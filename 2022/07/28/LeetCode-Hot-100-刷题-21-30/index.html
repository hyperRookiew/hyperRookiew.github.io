<!DOCTYPE html>
<html lang="en" color-mode="light">

  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  
  <meta name="author" content="John Doe" />
  <meta name="description" content="" />
  
  
  <title>
    
      LeetCode Hot 100 刷题 [21-30] 
      
      
      |
    
     Hexo
  </title>

  
    <link rel="apple-touch-icon" href="/images/favicon.png">
    <link rel="icon" href="/images/favicon.png">
  

  <!-- Raleway-Font -->
  <link href="https://fonts.googleapis.com/css?family=Raleway&display=swap" rel="stylesheet">

  <!-- hexo site css -->
  <link rel="stylesheet" href="/css/main.css" />
  <link rel="stylesheet" href="//at.alicdn.com/t/font_1886449_67xjft27j1l.css" />
  <!-- 代码块风格 -->
  

  <!-- jquery3.3.1 -->
  
    <script defer type="text/javascript" src="/plugins/jquery.min.js"></script>
  

  <!-- fancybox -->
  
    <link href="/plugins/jquery.fancybox.min.css" rel="stylesheet">
    <script defer type="text/javascript" src="/plugins/jquery.fancybox.min.js"></script>
  
  
<script src="/js/fancybox.js"></script>


  

  

  <script>
    var html = document.documentElement
    const colorMode = localStorage.getItem('color-mode')
    if (colorMode) {
      document.documentElement.setAttribute('color-mode', colorMode)
    }
  </script>
<meta name="generator" content="Hexo 6.3.0"></head>


  <body>
    <div id="app">
      <div class="header">
  <div class="avatar">
    <a href="/">
      <!-- 头像取消懒加载，添加no-lazy -->
      
        <img src="/images/avatar.png" alt="">
      
    </a>
    <div class="nickname"><a href="/">欢迎来到我的博客!</a></div>
  </div>
  <div class="navbar">
    <ul>
      
        <li class="nav-item" data-path="/">
          <a href="/">主页</a>
        </li>
      
        <li class="nav-item" data-path="/archives/">
          <a href="/archives/">归档</a>
        </li>
      
        <li class="nav-item" data-path="/tags/">
          <a href="/tags/">标签</a>
        </li>
      
        <li class="nav-item" data-path="/friends/">
          <a href="/friends/">朋友</a>
        </li>
      
        <li class="nav-item" data-path="/about/">
          <a href="/about/">关于</a>
        </li>
      
    </ul>
  </div>
</div>


<script src="/js/activeNav.js"></script>



      <div class="flex-container">
        <!-- 文章详情页，展示文章具体内容，url形式：https://yoursite/文章标题/ -->
<!-- 同时为「标签tag」，「朋友friend」，「分类categories」，「关于about」页面的承载页面，具体展示取决于page.type -->


  <!-- LaTex Display -->

  
    <script async type="text/javascript" src="/plugins/mathjax/tex-chtml.js"></script>
  
  <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      }
    }
  </script>





  <!-- clipboard -->

  
    <script async type="text/javascript" src="/plugins/clipboard.min.js"></script>
  
  
<script src="/js/codeCopy.js"></script>







  

  

  

  
  <!-- 文章内容页 url形式：https://yoursite/文章标题/ -->
  <div class="container post-details" id="post-details">
    <div class="post-content">
      <div class="post-title">LeetCode Hot 100 刷题 [21-30]</div>
      <div class="post-attach">
        <span class="post-pubtime">
          <i class="iconfont icon-updatetime mr-10" title="Update time"></i>
          2023-07-15 17:13:23
        </span>
        
              <span class="post-tags">
                <i class="iconfont icon-tags mr-10" title="Tags"></i>
                
                <span class="span--tag mr-8">
                  <a href="/tags/LeetCode/" title="LeetCode">
                    #LeetCode
                  </a>
                </span>
                
                <span class="span--tag mr-8">
                  <a href="/tags/%E7%AE%97%E6%B3%95/" title="算法">
                    #算法
                  </a>
                </span>
                
              </span>
          
      </div>
      <div class="markdown-body">
        <h1 id="LeetCode-Hot-100-11-20"><a href="#LeetCode-Hot-100-11-20" class="headerlink" title="LeetCode Hot 100 [11-20]"></a>LeetCode Hot 100 [11-20]</h1><blockquote>
<p>刷完了《剑指Offer》，下一阶段，开始 LeetCode Hot 100。 之前一直都用思维导图记录，今天发现思维导图可以导出成markdown，简单编辑一下就可以成为文章。相比Xmind，博客文章打开和查看更加方便，所以之后每次Xmind记录之后，会再在这里同时同步一下</p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>HOT100，之前的文章传送门<br><a target="_blank" rel="noopener" href="http://blog.zwboy.cn/suan-fa/leetcode/leetcode-hot100-shua-ti-1-10.html">LeetCode Hot 100 刷题 [1-10]</a><br><a target="_blank" rel="noopener" href="http://blog.zwboy.cn/suan-fa/leetcode/leetcode-hot-100-shua-ti-11-20.html">LeetCode Hot 100 刷题 [11-20]</a></p>
<h2 id="21-接雨水问题"><a href="#21-接雨水问题" class="headerlink" title="21.接雨水问题"></a>21.接雨水问题</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><blockquote>
<ul>
<li>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</li>
</ul>
</blockquote>
<ul>
<li>输入: [0,1,0,2,1,0,1,3,2,1,2,1]</li>
<li>输出: 6</li>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/trapping-rain-water/">题目地址</a></li>
<li>这是一道Hard题</li>
</ul>
<p>	</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="思路1：暴力算法"><a href="#思路1：暴力算法" class="headerlink" title="思路1：暴力算法"></a>思路1：暴力算法</h4><ul>
<li>按列，统计每个列上可以存的雨水的量</li>
<li>如何计算某个列上存水的量<ol>
<li>遍历找出该列左边的最大高度，maxleft</li>
<li>遍历找出该列右边的最大高度，maxRight</li>
<li>水的高度取决于maxLeft和maxRight中的较小者</li>
<li>这个列上水的深度为水的高度 - 该列的高度</li>
</ol>
</li>
<li>代码实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>; i &lt; height.length; i++)&#123;</span><br><span class="line">          <span class="comment">// find max left</span></span><br><span class="line">          <span class="type">int</span> <span class="variable">leftMax</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">              leftMax = Math.max(leftMax, height[j]);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// find max right</span></span><br><span class="line">          <span class="type">int</span> <span class="variable">rightMax</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i+<span class="number">1</span>; j&lt;height.length; j++)&#123;</span><br><span class="line">              rightMax = Math.max(rightMax, height[j]);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="type">int</span> <span class="variable">validHeight</span> <span class="operator">=</span> Math.min(leftMax,rightMax);</span><br><span class="line">          res += Math.max(<span class="number">0</span>, validHeight-height[i]);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li>算法复杂度<ul>
<li>时间复杂度O(N^2)</li>
</ul>
</li>
</ul>
<h4 id="思路2：动态规划"><a href="#思路2：动态规划" class="headerlink" title="思路2：动态规划"></a>思路2：动态规划</h4><ul>
<li>对思路1进行优化，思路1中查找左右最大值的过程可以通过DP优化</li>
<li>定义maxLeftDP[ i ] 为 i 左边的最大高度，同理，maxRightDp[ i ]为 i 右边的最大高度 </li>
<li>maxLeftDP[ i ] &#x3D; Max{ maxLeftDP[ i-1 ] , height[ i-1 ] }</li>
<li>代码实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="type">int</span> [] maxLeftDP = <span class="keyword">new</span> <span class="title class_">int</span> [height.length];</span><br><span class="line">       <span class="type">int</span> [] maxRightDP = <span class="keyword">new</span> <span class="title class_">int</span> [height.length];</span><br><span class="line">       <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> height.length;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; size-<span class="number">1</span>; i++)&#123;</span><br><span class="line">           maxLeftDP[i] = Math.max(maxLeftDP[i-<span class="number">1</span>], height[i-<span class="number">1</span>]);</span><br><span class="line">           maxRightDP[size-<span class="number">1</span>- i] = Math.max(maxRightDP[ size-i], height[size-i]);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; height.length-<span class="number">1</span>; i++)&#123;</span><br><span class="line">           <span class="type">int</span> <span class="variable">validHeight</span> <span class="operator">=</span> Math.min(maxLeftDP[i],maxRightDP[i]);</span><br><span class="line">           res += Math.max(<span class="number">0</span>, validHeight-height[i]);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
<li>复杂度分析<ul>
<li>时间复杂度O(N)</li>
<li>空间复杂度O(N)</li>
</ul>
</li>
</ul>
<h4 id="思路3：双指针解法"><a href="#思路3：双指针解法" class="headerlink" title="思路3：双指针解法"></a>思路3：双指针解法</h4><ul>
<li>对思路2中的空间复杂度还可以进一步优化</li>
<li>DP递推方程中，maxLeft和maxRight其实只用到左右边的一个，其实可以不用数组来存储</li>
<li>maxLeftDP是直接可以用变量来替代的，但是maxRightDP的求解是从右向左的，不方便直接用变量来替代</li>
<li>思路与过程<ul>
<li>left、right双指针从两端进行更新</li>
<li>maxLeft、maxRight记录left和right位置对应的左右最大值</li>
<li>maxLeft和maxRight中，起作用的是他们中的较小值，所以每次left和right指针更新较小值的一端</li>
</ul>
</li>
<li>如何选择更新哪一段<ul>
<li>maxLeft &lt; maxRight<ul>
<li>可以保证maxLeft为left左边最大值，且它是起作用的</li>
<li>left指针前进，同时更新maxleft<br>  maxLeft &gt; maxRight</li>
<li>同理，可以保障maxRight为right右边最大值，且它比maxLeft要小，所以即便加上右边还没检查的部分，最终的maxLeft还是比maxRight大，即起作用的还是maxRight</li>
<li>所以，right指针前进，同时更新maxRight</li>
</ul>
</li>
<li>让我想起了类似的用双指针求最大面积的题目<ul>
<li>每次搜索高度较小的一边</li>
</ul>
</li>
</ul>
</li>
<li>代码实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = height.length - <span class="number">1</span>;</span><br><span class="line">       <span class="type">int</span> <span class="variable">maxLeft</span> <span class="operator">=</span> <span class="number">0</span>, maxRight = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span>( left &lt;= right)&#123;</span><br><span class="line">           <span class="comment">// maxLeft 起作用</span></span><br><span class="line">           <span class="keyword">if</span>( height[left] &lt; maxRight &amp;&amp; maxLeft &lt; maxRight )&#123;</span><br><span class="line">               <span class="keyword">if</span>( height[left] &gt; maxLeft )&#123;</span><br><span class="line">                   maxLeft = height[left];</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   res += maxLeft - height[left];</span><br><span class="line">               &#125; </span><br><span class="line">               left++;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123; <span class="comment">// maxRight 起作用</span></span><br><span class="line">               <span class="keyword">if</span>( height[right] &gt; maxRight )&#123;</span><br><span class="line">                   maxRight = height[right];</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   res += maxRight - height[right];</span><br><span class="line">               &#125; </span><br><span class="line">               right--;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
<li>复杂度分析<ul>
<li>时间复杂度O(N)</li>
<li>空间复杂度O(1)</li>
</ul>
</li>
</ul>
<h2 id="22-旋转图像"><a href="#22-旋转图像" class="headerlink" title="22.旋转图像"></a>22.旋转图像</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><blockquote>
<ul>
<li>给定一个 n × n 的二维矩阵表示一个图像。</li>
</ul>
</blockquote>
<ul>
<li>将图像顺时针旋转 90 度。</li>
<li>你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。</li>
<li>给定 matrix &#x3D; <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],</span><br><span class="line">  [<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li>
<li>原地旋转输入矩阵，使其变为:<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">7</span>,<span class="number">4</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">8</span>,<span class="number">5</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">9</span>,<span class="number">6</span>,<span class="number">3</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/rotate-image">题目地址</a></li>
</ul>
<h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="思路1：转置-行交换"><a href="#思路1：转置-行交换" class="headerlink" title="思路1：转置+行交换"></a>思路1：转置+行交换</h4><ul>
<li>思路与过程<ol>
<li>将行按照对称的方式进行交换<ul>
<li>a[i][j] 与 a[ len-i-1 ][j]交换</li>
</ul>
</li>
<li>将处理后的矩阵按对角进行转置<ul>
<li>a[i][j] 与 a[j][i]交换</li>
</ul>
</li>
</ol>
</li>
<li>代码实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">       <span class="comment">// 水平交换</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = matrix.length-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span>( left &lt; right)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; matrix[<span class="number">0</span>].length;i++)&#123;</span><br><span class="line">               rowSwap(matrix, left, right, i);</span><br><span class="line">           &#125;</span><br><span class="line">           left++;</span><br><span class="line">           right--;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 对角线对称</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;matrix.length; i++)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j&lt; i; j++)&#123;</span><br><span class="line">               angleSwap(matrix,i,j);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rowSwap</span><span class="params">(<span class="type">int</span> [][] matrix, <span class="type">int</span> left, <span class="type">int</span> right , <span class="type">int</span> i)</span>&#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> matrix[left][i];</span><br><span class="line">       matrix[left][i] = matrix[right][i];</span><br><span class="line">       matrix[right][i] = temp;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">angleSwap</span><span class="params">(<span class="type">int</span> [][] matrix, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> matrix[i][j];</span><br><span class="line">       matrix[i][j] = matrix[j][i];</span><br><span class="line">       matrix[j][i] = temp;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
<li>复杂度评估<ul>
<li>时间复杂度O(N^2)</li>
</ul>
</li>
</ul>
<h2 id="23-字母异位词分组"><a href="#23-字母异位词分组" class="headerlink" title="23.字母异位词分组"></a>23.字母异位词分组</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><blockquote>
<ul>
<li>给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。</li>
</ul>
</blockquote>
<ul>
<li>输入: [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”]</li>
<li>输出:<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="string">&quot;ate&quot;</span>,<span class="string">&quot;eat&quot;</span>,<span class="string">&quot;tea&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;nat&quot;</span>,<span class="string">&quot;tan&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;bat&quot;</span>]</span><br><span class="line">]</span><br><span class="line">```		</span><br><span class="line">- 所有输入均为小写字母。</span><br><span class="line">- 不考虑答案输出的顺序。</span><br><span class="line">- [题目地址](https:<span class="comment">//leetcode-cn.com/problems/group-anagrams/)</span></span><br><span class="line"></span><br><span class="line">### 解题思路</span><br><span class="line">#### 思路<span class="number">1</span>：排序 + HashMap</span><br><span class="line">- 对每一个字符串的字符按字典序进行排序</span><br><span class="line">- 将排序后的结果作为HashMap的key，value为列表</span><br><span class="line">- 最终将HashMap的values输出为列表</span><br><span class="line">    - values()，返回的是数组，不是List，需要将数组转化成list</span><br><span class="line">	- Java8 Stream API:`hashMap.values().stream().collect(Collectors.toList())`</span><br><span class="line">	- Java8之前：`<span class="keyword">new</span> <span class="title class_">ArrayList</span>(hashMap.values())`</span><br><span class="line">- 代码实现</span><br><span class="line">```java</span><br><span class="line">	<span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">groupAnagrams</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">        HashMap&lt;String, List&lt;String&gt;&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="keyword">for</span>(String str : strs)&#123;</span><br><span class="line">            <span class="type">char</span> [] values = str.toCharArray();</span><br><span class="line">            Arrays.sort(values);</span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(values);</span><br><span class="line">            <span class="keyword">if</span>(hashMap.containsKey(key))&#123;</span><br><span class="line">                hashMap.get(key).add(str);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">                list.add(str);</span><br><span class="line">                hashMap.put(key,list);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hashMap.values().stream().collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li>复杂度分析<ul>
<li>时间复杂度O(Nklogk)</li>
<li>空间复杂度O(NK)</li>
</ul>
</li>
</ul>
<h4 id="思路2：字符计数-HashMap"><a href="#思路2：字符计数-HashMap" class="headerlink" title="思路2：字符计数 + HashMap"></a>思路2：字符计数 + HashMap</h4><ul>
<li>与思路1基本类似，只是key的生成方式不一样</li>
<li>思路1需要排序，O(klogk)，还是比较高的</li>
<li>可以统计每个字符串中26个字母出现的次数，作为模式，模式作为hashmap的key<ul>
<li>计数模式：<code>int [ ] count = new int [26]</code></li>
<li>最后的模式串：<code>1#0#6#...</code></li>
</ul>
</li>
<li>代码实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">groupAnagrams</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">       HashMap&lt;String, List&lt;String&gt;&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">       <span class="type">int</span> [] count = <span class="keyword">new</span> <span class="title class_">int</span> [<span class="number">26</span>];</span><br><span class="line">       <span class="keyword">for</span>(String str : strs)&#123;</span><br><span class="line">           <span class="type">char</span> [] values = str.toCharArray();</span><br><span class="line">           Arrays.fill(count, <span class="number">0</span>);</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">char</span> ch : values)&#123;</span><br><span class="line">               count[ch-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> num:count)&#123;</span><br><span class="line">               builder.append(num);</span><br><span class="line">               builder.append(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> builder.toString();</span><br><span class="line">           <span class="keyword">if</span>(hashMap.containsKey(key))&#123;</span><br><span class="line">               hashMap.get(key).add(str);</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">               list.add(str);</span><br><span class="line">               hashMap.put(key,list);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> hashMap.values().stream().collect(Collectors.toList());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
<li>复杂度分析<ul>
<li>时间复杂度O(NK)</li>
<li>空间复杂度O(NK)</li>
</ul>
</li>
</ul>
<h2 id="24-跳跃游戏"><a href="#24-跳跃游戏" class="headerlink" title="24.跳跃游戏"></a>24.跳跃游戏</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><blockquote>
<ul>
<li>给定一个非负整数数组，你最初位于数组的第一个位置。</li>
</ul>
</blockquote>
<ul>
<li>数组中的每个元素代表你在该位置可以跳跃的最大长度。</li>
<li>判断你是否能够到达最后一个位置。</li>
<li>输入: [2,3,1,1,4]</li>
<li>输出: true</li>
<li>解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。</li>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/jump-game/">题目地址</a></li>
</ul>
<h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="思路1：排除法"><a href="#思路1：排除法" class="headerlink" title="思路1：排除法"></a>思路1：排除法</h4><ul>
<li>研究什么时候跳不到终点<ol>
<li>序列中有 0 的时候，才会可能跳不到终点</li>
<li>当 0 前边所有的数都无法跳过 0 ，则必定跳不过去<ul>
<li>即该位置的值，小于等于该位置距离0的格数</li>
</ul>
</li>
<li>最后一个为0不影响</li>
</ol>
</li>
<li>思路过程</li>
</ul>
<ol>
<li>遍历数组，检索所有的0<ul>
<li>最后一个位置是否为0不影响，所以不用判断</li>
</ul>
</li>
<li>对每一个0， 向前遍历，是否存在能跳跃过它的数</li>
<li>所有的都满足，则可以到达最后一个位置</li>
</ol>
<ul>
<li>代码实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canJump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;        </span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i &lt; nums.length-<span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="comment">// 最后一个是0还是非0对结果不影响</span></span><br><span class="line">           <span class="keyword">if</span>(nums[i] == <span class="number">0</span>)&#123;</span><br><span class="line">               <span class="type">int</span> j,dis=<span class="number">1</span>;</span><br><span class="line">               <span class="keyword">for</span>(j = i-<span class="number">1</span>; j &gt;= <span class="number">0</span>; j--,dis++)&#123;</span><br><span class="line">                   <span class="keyword">if</span>(nums[j] &gt; dis) <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span>(j &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
<li>复杂度分析<ul>
<li>时间复杂度O(N^2)</li>
<li>空间复杂度O(1)</li>
</ul>
</li>
</ul>
<h4 id="思路2：贪心算法"><a href="#思路2：贪心算法" class="headerlink" title="思路2：贪心算法"></a>思路2：贪心算法</h4><ul>
<li>是本题的最优解法，也应该是主要的考察点</li>
<li>比较不容易想到贪心规则</li>
<li>某一位置可达，则该位置之前的位置均是可达的</li>
<li>所以，只要保障能到达的位置超过数组最后一个位置就可以了<ul>
<li>因此，每次都尽可能的向远处跳</li>
</ul>
</li>
<li>思路过程</li>
</ul>
<ol>
<li>mostFarIndex 标识目前能到达的最远位置</li>
<li>当前位置在最远位置或之前，则说明最远位置可能还可以更大，更新最远位置</li>
<li>若当前位置在最远位置之后了，则最远位置再也没法更新了，也就最终无法超越最后一个位置了</li>
</ol>
<ul>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canJump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;        </span><br><span class="line">       <span class="type">int</span> <span class="variable">mostFarIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i &lt; nums.length-<span class="number">1</span>; i++)&#123; <span class="comment">// 最后一个不影响</span></span><br><span class="line">           <span class="keyword">if</span>( i &lt;= mostFarIndex )&#123;</span><br><span class="line">               mostFarIndex = Math.max(mostFarIndex, i + nums[i]);</span><br><span class="line">               <span class="keyword">if</span>(mostFarIndex &gt;= nums.length-<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> mostFarIndex &gt;= nums.length-<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>复杂度分析</p>
<ul>
<li>时间复杂度O(N)</li>
<li>空间复杂度O(1)</li>
</ul>
</li>
</ul>
<h2 id="25-合并区间"><a href="#25-合并区间" class="headerlink" title="25.合并区间"></a>25.合并区间</h2><h3 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h3><blockquote>
<ul>
<li>出一个区间的集合，请合并所有重叠的区间。</li>
</ul>
</blockquote>
<ul>
<li>示例</li>
<li>输入: [[1,3],[2,6],[8,10],[15,18]]</li>
<li>输出: [[1,6],[8,10],[15,18]]</li>
<li>解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</li>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-intervals">题目链接</a></li>
</ul>
<h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>先将区间按照左边界的大小排序<ul>
<li>lambda实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(intervals, (<span class="type">int</span> [] a, <span class="type">int</span> [] b)-&gt;&#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>] - b[<span class="number">0</span>];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>然后遍历区间数组，相邻的区间能合并则合并</li>
<li>代码实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[][] merge(<span class="type">int</span>[][] intervals) &#123;</span><br><span class="line">       <span class="keyword">if</span>(intervals.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">       ArrayList&lt;<span class="type">int</span> []&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">       <span class="comment">// 按第一个排序</span></span><br><span class="line">       Arrays.sort(intervals, (<span class="type">int</span> [] a, <span class="type">int</span> [] b)-&gt;&#123;</span><br><span class="line">           <span class="keyword">return</span> a[<span class="number">0</span>] - b[<span class="number">0</span>];</span><br><span class="line">       &#125;);</span><br><span class="line">       <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> intervals[<span class="number">0</span>][<span class="number">0</span>], end = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;intervals.length; i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(intervals[i][<span class="number">0</span>] &lt;= end)&#123;</span><br><span class="line">               end = Math.max(end, intervals[i][<span class="number">1</span>]);</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               res.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;start, end&#125;);</span><br><span class="line">               start = intervals[i][<span class="number">0</span>];</span><br><span class="line">               end = intervals[i][<span class="number">1</span>];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       res.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;start, end&#125;);</span><br><span class="line">       <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[res.size()][<span class="number">2</span>]);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
<li>复杂度分析<ul>
<li>O(NlogN)</li>
</ul>
</li>
</ul>
<h2 id="26-不同路径"><a href="#26-不同路径" class="headerlink" title="26.不同路径"></a>26.不同路径</h2><h3 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h3><blockquote>
<ul>
<li>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</li>
</ul>
</blockquote>
<ul>
<li>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</li>
<li>问总共有多少条不同的路径？</li>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/unique-paths">题目链接</a></li>
</ul>
<h3 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>典型的深度优先遍历，动态规划解题</li>
</ul>
<h4 id="思路1：DFS-回溯"><a href="#思路1：DFS-回溯" class="headerlink" title="思路1：DFS+回溯"></a>思路1：DFS+回溯</h4><ul>
<li>从左上角出发，分别尝试向下和向右，然后回溯</li>
<li>代码实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        dfs(<span class="number">0</span>,<span class="number">0</span>,m,n);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> m, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= m || j &gt;= n) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>( i == m-<span class="number">1</span> &amp;&amp; j == n-<span class="number">1</span>)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 向右尝试</span></span><br><span class="line">        <span class="keyword">if</span>(j &lt; n-<span class="number">1</span>)&#123;</span><br><span class="line">            dfs(i,j+<span class="number">1</span>,m,n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 向左尝试</span></span><br><span class="line">        <span class="keyword">if</span>(i &lt; m -<span class="number">1</span>)&#123;</span><br><span class="line">            dfs(i+<span class="number">1</span>, j, m,n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>复杂度分析<ul>
<li>时间复杂度O((M+N)^2)</li>
<li>空间复杂度O(（M+N）^2)</li>
</ul>
</li>
</ul>
<h4 id="思路2：动态规划-1"><a href="#思路2：动态规划-1" class="headerlink" title="思路2：动态规划"></a>思路2：动态规划</h4><ul>
<li>dp[ i ][ j ]：到达坐标(i,j)位置有多少个路径<ul>
<li>&#x3D; dp[ i-1 ]dp[ j ] + dp[ i ][ j-1 ]</li>
</ul>
</li>
<li>思路过程<ol>
<li>创建二维dp数组，并进行初始化</li>
<li>dp数组的第一行和第一类初始化为1，因为可以确定只有1个路径</li>
<li>对dp数组进行填表操作</li>
</ol>
</li>
<li>代码实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> [][] dp = <span class="keyword">new</span> <span class="title class_">int</span> [m][n];</span><br><span class="line">    Arrays.fill(dp[<span class="number">0</span>], <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">            dp[i][j] = dp[i-<span class="number">1</span>][j] + dp[i][j-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>复杂度分析<ul>
<li>时间复杂度O(M*N)</li>
<li>空间复杂度O(M*N)</li>
</ul>
</li>
</ul>
<h4 id="思路3：动态规划空间优化"><a href="#思路3：动态规划空间优化" class="headerlink" title="思路3：动态规划空间优化"></a>思路3：动态规划空间优化</h4><ul>
<li>思路2中的dp二维数组，可以继续优化成一维数组</li>
<li>因为递归关系中，只使用到了坐标左边和左边上边的位置</li>
<li>代码实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> [] dp = <span class="keyword">new</span> <span class="title class_">int</span> [n];</span><br><span class="line">    Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">            dp[j] = dp[j-<span class="number">1</span>] + dp[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="27-最小路径和"><a href="#27-最小路径和" class="headerlink" title="27. 最小路径和"></a>27. 最小路径和</h2><h3 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h3><blockquote>
<ul>
<li>给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</li>
</ul>
</blockquote>
<ul>
<li>说明：每次只能向下或者向右移动一步。</li>
<li>输入:<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">5</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li>
<li>输出: 7</li>
<li>解释: 因为路径 1→3→1→1→1 的总和最小。</li>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-path-sum">link</a></li>
</ul>
<h3 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>思路明显，二维数组动态规划</li>
<li>dp[ i ][ j ]：从起点到达 (i , j)位置的路径和<ul>
<li>dp[ i ][ j ] &#x3D; Math.min(dp[ i ][j-1], dp[ i-1 ][ j ]) + grid[i][j];</li>
<li>只用到了左边和上边的位置，所以可以优化到一维数组</li>
<li>初始状态，i&#x3D;0 以及 j &#x3D; 0，第0行和第0列的初始化</li>
</ul>
</li>
<li>代码实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minPathSum</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span>(grid.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="type">int</span> dp[] = <span class="keyword">new</span> <span class="title class_">int</span> [grid[<span class="number">0</span>].length];</span><br><span class="line">       dp[<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> ; i &lt; dp.length; i++)&#123;</span><br><span class="line">           dp[i] = dp[i-<span class="number">1</span>] + grid[<span class="number">0</span>][i];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i&lt;grid.length; i++)&#123;</span><br><span class="line">           dp[<span class="number">0</span>] += grid[i][<span class="number">0</span>]; </span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j&lt;dp.length; j++)&#123;</span><br><span class="line">               dp[j] = Math.min(dp[j-<span class="number">1</span>], dp[j]) + grid[i][j];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> dp[dp.length-<span class="number">1</span>];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
<li>复杂度分析<ul>
<li>时间复杂度O(N*M)</li>
<li>空间复杂度O(M)</li>
</ul>
</li>
</ul>
<h2 id="28-编辑距离"><a href="#28-编辑距离" class="headerlink" title="28. 编辑距离"></a>28. 编辑距离</h2><h3 id="题目-7"><a href="#题目-7" class="headerlink" title="题目"></a>题目</h3><blockquote>
<ul>
<li>给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。</li>
</ul>
</blockquote>
<ul>
<li>你可以对一个单词进行如下三种操作：<ul>
<li>插入一个字符</li>
<li>删除一个字符</li>
<li>替换一个字符</li>
</ul>
</li>
<li>输入：word1 &#x3D; “horse”, word2 &#x3D; “ros”</li>
<li>输出：3</li>
<li>解释:<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">horse -&gt; rorse (将 <span class="string">&#x27;h&#x27;</span> 替换为 <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">rorse -&gt; rose (删除 <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">rose -&gt; ros (删除 <span class="string">&#x27;e&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/edit-distance">link</a></li>
</ul>
<h3 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>动态规划解题</li>
</ul>
<ol>
<li>求最优解问题</li>
<li>是可以分阶段进行的<ul>
<li>每个阶段有插入、删除、替换三个选择</li>
<li>插入、删除、替换设定都在末尾进行<ul>
<li>等价的，在中间插入也是可以转换到尾部操作的</li>
</ul>
</li>
</ul>
</li>
<li>最优子结构<ul>
<li>dp[ i ][ j ]，表示将word1的前 i 位 转换成 word2的前 j 位需要的最少操作数</li>
<li>它可以通过三种方式获得，且取三种方式中的最小值</li>
</ul>
<ol>
<li>word1末尾插入<ul>
<li>dp[ i ][ j ] &#x3D; dp[ i-1 ][ j ] + 1;</li>
<li>hors -&gt; ros 需要a步，则horse -&gt; ros 需要 a+1 步</li>
</ul>
</li>
<li>word1末尾删除<ul>
<li>dp[ i ][ j ] &#x3D; dp[ i ][ j-1 ] + 1;</li>
<li>hors -&gt; ro需要 b 步，则 hors -&gt; ros 需要 b+1 步</li>
</ul>
</li>
<li>word1末尾替换<ul>
<li>dp[ i ][ j ] &#x3D; dp[ i-1 ][ j-1 ] + 1 ，如果 i 和 j 字符不同， 则需要额外一次替换操作<ul>
<li>hors - &gt; ro 为 c， 则horo -&gt; ro需要额外一次替换操作</li>
</ul>
</li>
<li>dp[ i ][ j ] &#x3D; dp[ i-1 ][ j ] , 如果 i 和 j 字符相同，则不需要额外一次操作 <ul>
<li>hor -&gt; ro 为 d ，则 hors -&gt; ros 为 d</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<ul>
<li>代码实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String word1, String word2)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">len1</span> <span class="operator">=</span> word1.length(), len2 = word2.length();</span><br><span class="line">       <span class="keyword">if</span>(len1 == <span class="number">0</span>) <span class="keyword">return</span> len2;</span><br><span class="line">       <span class="keyword">if</span>(len2 == <span class="number">0</span>) <span class="keyword">return</span> len1;</span><br><span class="line">       <span class="type">int</span> dp[][] = <span class="keyword">new</span> <span class="title class_">int</span> [len1 +<span class="number">1</span> ][len2+<span class="number">1</span>];</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= len1; i++ )&#123;</span><br><span class="line">           dp[i][<span class="number">0</span>] = i;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;= len2; i++)&#123;</span><br><span class="line">           dp[<span class="number">0</span>][i] = i;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= len1; i++)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= len2; j++)&#123;</span><br><span class="line">               <span class="type">int</span> <span class="variable">insert</span> <span class="operator">=</span> dp[i-<span class="number">1</span>][j] + <span class="number">1</span>;</span><br><span class="line">               <span class="type">int</span> <span class="variable">remove</span> <span class="operator">=</span> dp[i][j-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">               <span class="type">int</span> <span class="variable">replace</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">               <span class="keyword">if</span>(word1.charAt(i-<span class="number">1</span>) == word2.charAt(j-<span class="number">1</span>))&#123;</span><br><span class="line">                   replace = dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   replace = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               dp[i][j] = Stream.of(insert,remove, replace)</span><br><span class="line">               .min(Comparator.comparing(Integer::valueOf)).get();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> dp[len1][len2];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
<li>复杂度分析<ul>
<li>时间复杂度O(M*N)</li>
<li>空间复杂度O(M*N)</li>
</ul>
</li>
</ul>
<h2 id="29-颜色排序"><a href="#29-颜色排序" class="headerlink" title="29. 颜色排序"></a>29. 颜色排序</h2><h3 id="题目-8"><a href="#题目-8" class="headerlink" title="题目"></a>题目</h3><blockquote>
<ul>
<li>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</li>
</ul>
</blockquote>
<ul>
<li>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</li>
<li>不能使用代码库中的排序函数来解决这道题。</li>
<li>输入: [2,0,2,1,1,0]</li>
<li>输出: [0,0,1,1,2,2]</li>
<li>进阶<ul>
<li>一个直观的解决方案是使用计数排序的两趟扫描算法。</li>
<li>首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。</li>
<li>你能想出一个仅使用常数空间的一趟扫描算法吗？</li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sort-colors">题目地址</a></li>
</ul>
<p>	</p>
<h3 id="解题思路-7"><a href="#解题思路-7" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="思路1：计数排序算法"><a href="#思路1：计数排序算法" class="headerlink" title="思路1：计数排序算法"></a>思路1：计数排序算法</h4><ul>
<li>计数排序<ol>
<li>数组统计各种元素的出现频数</li>
<li>对频数数组进行连续累加，对应的数字便是该类值插入位置的后一个</li>
<li>读取原数组中的数字，并查找频数数组，确定插入的位置<ul>
<li>插入成功之后，频数数组对应的值-1</li>
<li>即，插入位置前移一个</li>
</ul>
</li>
</ol>
</li>
<li>这里由于只要对值排序就可以，相同的值之间没有差异，所以得到频数数组之后，直接更改原数组即可</li>
<li>代码实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sortColors</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">       <span class="type">int</span>[] count = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">           count[nums[i]]++;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count.length; i++) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; count[i]; j++) &#123;</span><br><span class="line">               nums[index] = i;</span><br><span class="line">               index++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
<li>复杂度分析<ul>
<li>时间复杂度O(K+N)</li>
<li>空间复杂度O(K)</li>
</ul>
</li>
</ul>
<h4 id="思路2：双指针算法"><a href="#思路2：双指针算法" class="headerlink" title="思路2：双指针算法"></a>思路2：双指针算法</h4><ul>
<li>类似三路排序的效果，能够高效处理含有大量重复元素的情况</li>
<li>一路指针标记0的插入位置，另一路标记2的插入位置，0和2排序好了，中间剩下的1便也排序好了</li>
<li>代码实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sortColors</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">       <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> left;</span><br><span class="line">       <span class="keyword">while</span> (index &lt;= right) &#123;</span><br><span class="line">           <span class="keyword">if</span> (nums[index] == <span class="number">0</span>) &#123;</span><br><span class="line">               swap(nums, index, left);</span><br><span class="line">               left++;</span><br><span class="line">               index++;</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[index] == <span class="number">2</span>) &#123;</span><br><span class="line">               swap(nums, index, right);</span><br><span class="line">               right--;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               index++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
<li>复杂度分析<ul>
<li>时间复杂度O(N)</li>
<li>空间复杂度O(1)</li>
</ul>
</li>
</ul>
<h2 id="30-最小包含子串"><a href="#30-最小包含子串" class="headerlink" title="30.最小包含子串"></a>30.最小包含子串</h2><h3 id="题目-9"><a href="#题目-9" class="headerlink" title="题目"></a>题目</h3><blockquote>
<ul>
<li>给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字符的最小子串。</li>
</ul>
</blockquote>
<ul>
<li>输入: S &#x3D; “ADOBECODEBANC”, T &#x3D; “ABC”</li>
<li>输出: “BANC”</li>
<li>如果 S 中不存这样的子串，则返回空字符串 “”。</li>
<li>如果 S 中存在这样的子串，我们保证它是唯一的答案。</li>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-window-substring">link</a></li>
</ul>
<h3 id="解题思路-8"><a href="#解题思路-8" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>滑动窗口解题的典型例题</li>
<li>T字符中可能存在重复字符<ul>
<li>对字符进行计数</li>
<li>可以使用数组统计128所有字符</li>
<li>也可以通过HashMap，只统计出现的字符  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">char</span> c : tValues) &#123;</span><br><span class="line">       <span class="keyword">if</span> (tMap.containsKey(c)) &#123;</span><br><span class="line">           tMap.put(c, tMap.get(c) + <span class="number">1</span>);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           tMap.put(c, <span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>检测当前窗口是否包含T所有字符<ul>
<li>distance，即窗口内容与T之间的距离</li>
<li>当字符出现在T中，且该字符能缩小窗口与T距离的时候，distance++  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符在t中，更改distance</span></span><br><span class="line">      <span class="keyword">if</span> (winMap.containsKey(sValues[right])) &#123;</span><br><span class="line">          <span class="keyword">if</span> (winMap.get(sValues[right]) &lt; tMap.get(sValues[right])) &#123;</span><br><span class="line">              distance++;</span><br><span class="line">          &#125;</span><br><span class="line">          winMap.put(sValues[right], winMap.get(sValues[right]) + <span class="number">1</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          winMap.put(sValues[right], <span class="number">1</span>);</span><br><span class="line">          distance++;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>思路与过程</li>
</ul>
<ol>
<li>通过HashMap，统计T字符串中字符的出现次数</li>
<li>left，right&#x3D;0，窗口从左出发</li>
<li>先right右移，right位置元素未在TMap中，则继续右移</li>
<li>当right位置元素出现在TMap中<ul>
<li>如果SMap中该字符数目 &lt; TMap中该字符数目<ul>
<li>distance++</li>
<li>说明该字符能有效降低窗口和T之间的距离</li>
<li>若大于等于，说明该元素重复了</li>
</ul>
</li>
<li>然后SMap中该字符数目+1</li>
</ul>
</li>
<li>检测distance<ul>
<li>如果比T的长度小，则right继续右移</li>
<li>如果和T长度相等，说明当前窗口是满足包含所有T字符的子串，但需要缩小到最小子串</li>
</ul>
</li>
<li>left指针右移<ul>
<li>移动到distance不等于T长度为止</li>
<li>判断left位置字符是否出现在TMap中<ul>
<li>出现，若SMap中该字符频数 &lt;&#x3D; TMap中该字符频数，distance–</li>
</ul>
</li>
<li>SMap中该字符频数-1</li>
</ul>
</li>
<li>最终left的位置便是子串最左位置的下一个<ul>
<li>length &#x3D; right -left +2</li>
<li>更新最短长度以及其实位置</li>
</ul>
</li>
</ol>
<ul>
<li>代码实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">minWindow</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">       <span class="type">char</span>[] sValues = s.toCharArray();</span><br><span class="line">       <span class="type">char</span>[] tValues = t.toCharArray();</span><br><span class="line">       <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">       HashMap&lt;Character, Integer&gt; tMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">       HashMap&lt;Character, Integer&gt; winMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">       <span class="type">int</span> <span class="variable">distance</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="type">int</span> <span class="variable">minBegin</span> <span class="operator">=</span> <span class="number">0</span>, minLength = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (<span class="type">char</span> c : tValues) &#123;</span><br><span class="line">           <span class="keyword">if</span> (tMap.containsKey(c)) &#123;</span><br><span class="line">               tMap.put(c, tMap.get(c) + <span class="number">1</span>);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               tMap.put(c, <span class="number">1</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span> (right &lt; sValues.length) &#123;</span><br><span class="line">           <span class="comment">// right 右移</span></span><br><span class="line">           <span class="keyword">if</span> (!tMap.containsKey(sValues[right])) &#123;</span><br><span class="line">               <span class="comment">// 字符不在t中，right右移</span></span><br><span class="line">               right++;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 字符在t中，更改distance</span></span><br><span class="line">           <span class="keyword">if</span> (winMap.containsKey(sValues[right])) &#123;</span><br><span class="line">               <span class="keyword">if</span> (winMap.get(sValues[right]) &lt; tMap.get(sValues[right])) &#123;</span><br><span class="line">                   distance++;</span><br><span class="line">               &#125;</span><br><span class="line">               winMap.put(sValues[right], winMap.get(sValues[right]) + <span class="number">1</span>);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               winMap.put(sValues[right], <span class="number">1</span>);</span><br><span class="line">               distance++;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (distance &lt; t.length()) &#123;</span><br><span class="line">               right++;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 判断distance,等于t串长度的时候，left开始左移</span></span><br><span class="line">           <span class="keyword">while</span> (distance == t.length()) &#123;</span><br><span class="line">               <span class="keyword">if</span> (winMap.containsKey(sValues[left])) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (winMap.get(sValues[left]) &lt;= tMap.get(sValues[left])) &#123;</span><br><span class="line">                       distance--;</span><br><span class="line">                   &#125;</span><br><span class="line">                   winMap.put(sValues[left], winMap.get(sValues[left]) - <span class="number">1</span>);</span><br><span class="line">               &#125;</span><br><span class="line">               left++;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 最终，left为满足条件的左边界的下一个</span></span><br><span class="line">           <span class="keyword">if</span> (right - left + <span class="number">2</span> &lt; minLength) &#123;</span><br><span class="line">               minBegin = left - <span class="number">1</span>;</span><br><span class="line">               minLength = right - left + <span class="number">2</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           right++;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (minLength == Integer.MAX_VALUE) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> s.substring(minBegin, minBegin + minLength);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
<li>复杂度分析<ul>
<li>时间复杂度O(N+M)</li>
<li>空间复杂度O(N+M)</li>
</ul>
</li>
</ul>
<h2 id="下个路口见"><a href="#下个路口见" class="headerlink" title="下个路口见"></a>下个路口见</h2><p>HOT100依然在继续，写在下一篇文章中。<a target="_blank" rel="noopener" href="http://blog.zwboy.cn/suan-fa/leetcode/leetcode-hot-100-shua-ti-31-40.html">传送门</a></p>

      </div>
      
        <div class="prev-or-next">
          <div class="post-foot-next">
            
              <a href="/2022/07/23/LeetCode-Hot-100-%E5%88%B7%E9%A2%98-11-20/" target="_self">
                <i class="iconfont icon-chevronleft"></i>
                <span>Prev</span>
              </a>
            
          </div>
          <div class="post-attach">
            <span class="post-pubtime">
              <i class="iconfont icon-updatetime mr-10" title="Update time"></i>
              2023-07-15 17:13:23
            </span>
            
                  <span class="post-tags">
                    <i class="iconfont icon-tags mr-10" title="Tags"></i>
                    
                    <span class="span--tag mr-8">
                      <a href="/tags/LeetCode/" title="LeetCode">
                        #LeetCode
                      </a>
                    </span>
                    
                    <span class="span--tag mr-8">
                      <a href="/tags/%E7%AE%97%E6%B3%95/" title="算法">
                        #算法
                      </a>
                    </span>
                    
                  </span>
              
          </div>
          <div class="post-foot-prev">
            
              <a href="/2022/07/30/%E7%AE%97%E6%B3%95%E8%8C%83%E5%BC%8F%E7%B3%BB%E5%88%97-%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/" target="_self">
                <span>Next</span>
                <i class="iconfont icon-chevronright"></i>
              </a>
            
          </div>
        </div>
      
    </div>
    
  <div id="btn-catalog" class="btn-catalog">
    <i class="iconfont icon-catalog"></i>
  </div>
  <div class="post-catalog hidden" id="catalog">
    <div class="title">Contents</div>
    <div class="catalog-content">
      
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#LeetCode-Hot-100-11-20"><span class="toc-text">LeetCode Hot 100 [11-20]</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-%E6%8E%A5%E9%9B%A8%E6%B0%B4%E9%97%AE%E9%A2%98"><span class="toc-text">21.接雨水问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF"><span class="toc-text">解题思路</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF1%EF%BC%9A%E6%9A%B4%E5%8A%9B%E7%AE%97%E6%B3%95"><span class="toc-text">思路1：暴力算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF2%EF%BC%9A%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-text">思路2：动态规划</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF3%EF%BC%9A%E5%8F%8C%E6%8C%87%E9%92%88%E8%A7%A3%E6%B3%95"><span class="toc-text">思路3：双指针解法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F"><span class="toc-text">22.旋转图像</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-1"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-1"><span class="toc-text">解题思路</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF1%EF%BC%9A%E8%BD%AC%E7%BD%AE-%E8%A1%8C%E4%BA%A4%E6%8D%A2"><span class="toc-text">思路1：转置+行交换</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84"><span class="toc-text">23.字母异位词分组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-2"><span class="toc-text">题目</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF2%EF%BC%9A%E5%AD%97%E7%AC%A6%E8%AE%A1%E6%95%B0-HashMap"><span class="toc-text">思路2：字符计数 + HashMap</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F"><span class="toc-text">24.跳跃游戏</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-3"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-2"><span class="toc-text">解题思路</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF1%EF%BC%9A%E6%8E%92%E9%99%A4%E6%B3%95"><span class="toc-text">思路1：排除法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF2%EF%BC%9A%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95"><span class="toc-text">思路2：贪心算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4"><span class="toc-text">25.合并区间</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-4"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-3"><span class="toc-text">解题思路</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84"><span class="toc-text">26.不同路径</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-5"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-4"><span class="toc-text">解题思路</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF1%EF%BC%9ADFS-%E5%9B%9E%E6%BA%AF"><span class="toc-text">思路1：DFS+回溯</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF2%EF%BC%9A%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-1"><span class="toc-text">思路2：动态规划</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF3%EF%BC%9A%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%A9%BA%E9%97%B4%E4%BC%98%E5%8C%96"><span class="toc-text">思路3：动态规划空间优化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27-%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C"><span class="toc-text">27. 最小路径和</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-6"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-5"><span class="toc-text">解题思路</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB"><span class="toc-text">28. 编辑距离</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-7"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-6"><span class="toc-text">解题思路</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#29-%E9%A2%9C%E8%89%B2%E6%8E%92%E5%BA%8F"><span class="toc-text">29. 颜色排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-8"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-7"><span class="toc-text">解题思路</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF1%EF%BC%9A%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-text">思路1：计数排序算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF2%EF%BC%9A%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95"><span class="toc-text">思路2：双指针算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#30-%E6%9C%80%E5%B0%8F%E5%8C%85%E5%90%AB%E5%AD%90%E4%B8%B2"><span class="toc-text">30.最小包含子串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-9"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF-8"><span class="toc-text">解题思路</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8B%E4%B8%AA%E8%B7%AF%E5%8F%A3%E8%A7%81"><span class="toc-text">下个路口见</span></a></li></ol></li></ol>
      
    </div>
  </div>

  
<script src="/js/catalog.js"></script>




    
      <div class="comments-container">
        




  
    <script async type="text/javascript" src="/plugins/valine.min.js" onload="loadValineSuc(this)"></script>
  

  <div id="vcomments"></div>

  <script>
    function loadValineSuc() {
      new Valine({
        el: '#vcomments',
        appId: 'oOhVZyeGYClJeXi7hL6mMis8-gzGzoHsz',
        appKey: 'T2sc39tWFmhYbQiem6rTdkkc',
        placeholder: 'Welcome!',
        avatar: 'retro',
        lang: 'en'
      })
    }
  </script>

    <style>
      .comments-container .v .vempty {
        display: none!important;
      }
    </style>




      </div>
    
  </div>


        
<div class="footer">
  <div class="social">
    <ul>
      
        <li>
          <a title="github" target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">
            <i class="iconfont icon-github"></i>
          </a>
        </li>
      
    </ul>
  </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">Copyright © 2023 Oranges</a>
        
    </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/zchengsite/hexo-theme-oranges">Theme by Oranges | Powered by Hexo</a>
        
    </div>
  
  
</div>

      </div>

      <div class="tools-bar">
        <div class="back-to-top tools-bar-item hidden">
  <a href="javascript: void(0)">
    <i class="iconfont icon-chevronup"></i>
  </a>
</div>


<script src="/js/backtotop.js"></script>



        
  <div class="search-icon tools-bar-item" id="search-icon">
    <a href="javascript: void(0)">
      <i class="iconfont icon-search"></i>
    </a>
  </div>

  <div class="search-overlay hidden">
    <div class="search-content" tabindex="0">
      <div class="search-title">
        <span class="search-icon-input">
          <a href="javascript: void(0)">
            <i class="iconfont icon-search"></i>
          </a>
        </span>
        
          <input type="text" class="search-input" id="search-input" placeholder="搜索...">
        
        <span class="search-close-icon" id="search-close-icon">
          <a href="javascript: void(0)">
            <i class="iconfont icon-close"></i>
          </a>
        </span>
      </div>
      <div class="search-result" id="search-result"></div>
    </div>
  </div>

  <script type="text/javascript">
    var inputArea = document.querySelector("#search-input")
    var searchOverlayArea = document.querySelector(".search-overlay")

    inputArea.onclick = function() {
      getSearchFile()
      this.onclick = null
    }

    inputArea.onkeydown = function() {
      if(event.keyCode == 13)
        return false
    }

    function openOrHideSearchContent() {
      let isHidden = searchOverlayArea.classList.contains('hidden')
      if (isHidden) {
        searchOverlayArea.classList.remove('hidden')
        document.body.classList.add('hidden')
        // inputArea.focus()
      } else {
        searchOverlayArea.classList.add('hidden')
        document.body.classList.remove('hidden')
      }
    }

    function blurSearchContent(e) {
      if (e.target === searchOverlayArea) {
        openOrHideSearchContent()
      }
    }

    document.querySelector("#search-icon").addEventListener("click", openOrHideSearchContent, false)
    document.querySelector("#search-close-icon").addEventListener("click", openOrHideSearchContent, false)
    searchOverlayArea.addEventListener("click", blurSearchContent, false)

    var searchFunc = function (path, search_id, content_id) {
      'use strict';
      var $input = document.getElementById(search_id);
      var $resultContent = document.getElementById(content_id);
      $resultContent.innerHTML = "<ul><span class='local-search-empty'>First search, index file loading, please wait...<span></ul>";
      $.ajax({
        // 0x01. load xml file
        url: path,
        dataType: "xml",
        success: function (xmlResponse) {
          // 0x02. parse xml file
          var datas = $("entry", xmlResponse).map(function () {
            return {
              title: $("title", this).text(),
              content: $("content", this).text(),
              url: $("url", this).text()
            };
          }).get();
          $resultContent.innerHTML = "";

          $input.addEventListener('input', function () {
            // 0x03. parse query to keywords list
            var str = '<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length <= 0) {
              return;
            }
            // 0x04. perform local searching
            datas.forEach(function (data) {
              var isMatch = true;
              var content_index = [];
              if (!data.title || data.title.trim() === '') {
                data.title = "Untitled";
              }
              var orig_data_title = data.title.trim();
              var data_title = orig_data_title.toLowerCase();
              var orig_data_content = data.content.trim().replace(/<[^>]+>/g, "");
              var data_content = orig_data_content.toLowerCase();
              var data_url = data.url;
              var index_title = -1;
              var index_content = -1;
              var first_occur = -1;
              // only match artiles with not empty contents
              if (data_content !== '') {
                keywords.forEach(function (keyword, i) {
                  index_title = data_title.indexOf(keyword);
                  index_content = data_content.indexOf(keyword);

                  if (index_title < 0 && index_content < 0) {
                    isMatch = false;
                  } else {
                    if (index_content < 0) {
                      index_content = 0;
                    }
                    if (i == 0) {
                      first_occur = index_content;
                    }
                    // content_index.push({index_content:index_content, keyword_len:keyword_len});
                  }
                });
              } else {
                isMatch = false;
              }
              // 0x05. show search results
              if (isMatch) {
                str += "<li><a href='" + data_url + "' class='search-result-title'>" + orig_data_title + "</a>";
                var content = orig_data_content;
                if (first_occur >= 0) {
                  // cut out 100 characters
                  var start = first_occur - 20;
                  var end = first_occur + 80;

                  if (start < 0) {
                    start = 0;
                  }

                  if (start == 0) {
                    end = 100;
                  }

                  if (end > content.length) {
                    end = content.length;
                  }

                  var match_content = content.substr(start, end);

                  // highlight all keywords
                  keywords.forEach(function (keyword) {
                    var regS = new RegExp(keyword, "gi");
                    match_content = match_content.replace(regS, "<span class=\"search-keyword\">" + keyword + "</span>");
                  });

                  str += "<p class=\"search-result-abstract\">" + match_content + "...</p>"
                }
                str += "</li>";
              }
            });
            str += "</ul>";
            if (str.indexOf('<li>') === -1) {
              return $resultContent.innerHTML = "<ul><span class='local-search-empty'>No result<span></ul>";
            }
            $resultContent.innerHTML = str;
          });
        },
        error: function(xhr, status, error) {
          $resultContent.innerHTML = ""
          if (xhr.status === 404) {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>The search.xml file was not found, please refer to：<a href='https://github.com/zchengsite/hexo-theme-oranges#configuration' target='_black'>configuration</a><span></ul>";
          } else {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>The request failed, Try to refresh the page or try again later.<span></ul>";
          }
        }
      });
      $(document).on('click', '#search-close-icon', function() {
        $('#search-input').val('');
        $('#search-result').html('');
      });
    }

    var getSearchFile = function() {
        var path = "/search.xml";
        searchFunc(path, 'search-input', 'search-result');
    }
  </script>




        
  <div class="tools-bar-item theme-icon" id="switch-color-scheme">
    <a href="javascript: void(0)">
      <i id="theme-icon" class="iconfont icon-moon"></i>
    </a>
  </div>

  
<script src="/js/colorscheme.js"></script>





        
  
    <div class="share-icon tools-bar-item">
      <a href="javascript: void(0)" id="share-icon">
        <i class="iconfont iconshare"></i>
      </a>
      <div class="share-content hidden">
        
          <a class="share-item" href="https://twitter.com/intent/tweet?text=' + LeetCode%20Hot%20100%20%E5%88%B7%E9%A2%98%20%5B21-30%5D + '&url=' + http%3A%2F%2Fexample.com%2F2022%2F07%2F28%2FLeetCode-Hot-100-%25E5%2588%25B7%25E9%25A2%2598-21-30%2F + '" target="_blank" title="Twitter">
            <i class="iconfont icon-twitter"></i>
          </a>
        
        
          <a class="share-item" href="https://www.facebook.com/sharer.php?u=http://example.com/2022/07/28/LeetCode-Hot-100-%E5%88%B7%E9%A2%98-21-30/" target="_blank" title="Facebook">
            <i class="iconfont icon-facebooksquare"></i>
          </a>
        
      </div>
    </div>
  
  
<script src="/js/shares.js"></script>



      </div>
    </div>
  </body>
</html>
