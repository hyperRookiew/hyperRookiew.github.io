<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/07/15/hello-world/"/>
      <url>/2023/07/15/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>个人介绍</title>
      <link href="/2023/07/15/%E4%B8%AA%E4%BA%BA%E4%BB%8B%E7%BB%8D/"/>
      <url>/2023/07/15/%E4%B8%AA%E4%BA%BA%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="个人介绍"><a href="#个人介绍" class="headerlink" title="个人介绍"></a>个人介绍</h1><p>我叫王硕，是大连理工大学2020级软件学院软件工程专业的本科生，十分渴望能够有机会免试攻读贵院的硕士研究生。为了让您更好地了解我，我将从学业情况、项目经历、竞赛实践、未来规划这四个方面介绍自己。</p><p><strong>一、学业情况</strong></p><p>大学期间，我就读软件工程专业，专业所属的大连理工大学软件学院2021年入选教育部首批特色化示范性软件学院。在过去三年的学习中，我的课业成绩优秀，学习刻苦，必修科目加权平均成绩为93.81分，GPA为4.38&#x2F;5.0，专业排名为1&#x2F;388，曾获国家奖学金、院优秀团员、大连理工大学学习优秀奖学金（一等）、大连理工大学科创奖学金等多项荣誉。</p><p>我十分热爱数学，因此数学基础课取得了均分94 +的成绩，包括概率与统计（100）、计算机数学基础（100）、工科数学分析基础1（98）、高级统计方法（96）、离散数学（93）等，这些课程的学习既让我打下扎实的数学基础，也让我具备良好的计算机基础。</p><p>我在专业课基础方面也十分认真，通过人工智能基础（100）、编译技术（98）、软件工程（97）、操作系统（96）、数据结构与算法（96）、面向对象与C++程序设计（96）、程序设计基础与C程序设计（96）、数据库系统（93）、计算机组织与结构（92）等专业课的学习，我构建了扎实的计算机专业基础。同时我兼修了多门英语课程，四级成绩达到579分，六级成绩达到526分。本科的学习积累为我在人工智能方向上的探索打下了坚实的基础。</p><p><strong>二、项目经历</strong></p><p>为了锻炼自己的科研能力，我在大三下学期加入了大连理工大学刘日升老师的实验室，在其博士生的指导下，参与计算机视觉方向的科研，为了探索自己热爱的方向领域并锻炼自己的代码能力，我还参与了多个AI竞赛与数学建模竞赛项目。重要项目如下：</p><p><strong>1.遥感图像识别（图像分类）</strong></p><p>本项目是数据竞赛平台——FlyAI中的一项竞赛，由本人独立完成。为精准将遥感图像中显示的地形分为10类，本项目以efficientnet-b2预训练模型为基础搭建模型，采用了 albumentations、FMix 两种数据增强方案，结合 Warmup、Cosine annealing 两种方法调节学习率，并以 Test time Augmentation 方法扩展测试集，最终取得了95.89%的分类准确率。</p><p><strong>2.古文文本分类与相似性评估（自然语言处理）</strong></p><p>为从新的技术角度研究、弘扬中华传统文化，本项目对诸子百家的文本风格进行分类，并据此判断诸子与周易的语言风格近似程度。本人负责其中部分数据集的处理、模型的训练与改进、模型的测试。本项目在ERNIE1.0预训练模型的基础上搭建网络，采用AdamW优化器进行训练，并在测试集上得到了92.8%的准确率。作为对比，这一结果超过了BERT、TextCNN等模型的效果。在儒、道、法、墨四家中，法家、儒家与《周易》六十四卦风格最为相似。</p><p><strong>3.森林管理计划决策方案研究（机器学习）</strong></p><p>为确定一片森林及其产品在一段时间内封存二氧化碳量确定能够平衡森林商业价值、人文价值与生态价值的森林管理计划，该计划包括间伐周期、森林砍伐量、管理计划过度点确定等方面内容，本项目利用Logistic增长模型与栅格化方法。作为团队核心成员，本人主要负责森林碳封存量确定与管理计划过度点算法研究等方面的工作。本项目于2022年美国大学生数学建模竞赛中获得特等奖。</p><p><strong>三、竞赛实践</strong></p><p>在学科竞赛方面，我曾获2022年美国大学生数学建模竞赛Outstanding Winner &amp; AMS Award &amp; COMAP Scholarship Award、第十一届亚太地区大学生数学建模竞赛一等奖、大连理工大学2021 ~ 2022学年科技创新奖学金等奖项。</p><p>在学生工作方面，我曾担任大连理工大学软件学院创新创业实践中心数模组副部长、软件2002班学习委员，多次组织例会讲解数学建模知识，获得2021 ~ 2022学年度本专科生国家奖学金，服务师生。</p><p>在社会服务方面，我曾担任核酸检测志愿者，多次参与寒暑假社会实践活动，服务社会。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 个人介绍 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>本次作业的总结</title>
      <link href="/2023/07/15/%E6%9C%AC%E6%AC%A1%E4%BD%9C%E4%B8%9A%E7%9A%84%E6%80%BB%E7%BB%93/"/>
      <url>/2023/07/15/%E6%9C%AC%E6%AC%A1%E4%BD%9C%E4%B8%9A%E7%9A%84%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="博客主题及其选取原因"><a href="#博客主题及其选取原因" class="headerlink" title="博客主题及其选取原因"></a>博客主题及其选取原因</h2><p>在本次作业中，我选择使用Hexo和GitHub Pages搭建个人博客。Hexo是一个快速、简洁的静态博客框架，而GitHub Pages允许我将博客托管在GitHub上，便于版本控制和分享。我之所以选择这个组合，主要有以下原因：</p><ol><li><strong>简洁高效</strong>：Hexo生成静态页面，访问速度快，适合展示内容，而无需依赖服务器动态生成页面，降低了维护成本。</li><li><strong>版本控制</strong>：使用GitHub Pages，我可以将博客源码与文章进行版本管理，方便查看历史修改，协作和备份。</li><li><strong>技术方便</strong>：Hexo使用Node.js构建，这对我来说是一个熟悉的技术栈，便于自定义主题和功能。</li></ol><h2 id="博客页面布局及其设计思路"><a href="#博客页面布局及其设计思路" class="headerlink" title="博客页面布局及其设计思路"></a>博客页面布局及其设计思路</h2><p>在博客页面布局方面，我采用了传统的三栏布局：左侧是侧边栏，中间是主要内容区域，右侧是文章目录。设计思路如下：</p><ol><li><strong>导航栏</strong>：放置了一些页面导航链接，方便读者了解我的博客内容。</li><li><strong>主要内容区域</strong>：展示文章内容，包括博客文章和其他页面，如关于页面和项目页面。</li><li><strong>文章目录</strong>：右侧的文章目录能够提供更好的导航和阅读体验，使得读者可以快速浏览和访问文章。</li></ol><h2 id="博客功能实现及其技术选择"><a href="#博客功能实现及其技术选择" class="headerlink" title="博客功能实现及其技术选择"></a>博客功能实现及其技术选择</h2><p>在实现博客功能方面，我主要添加了以下功能，并选取了相应的技术：</p><ol><li><strong>文章分类与标签</strong>：通过Hexo的分类和标签功能，使得读者可以根据不同主题进行检索和浏览。</li><li><strong>评论功能</strong>：我选择使用第三方评论插件，如Disqus或Valine，来实现文章的评论功能，便于读者与我交流和讨论。</li><li><strong>搜索功能</strong>：通过Hexo的插件或者自定义脚本，实现文章内容的搜索功能，让读者能够快速找到感兴趣的文章。</li></ol><h2 id="博客样式设计及其美学考量"><a href="#博客样式设计及其美学考量" class="headerlink" title="博客样式设计及其美学考量"></a>博客样式设计及其美学考量</h2><p>博客样式设计是为了提升用户体验和视觉美感。在进行样式设计时，我考虑了以下美学因素：</p><ol><li><strong>简洁清晰</strong>：避免过度设计和复杂布局，保持页面简洁清晰，让读者专注于文章内容。</li><li><strong>配色方案</strong>：选择适合博客主题的配色方案，使得博客整体风格统一，有利于读者对品牌的记忆。</li><li><strong>响应式设计</strong>：确保博客能够在不同设备上良好显示，包括桌面、平板和手机等。</li></ol><h2 id="博客制作过程中遇到的问题及其解决方法"><a href="#博客制作过程中遇到的问题及其解决方法" class="headerlink" title="博客制作过程中遇到的问题及其解决方法"></a>博客制作过程中遇到的问题及其解决方法</h2><p>在博客制作过程中，我遇到了一些问题，并通过以下方法解决：</p><ol><li><strong>主题选择</strong>：一开始可能对主题不太满意，经过多次尝试后，找到了符合自己需求的主题，或者进行了定制修改，以满足个人化的要求。</li><li><strong>插件冲突</strong>：在添加新功能时，有时候会出现插件冲突的情况，导致页面出错。解决方法是逐一排查冲突插件，或者选择其他功能类似的插件替代。</li><li><strong>样式兼容性</strong>：在不同浏览器或设备上，样式可能显示不一致。解决方法是使用CSS兼容性技巧，测试和调整样式，确保在各种情况下都有较好的显示效果。</li></ol><p>总的来说，通过这次作业，我不仅学习了Hexo和GitHub Pages的搭建过程，还了解了如何进行博客主题的定制和功能添加。同时，遇到的问题也让我更加熟悉了调试和解决技术问题的方法，这些经验将对我的未来博客开发和网站制作有很大帮助。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode Hot 100 刷题 [31-40]</title>
      <link href="/2022/08/02/LeetCode-Hot-100-%E5%88%B7%E9%A2%98-31-40/"/>
      <url>/2022/08/02/LeetCode-Hot-100-%E5%88%B7%E9%A2%98-31-40/</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode-Hot-100-31-40"><a href="#LeetCode-Hot-100-31-40" class="headerlink" title="LeetCode Hot 100 [31-40]"></a>LeetCode Hot 100 [31-40]</h1><blockquote><p>刷完了《剑指Offer》，下一阶段，开始 LeetCode Hot 100。 之前一直都用思维导图记录，今天发现思维导图可以导出成markdown，简单编辑一下就可以成为文章。相比Xmind，博客文章打开和查看更加方便，所以之后每次Xmind记录之后，会再在这里同时同步一下</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>HOT100，之前的文章传送门<br><a href="http://blog.zwboy.cn/suan-fa/leetcode/leetcode-hot100-shua-ti-1-10.html">LeetCode Hot 100 刷题 [1-10]</a><br><a href="http://blog.zwboy.cn/suan-fa/leetcode/leetcode-hot-100-shua-ti-11-20.html">LeetCode Hot 100 刷题 [11-20]</a><br><a href="http://blog.zwboy.cn/suan-fa/leetcode/leetcode-hot-100-shua-ti-21-30.html">LeetCode Hot 100 刷题 [21-30]</a></p><h2 id="31-求所有子集"><a href="#31-求所有子集" class="headerlink" title="31. 求所有子集"></a>31. 求所有子集</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><blockquote><ul><li>给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。</li></ul></blockquote><ul><li>说明：解集不能包含重复的子集。</li><li>输入: nums &#x3D; [1,2,3]</li><li>输出:<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">3</span>],</span><br><span class="line">  [<span class="number">1</span>],</span><br><span class="line">  [<span class="number">2</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><a href="https://leetcode-cn.com/problems/subsets/">link</a></li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="解法1：集合迭代扩充"><a href="#解法1：集合迭代扩充" class="headerlink" title="解法1：集合迭代扩充"></a>解法1：集合迭代扩充</h4><ul><li>原理：每次向集合中新加入一个元素，新元素与已有元素组合形成新的元素</li><li>思路过程</li></ul><ol><li>首先，集合内无元素，所以只有一个空子集</li><li>依次将元素加入到集合中，每次加入后，新元素与已有子集成新的子集<ul><li>遍历已有的子集，每个子集后边追加新元素，然后加入到集合中</li></ul></li></ol><ul><li><ol start="3"><li>直到所有的元素都加入到了集合中</li></ol></li><li>代码实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsets</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">       ArrayList&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">       result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;());</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">           <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> result.size();</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; size; j++)&#123;</span><br><span class="line">               ArrayList&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>(result.get(j));</span><br><span class="line">               ans.add(nums[i]);</span><br><span class="line">               result.add(ans);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li>复杂度分析<ul><li>时间复杂度O(N* 2^N)</li><li>空间复杂度O(1)</li></ul></li></ul><h4 id="解法2：DFS-回溯"><a href="#解法2：DFS-回溯" class="headerlink" title="解法2：DFS + 回溯"></a>解法2：DFS + 回溯</h4><ul><li>对不同长度的子集分别进行遍历</li><li><code>dfs(int start, int len，List path)</code><ul><li>start，子集候选元素的起始区间</li><li>len，子集剩余长度</li><li>path，目前子集中的元素</li></ul></li><li>回溯过程<ul><li>依次尝试从start 开始的各个元素，加入到path中</li><li>尝试后，下次dfs的start从该元素的下个开始， len-1</li><li>尝试结束后，回溯</li></ul></li><li>代码实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 回溯算法</span></span><br><span class="line">    ArrayList&lt;List&lt;Integer&gt;&gt; result;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsets</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        ArrayList&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt;= nums.length; i++ )&#123;</span><br><span class="line">            dfs(nums,<span class="number">0</span>,i,ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> [] nums, <span class="type">int</span> start, <span class="type">int</span> len, List&lt;Integer&gt; ans)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">0</span>)&#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(ans));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; nums.length-len+<span class="number">1</span>; i++)&#123;</span><br><span class="line">            ans.add(nums[i]);</span><br><span class="line">            dfs(nums, i+<span class="number">1</span>, len-<span class="number">1</span>, ans);</span><br><span class="line">            ans.remove(ans.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>复杂度分析<ul><li>时间复杂度O(N*2^N)</li><li>空间复杂度O(N*2^N)</li></ul></li></ul><h4 id="解法3：二进制位掩码法"><a href="#解法3：二进制位掩码法" class="headerlink" title="解法3：二进制位掩码法"></a>解法3：二进制位掩码法</h4><ul><li><p>通过生成从 0…0 到 1….1 的二进制掩码，掩码每一位对应该元素是否被选中</p></li><li><p><strong>如何生成从 0…0 到 1…1的所有掩码</strong></p><ul><li>设掩码需要 N 位</li><li>则，0 &lt;&#x3D; num &lt; pow(2, N)</li></ul></li><li><p><strong>如何读取判断掩码每一位是否为1</strong></p><ul><li>右移</li><li>与1  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>( bitMask != <span class="number">0</span> )&#123;</span><br><span class="line">    <span class="keyword">if</span>((bitMask&amp;<span class="number">1</span>) == <span class="number">1</span>)&#123;</span><br><span class="line">        ans.add(nums[index]);</span><br><span class="line">    &#125;</span><br><span class="line">    index++;</span><br><span class="line">    bitMask = bitMask &gt;&gt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;List&lt;Integer&gt;&gt; result;</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsets</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> (<span class="type">int</span>)Math.pow(<span class="number">2</span>, nums.length);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; max; i++)&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">bitMask</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="keyword">while</span>( bitMask != <span class="number">0</span> )&#123;</span><br><span class="line">            <span class="keyword">if</span>((bitMask&amp;<span class="number">1</span>) == <span class="number">1</span>)&#123;</span><br><span class="line">                ans.add(nums[index]);</span><br><span class="line">            &#125;</span><br><span class="line">            index++;</span><br><span class="line">            bitMask = bitMask &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        result.add(ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>复杂度分析</p><ul><li>时间复杂度O(N * 2^N)</li><li>空间复杂度O(1)</li></ul></li></ul><h2 id="32-矩形中搜索单词"><a href="#32-矩形中搜索单词" class="headerlink" title="32. 矩形中搜索单词"></a>32. 矩形中搜索单词</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><blockquote><ul><li>给定一个二维网格和一个单词，找出该单词是否存在于网格中。</li></ul></blockquote><ul><li>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">board =</span><br><span class="line">[</span><br><span class="line">  [<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;E&#x27;</span>],</span><br><span class="line">  [<span class="string">&#x27;S&#x27;</span>,<span class="string">&#x27;F&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;S&#x27;</span>],</span><br><span class="line">  [<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;D&#x27;</span>,<span class="string">&#x27;E&#x27;</span>,<span class="string">&#x27;E&#x27;</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li>给定 word &#x3D; “ABCCED”, 返回 true</li><li>给定 word &#x3D; “SEE”, 返回 true</li><li>给定 word &#x3D; “ABCB”, 返回 false</li><li><a href="https://leetcode-cn.com/problems/word-search/">leetcode link</a></li></ul><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li><p>纯种的深度优先遍历算法DFS+回溯</p></li><li><p>思路与过程</p><ul><li>变量设计<ul><li>visited矩阵判断该位置是否访问过</li><li>dfs(int i, int j, int index)<ul><li>i,j为当前字符所在坐标</li><li>index为当前匹配到哪个字符了</li></ul></li></ul></li><li>DFS依次尝试上、下、左、右四个方向<ul><li>该方向元素匹配下一个字符，且该元素没被访问过，才会被尝试</li></ul></li></ul></li><li><p>代码实现</p><ul><li>查找过程  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> [][] board;</span><br><span class="line">   <span class="type">boolean</span>[][] visited;</span><br><span class="line">   String word;</span><br><span class="line">   ArrayList&lt;List&lt;Integer&gt;&gt; direct;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">exist</span><span class="params">(<span class="type">char</span>[][] board, String word)</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>.board = board;</span><br><span class="line">       <span class="built_in">this</span>.visited = <span class="keyword">new</span> <span class="title class_">boolean</span> [board.length][board[<span class="number">0</span>].length];</span><br><span class="line">       <span class="built_in">this</span>.word = word;</span><br><span class="line">       direct = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">       direct.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(<span class="keyword">new</span> ))</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; board.length; i++)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++)&#123;</span><br><span class="line">               <span class="keyword">if</span>(board[i][j] == word.charAt(<span class="number">0</span>))&#123;</span><br><span class="line">                   <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> dfs(i,j, <span class="number">1</span>);</span><br><span class="line">                   <span class="keyword">if</span>(result)&#123;</span><br><span class="line">                       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li>DFS过程  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j,<span class="type">int</span> index)</span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(index == word.length())&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       visited[i][j] = <span class="literal">true</span>;</span><br><span class="line">       <span class="type">boolean</span> <span class="variable">res</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">       <span class="keyword">if</span>(i-<span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; board[i-<span class="number">1</span>][j] == word.charAt(index) &amp;&amp; visited[i-<span class="number">1</span>][j] == <span class="literal">false</span>)&#123;</span><br><span class="line">           res = dfs(i-<span class="number">1</span>,j,index+<span class="number">1</span>);</span><br><span class="line">           visited[i-<span class="number">1</span>][j] = <span class="literal">false</span>;</span><br><span class="line">           <span class="keyword">if</span>(res) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(i+<span class="number">1</span> &lt; board.length &amp;&amp; board[i+<span class="number">1</span>][j] == word.charAt(index)&amp;&amp; visited[i+<span class="number">1</span>][j] == <span class="literal">false</span>)&#123;</span><br><span class="line">           res = dfs(i+<span class="number">1</span>,j,index+<span class="number">1</span>);</span><br><span class="line">           visited[i+<span class="number">1</span>][j] = <span class="literal">false</span>;</span><br><span class="line">           <span class="keyword">if</span>(res) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(j+<span class="number">1</span> &lt; board[<span class="number">0</span>].length &amp;&amp; board[i][j+<span class="number">1</span>] == word.charAt(index)&amp;&amp; visited[i][j+<span class="number">1</span>] == <span class="literal">false</span>)&#123;</span><br><span class="line">           res = dfs(i,j+<span class="number">1</span>,index+<span class="number">1</span>);</span><br><span class="line">           visited[i][j+<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">           <span class="keyword">if</span>(res) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(j-<span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; board[i][j-<span class="number">1</span>] == word.charAt(index)&amp;&amp; visited[i][j-<span class="number">1</span>] == <span class="literal">false</span>)&#123;</span><br><span class="line">           res = dfs(i,j-<span class="number">1</span>,index+<span class="number">1</span>);</span><br><span class="line">           visited[i][j-<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">           <span class="keyword">if</span>(res) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       &#125;  </span><br><span class="line">       visited[i][j] = <span class="literal">false</span>;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li>四个方向，也可以通过一个direction数组来表示，这样四个分支可以通过一个循环搞定</li></ul></li><li><p>复杂度分析</p><ul><li>时间复杂度O(N<em>M</em>K)</li><li>空间复杂度O(N<em>M</em>4*K)</li></ul></li></ul><h2 id="33-柱状图中最大的矩形"><a href="#33-柱状图中最大的矩形" class="headerlink" title="33.柱状图中最大的矩形"></a>33.柱状图中最大的矩形</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><blockquote><ul><li>给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</li></ul></blockquote><ul><li>求在该柱状图中，能够勾勒出来的矩形的最大面积。</li><li>输入: [2,1,5,6,2,3]</li><li>输出: 10</li><li><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/">Leetcode LinK</a></li></ul><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>想到接雨水、剑指Offer中的问题<ul><li>接雨水中，由最高的墙分割区间</li><li>本题中，面积最大，由最矮的墙分割区间</li></ul></li></ul><h4 id="思路1：迭代按列计算"><a href="#思路1：迭代按列计算" class="headerlink" title="思路1：迭代按列计算"></a>思路1：迭代按列计算</h4><ul><li><p>原理：依次计算以各个列作为高度的最大面积</p></li><li><p>高度为该列的高度</p></li><li><p>宽度</p><ul><li>向左找到第一个比自己小的，其右边的 left</li><li>向右找到第一个比自己大的，其左边的 right</li><li>之间的距离便是宽度， right - left + 1</li></ul></li><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">largestRectangleArea</span><span class="params">(<span class="type">int</span>[] heights)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">maxArea</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; heights.length; i++) &#123;</span><br><span class="line">           <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i, right = i;</span><br><span class="line">           <span class="comment">// 向左寻找第一个比自己小的</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i-<span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">               <span class="keyword">if</span>(heights[j] &lt; heights[i])&#123;</span><br><span class="line">                   left = j+<span class="number">1</span>;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span>(j == <span class="number">0</span>)&#123;</span><br><span class="line">                   left = <span class="number">0</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 向右寻找第一个比自己小的</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i+<span class="number">1</span>; j &lt; heights.length; j++) &#123;</span><br><span class="line">               <span class="keyword">if</span>(heights[j] &lt; heights[i])&#123;</span><br><span class="line">                   right = j - <span class="number">1</span>;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span>(j == heights.length-<span class="number">1</span>)&#123;</span><br><span class="line">                   right = heights.length-<span class="number">1</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> right - left + <span class="number">1</span>;</span><br><span class="line">           maxArea = Math.max(maxArea, width * heights[i]);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> maxArea;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p>复杂度分析</p><ul><li>时间复杂度O(N^2)</li><li>空间复杂度O(1)</li></ul></li></ul><h4 id="思路2：递归分治计算"><a href="#思路2：递归分治计算" class="headerlink" title="思路2：递归分治计算"></a>思路2：递归分治计算</h4><ul><li>每个列以他为高度的矩形的宽度是由区间中最矮的列决定的</li><li>与接雨水问题相反，用最矮的列不断对区间进行分割</li><li>思路与过程</li></ul><ol><li>找到区间中的最矮的列，其将区间分成左右两个部分</li><li>继续对左右区间再查找最矮列</li><li>递归计算各个子区间中的最大面积<ul><li>最大面积为三者中的最大值<ul><li>左区间的最大面积</li><li>右区间的最大面积</li><li>以当前区间最矮列为高，区间长度为宽度的面积</li></ul></li></ul></li></ol><ul><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">largestRectangleArea</span><span class="params">(<span class="type">int</span>[] heights)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> recv(heights, <span class="number">0</span>, heights.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">recv</span><span class="params">(<span class="type">int</span> [] heights,<span class="type">int</span> left , <span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt; right) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">minIndex</span> <span class="operator">=</span> left, index = left;</span><br><span class="line">        <span class="keyword">while</span>(index &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(heights[index] &lt; heights[minIndex])&#123;</span><br><span class="line">                minIndex = index;</span><br><span class="line">            &#125;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> right - left + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> heights[minIndex];</span><br><span class="line">        <span class="type">int</span> <span class="variable">area</span> <span class="operator">=</span> width * height;</span><br><span class="line">        area = Math.max(area, recv(heights, left, minIndex-<span class="number">1</span>));</span><br><span class="line">        area = Math.max(area, recv(heights, minIndex+<span class="number">1</span>, right));</span><br><span class="line">        <span class="keyword">return</span> area;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>复杂度分析</p><ul><li>时间复杂度O(N^2)</li><li>空间复杂度O(N)</li></ul></li></ul><h4 id="思路3：单调栈"><a href="#思路3：单调栈" class="headerlink" title="思路3：单调栈"></a>思路3：单调栈</h4><ul><li>是解决该类矩形面积问题的较优解法</li><li>原理和思路1是一样的，也是按列计算</li><li>以空间换时间<ul><li>用单调栈来减少查找左右最小值的时间复杂度</li></ul></li><li>思路与过程</li></ul><ol start="0"><li>栈中存储的是列的数组下标</li><li>当栈为空、当前列高度大于等于栈顶下标对应的列，<ul><li>则，将当前列坐标入栈</li><li>目的是找到第一个递减的列，出现递减，则其前边的几个列便可以确定宽度了</li><li>循环，直到不满足条件</li></ul></li><li>当出现当前列高度小于栈顶下标对应的列<ul><li>设当前列的索引为 rightIndex， 它是栈顶列右边第一个小于它的</li><li>poll出栈顶坐标 index，获取其高度 height[ index]，作为矩形的height</li><li>leftIndex 为栈顶下标，栈顶下标是 index列左边第一个小于它的</li><li>宽度为 (rightIndex-1) - (leftIndex+1) + 1</li><li>循环，直到栈顶元素高度大于 rightIndex 的高度<ul><li>然后将rightIndex入栈，即，始终要保持栈中元素式单调非减的</li></ul></li><li>继续 从1循环</li></ul></li><li>当列从左向右都遍历一遍了，栈中应该还会剩下一些元素<ol><li>取出栈顶元素下标作为rightIndex</li><li>循环，直到栈为空<ol><li>poll出栈顶坐标index，获得矩形高度为height[index]</li><li>leftIndex &#x3D; 新的栈顶元素下标，如果栈为空了，则leftIndex为0</li><li>宽度为，rightIndex - leftIndex + 1</li><li>更新maxArea</li></ol></li></ol></li></ol><ul><li>代码实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">largestRectangleArea</span><span class="params">(<span class="type">int</span>[] heights)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span>(heights.length == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">int</span> <span class="variable">maxArea</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="comment">// 栈中保存的是元素的数组下标</span></span><br><span class="line">       Deque&lt;Integer&gt; stack= <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">       stack.push(<span class="number">0</span>);</span><br><span class="line">       <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">while</span> (index &lt; heights.length)&#123;</span><br><span class="line">           <span class="keyword">if</span>(heights[index] &gt;= heights[stack.peek()])&#123;</span><br><span class="line">               stack.push(index);</span><br><span class="line">               index++;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 遇到第一个比栈顶小的了</span></span><br><span class="line">           <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; heights[index] &lt; heights[stack.peek()])&#123;</span><br><span class="line">               <span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> heights[stack.poll()];</span><br><span class="line">               <span class="type">int</span> <span class="variable">leftIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">               <span class="keyword">if</span>(!stack.isEmpty())&#123;</span><br><span class="line">                   leftIndex = stack.peek() + <span class="number">1</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> index - leftIndex;</span><br><span class="line">               maxArea = Math.max(maxArea, width* height);</span><br><span class="line">           &#125;</span><br><span class="line">           stack.push(index);</span><br><span class="line">           index++;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(!stack.isEmpty())&#123;</span><br><span class="line">           <span class="type">int</span> <span class="variable">rightIndex</span> <span class="operator">=</span> stack.peek();</span><br><span class="line">           <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">               <span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> heights[stack.poll()];</span><br><span class="line">               <span class="type">int</span> <span class="variable">leftIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">               <span class="keyword">if</span>(!stack.isEmpty())&#123;</span><br><span class="line">                   leftIndex = stack.peek() + <span class="number">1</span>;                    </span><br><span class="line">               &#125;</span><br><span class="line">               <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> rightIndex - leftIndex + <span class="number">1</span>;</span><br><span class="line">               maxArea = Math.max(maxArea, width * height);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> maxArea;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li>复杂度分析<ul><li>时间复杂度 O(N)</li><li>空间复杂度O(N)</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java8 提供的一些屠龙之术实践</title>
      <link href="/2022/07/31/Java8-%E6%8F%90%E4%BE%9B%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B1%A0%E9%BE%99%E4%B9%8B%E6%9C%AF%E5%AE%9E%E8%B7%B5/"/>
      <url>/2022/07/31/Java8-%E6%8F%90%E4%BE%9B%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B1%A0%E9%BE%99%E4%B9%8B%E6%9C%AF%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="Java8-提供的一些屠龙之术实践"><a href="#Java8-提供的一些屠龙之术实践" class="headerlink" title="Java8 提供的一些屠龙之术实践"></a>Java8 提供的一些屠龙之术实践</h1><blockquote><ul><li>Java8.0 提供函数式接口、Lambda表达式、方法引用、默认方法、Stream Api 以及Optional等新特性，这几个新的更新还是比较硬的，十分值得在编码中使用。</li></ul></blockquote><ul><li>话说，是不是也得开始系统学学Java11了。</li></ul><h2 id="一、Java8提供的新特性"><a href="#一、Java8提供的新特性" class="headerlink" title="一、Java8提供的新特性"></a>一、Java8提供的新特性</h2><ul><li>已在xmind，等有空再移植到这</li></ul><h2 id="二、Stream-API实战"><a href="#二、Stream-API实战" class="headerlink" title="二、Stream API实战"></a>二、Stream API实战</h2><h3 id="1-查找多个数剧中的最大最小值"><a href="#1-查找多个数剧中的最大最小值" class="headerlink" title="1. 查找多个数剧中的最大最小值"></a>1. 查找多个数剧中的最大最小值</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最大的int</span></span><br><span class="line">Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>).max(Comparator.comparing(Integer::valueOf)).get();</span><br><span class="line"><span class="comment">// 最长的字符串长度</span></span><br><span class="line">Stream.of(<span class="string">&quot;3333&quot;</span>,<span class="string">&quot;333&quot;</span>,<span class="string">&quot;8888&quot;</span>).max(Comparator.comparing(String::length)).get();</span><br><span class="line"><span class="comment">// 最高分</span></span><br><span class="line">persons.stream().max(Comparator.comparing(Person::getScores)).get();</span><br></pre></td></tr></table></figure><h3 id="2-将数组转化为List"><a href="#2-将数组转化为List" class="headerlink" title="2. 将数组转化为List"></a>2. 将数组转化为List</h3><ul><li><code>Arrays.stream(src)</code>,将数组转化成流</li><li><code>boxed()</code>,将基础数据类型包装成包装类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本类型数组：int [] to List&lt;Integer&gt;， 需要进行boxed处理</span></span><br><span class="line">Arrays.stream(array).boxed().collect(Collectors.toList());</span><br><span class="line"><span class="comment">// String [] to List&lt;String&gt;</span></span><br><span class="line">Arrays.stream(array).collect(Collectors.toList());</span><br><span class="line">Arrays.asList(array);</span><br></pre></td></tr></table></figure><h3 id="3-将List转化成数组"><a href="#3-将List转化成数组" class="headerlink" title="3. 将List转化成数组"></a>3. 将List转化成数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// List&lt;Integer&gt; to int []</span></span><br><span class="line">list.stream().mapToInt(Integer::valueOf).toArray();</span><br><span class="line"><span class="comment">// List&lt;Integer&gt; to Integer[]</span></span><br><span class="line">list.stream().toArray();</span><br><span class="line">list.toArray(<span class="keyword">new</span> <span class="title class_">Integer</span> [list.size()];</span><br></pre></td></tr></table></figure><h3 id="4-将基础类型数组转化成包装类数组"><a href="#4-将基础类型数组转化成包装类数组" class="headerlink" title="4. 将基础类型数组转化成包装类数组"></a>4. 将基础类型数组转化成包装类数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// int [] to Integer []</span></span><br><span class="line">Arrays.stream(array).boxed().toArray(Integer[]::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure><h3 id="5-将包装类数组转化成基础类型数组"><a href="#5-将包装类数组转化成基础类型数组" class="headerlink" title="5. 将包装类数组转化成基础类型数组"></a>5. 将包装类数组转化成基础类型数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Integer[] to int []</span></span><br><span class="line">Arrays.stream(array).mapToInt(Integer::valueOf).toArray();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法范式系列--二分算法</title>
      <link href="/2022/07/30/%E7%AE%97%E6%B3%95%E8%8C%83%E5%BC%8F%E7%B3%BB%E5%88%97-%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/"/>
      <url>/2022/07/30/%E7%AE%97%E6%B3%95%E8%8C%83%E5%BC%8F%E7%B3%BB%E5%88%97-%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="算法范式系列–二分算法"><a href="#算法范式系列–二分算法" class="headerlink" title="算法范式系列–二分算法"></a>算法范式系列–二分算法</h1><blockquote><ul><li>算法是Coder用来高效解决各种问题的屠龙刀，算法范式系列旨在武装自己的算法库。</li></ul></blockquote><ul><li>这次来强化二分算法技能，二分算法可是个好东西，高效，好用，真香！！！</li><li>整理一些关于二分算法的想法以及刷题总结</li></ul><h2 id="一、关于二分算法"><a href="#一、关于二分算法" class="headerlink" title="一、关于二分算法"></a>一、关于二分算法</h2><ul><li><p>可以使用二分算法的条件</p><ul><li>有序数列，（链表以及无序数组不行）</li></ul></li><li><p>复杂度</p><ul><li>时间复杂度：O(logN)</li><li>空间复杂度：迭代实现O(1)，递归实现O(logN)</li></ul></li><li><p>二分算法的思想</p><ul><li>减治思想：不断缩小问题的规模</li><li>排除法：排除掉不满足的区间</li></ul></li><li><p>什么时候该想到二分算法</p><ul><li><strong>在一个有序数组中进行查找</strong><ul><li>查找一个值，或者一个边界</li><li>半有序也可以，比如旋转、山脉数组</li></ul></li><li><strong>答案是二分的，即可以用排除法作为判断条件</strong></li><li><strong>查找一个有范围的整数</strong></li><li>算法复杂度要求O(logN)</li></ul></li><li><p>二分查找循环体规定</p><ul><li><code>[left, right]</code>, 双闭区间</li><li>这个原则基本不变，之后的各种处理就比较统一了</li></ul></li></ul><h2 id="二、二分算法解题思路"><a href="#二、二分算法解题思路" class="headerlink" title="二、二分算法解题思路"></a>二、二分算法解题思路</h2><h3 id="1-能否用二分查找"><a href="#1-能否用二分查找" class="headerlink" title="1. 能否用二分查找"></a>1. 能否用二分查找</h3><ul><li>是否有序or半有序</li><li>是否是查找一个有范围的整数</li><li>二分判断条件是什么，排除条件是什么</li></ul><h3 id="2-选择二分范式"><a href="#2-选择二分范式" class="headerlink" title="2. 选择二分范式"></a>2. 选择二分范式</h3><h4 id="范式一：在区间中查找特定的值"><a href="#范式一：在区间中查找特定的值" class="headerlink" title="范式一：在区间中查找特定的值"></a>范式一：在区间中查找特定的值</h4><ul><li>区间分为左，中，右，三个部分</li><li>比较简单的二分查找</li></ul><h4 id="范式二：查找一个整数区间中的一个值或者边界情况"><a href="#范式二：查找一个整数区间中的一个值或者边界情况" class="headerlink" title="范式二：查找一个整数区间中的一个值或者边界情况"></a>范式二：查找一个整数区间中的一个值或者边界情况</h4><ul><li>区间分为，已排除和未排除两个部分</li><li>适用于处理分界以及复杂问题</li></ul><h3 id="3-使用范式编写代码"><a href="#3-使用范式编写代码" class="headerlink" title="3. 使用范式编写代码"></a>3. 使用范式编写代码</h3><h4 id="范式一"><a href="#范式一" class="headerlink" title="范式一"></a>范式一</h4><ol><li>编写三个区间的判断，并对区间进行进一步缩小</li><li>终止条件， <code>left &gt; right</code></li></ol><h4 id="范式二"><a href="#范式二" class="headerlink" title="范式二"></a>范式二</h4><ol><li>编写排除条件<ul><li>根据题意排除区间，mid不包括在新区间中</li></ul></li><li>编写待排除区间<ul><li>不用多虑，直接是上一个区间的反区间</li></ul></li><li>检查mid的取值，向上取整还是向下<ul><li>左区间为满足条件时，要向上取整<ul><li>标志：else部分 left &#x3D; middle</li></ul></li><li>右区间为满足条件时，要向下取整<ul><li>标志：else部分 right &#x3D; middle</li></ul></li><li><strong>取整错误，区间缩小为2的时候，无法继续缩小下去了</strong></li></ul></li><li>检查查找结束后的left是否覆盖题意的范围<ul><li>默认返回范围在，[left, right]中</li><li>有时候查找结果可能超出这个区间，比如right位置的下一个</li><li>两种解决<ol><li>特别判断</li><li>在设置初始循环体时，将边界条件囊括其中。（推荐）<ul><li>比如，right一般取len-1，但有时候，结果范围包括len时，right取len</li></ul></li></ol></li></ul></li></ol><h2 id="三、二分查找的两个编程范式"><a href="#三、二分查找的两个编程范式" class="headerlink" title="三、二分查找的两个编程范式"></a>三、二分查找的两个编程范式</h2><ul><li>二分可以通过迭代以及递归实现，推荐使用迭代实现。</li><li>这里仅提供迭代实现的两个范式，递归的能不用就不用。</li><li>避免mid溢出：<code>int mid = left + ( right - left) /2;</code></li></ul><h3 id="二分范式一"><a href="#二分范式一" class="headerlink" title="二分范式一"></a>二分范式一</h3><ul><li><strong>擅长查找特定的值，查找到了则直接返回结果。</strong></li><li>其将区间分为 left，mid，right三个区间，分别对这三个区间进行判断。</li><li>终止条件：left &gt; right, 即<code>while(left &lt;= right)</code><ul><li>终止后，left和right的取值情况不好确定</li><li>所以只擅长精准查找并返回，不擅长查找结束后的处理</li><li>如果需要查找边界等情况，推荐使用范式二</li></ul></li><li>代码<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">binarySearchFor</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>; <span class="comment">// 闭区间</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123; <span class="comment">// left &gt; right 终止</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left +（ right - left) / <span class="number">2</span>; <span class="comment">// 避免mid溢出</span></span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;  <span class="comment">// 三段条件判断</span></span><br><span class="line">            result = mid;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            start = middle + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            end = middle - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="二分范式二"><a href="#二分范式二" class="headerlink" title="二分范式二"></a>二分范式二</h3><ul><li><strong>擅长处理各种边界查找问题</strong></li><li>原理思想：通过不断将不满足区间条件一边排除，不断缩小范围，最终left便为查找结果。<ul><li>如果mid不在满足条件的区间，则将该区间包括mid，排除掉</li><li>如果mid在满足条件的区间，则再缩小区间时候，保留mid</li></ul></li><li>需要抽取出区间选择条件，即大于等于，小于等于之类的</li><li>终止条件：left &#x3D;&#x3D; right, 即 <code>while(left &lt; right)</code><ul><li>查找终止后，left的位置是比较明确的，就是查找元素的边界位置</li><li>至于是之后取上边界还是下边界，再进一步判断</li></ul></li><li>mid 取整：<ul><li>主要是第二个条件分支中的<code>left=mid</code>和<code>right=mid</code>语句造成的<ul><li>目的是，当区间长度为2时，能进一步缩小区间。</li><li>当为<code>left=mid</code>，区间长度为2时，如果向下取整，则区间永远为2，死循环。</li><li>同理<code>right=mid</code>, 区间长度为2时，如果向上取整，则区间永远为2，死循环。</li></ul></li><li>如果排除的是左区间，则向下取整<ul><li><code>int mid = left + (right - left) / 2;</code></li></ul></li><li>如果排除的是右区间，则向上取整<ul><li><code>int mid = left + (right - left + 1) / 2;</code></li></ul></li></ul></li><li>代码<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 排除左区间</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">binarySearchFor</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length-<span class="number">1</span>; <span class="comment">// right也可能取nums.length，看查找结果的范围</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123; <span class="comment">// 注意，不是 &lt;=</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> ( mid 不满足区间条件 ) &#123; </span><br><span class="line">            <span class="comment">// 将左区间完全排除</span></span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// mid满足区间，所以包含mid</span></span><br><span class="line">            right = mid</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 排除右区间</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">binarySearchFor</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length-<span class="number">1</span>; <span class="comment">// right也可能取nums.length，看查找结果的范围</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123; <span class="comment">// 注意，不是 &lt;=</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> ( mid 不满足所在区间 ) &#123; </span><br><span class="line">            <span class="comment">// 将右区间完全排除</span></span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// mid满足区间，所以包含mid</span></span><br><span class="line">            left = mid</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="四、一些LeetCode典型题目"><a href="#四、一些LeetCode典型题目" class="headerlink" title="四、一些LeetCode典型题目"></a>四、一些LeetCode典型题目</h2><h3 id="1-搜索插入位置"><a href="#1-搜索插入位置" class="headerlink" title="1. 搜索插入位置"></a>1. 搜索插入位置</h3><blockquote><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。<br>你可以假设数组中无重复元素。<br>示例 1:<br>输入: [1,3,5,6], 5<br>输出: 2<br>示例 2:<br>输入: [1,3,5,6], 2<br>输出: 1<br>示例 3:<br>输入: [1,3,5,6], 7<br>输出: 4<br>示例 4:<br>输入: [1,3,5,6], 0<br>输出: 0<br><a href="https://leetcode-cn.com/problems/search-insert-position/">LeetCode地址</a></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找第一个大于等于target的位置</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-x-的平方根"><a href="#2-x-的平方根" class="headerlink" title="2. x 的平方根"></a>2. x 的平方根</h3><blockquote><p>实现 int sqrt(int x) 函数。<br>计算并返回 x 的平方根，其中 x 是非负整数。<br>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。<br>示例 1:<br>输入: 4<br>输出: 2<br>示例 2:<br>输入: 8<br>输出: 2<br>说明: 8 的平方根是 2.82842…,<br>由于返回类型是整数，小数部分将被舍去。<br><a href="https://leetcode-cn.com/problems/sqrtx">题目地址</a></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">mySqrt</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>; </span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> x/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>( mid &gt; x / mid )&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-爱吃香蕉的珂珂"><a href="#3-爱吃香蕉的珂珂" class="headerlink" title="3. 爱吃香蕉的珂珂"></a>3. 爱吃香蕉的珂珂</h3><blockquote><p>珂珂喜欢吃香蕉。这里有 N 堆香蕉，第 i 堆中有 piles[i] 根香蕉。警卫已经离开了，将在 H 小时后回来。<br>珂珂可以决定她吃香蕉的速度 K （单位：根&#x2F;小时）。每个小时，她将会选择一堆香蕉，从中吃掉 K 根。如果这堆香蕉少于 K 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。  <br>珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。<br>返回她可以在 H 小时内吃掉所有香蕉的最小速度 K（K 为整数）。<br>示例 1：<br>输入: piles &#x3D; [3,6,7,11], H &#x3D; 8<br>输出: 4<br>示例 2：<br>输入: piles &#x3D; [30,11,23,4,20], H &#x3D; 5<br>输出: 30<br>示例 3：<br>输入: piles &#x3D; [30,11,23,4,20], H &#x3D; 6<br>输出: 23<br><a href="https://leetcode-cn.com/problems/koko-eating-bananas">题目地址</a></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minEatingSpeed</span><span class="params">(<span class="type">int</span>[] piles, <span class="type">int</span> H)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxK</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>; i&lt; piles.length; i++)&#123;</span><br><span class="line">            maxK = Math.max(maxK,piles[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">1</span>, right = maxK;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left ) /<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(!canEatOut(piles,H,mid))&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">canEatOut</span><span class="params">(<span class="type">int</span> [] piles, <span class="type">int</span> H,<span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; piles.length; i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> piles[i];</span><br><span class="line">            count += total / k;</span><br><span class="line">            <span class="keyword">if</span>(total % k != <span class="number">0</span>) count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count &lt;= H;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-在排序数组中查找元素的第一个和最后一个位置"><a href="#4-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="4. 在排序数组中查找元素的第一个和最后一个位置"></a>4. 在排序数组中查找元素的第一个和最后一个位置</h3><blockquote><p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。<br>你的算法时间复杂度必须是 O(log n) 级别。<br>如果数组中不存在目标值，返回 [-1, -1]。<br>示例 1:<br>输入: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 8<br>输出: [3,4]<br>示例 2:<br>输入: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 6<br>输出: [-1,-1]<br><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array">题目地址</a></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] searchRange(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span> []&#123;findLowBound(nums,target),findUpBound(nums,target)&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找第一个大于等于</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">findLowBound</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left&lt;right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right-left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[left] != target? -<span class="number">1</span>:left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 第一个小于等于</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">findUpBound</span><span class="params">(<span class="type">int</span> [] nums,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left&lt;right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right-left+<span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[left] != target? -<span class="number">1</span>:left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-搜索旋转排序数组"><a href="#5-搜索旋转排序数组" class="headerlink" title="5. 搜索旋转排序数组"></a>5. 搜索旋转排序数组</h3><blockquote><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。<br>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。<br>搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。<br>你可以假设数组中不存在重复的元素。<br>你的算法时间复杂度必须是 O(log n) 级别。<br>示例 1:<br>输入: nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 0<br>输出: 4<br>示例 2:<br>输入: nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 3<br>输出: -1<br><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array">题目地址</a></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right-left )/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target)&#123; </span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[mid] &lt; nums[left] &amp;&amp; nums[right] &lt; target)&#123;</span><br><span class="line">                    right = mid -<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    left = mid+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[mid] &gt;= nums[left] &amp;&amp; nums[left] &gt; target)&#123;</span><br><span class="line">                    left = mid+<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    right = mid -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-搜索旋转排序数组-II"><a href="#6-搜索旋转排序数组-II" class="headerlink" title="6. 搜索旋转排序数组 II"></a>6. 搜索旋转排序数组 II</h3><blockquote><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。<br>( 例如，数组 [0,0,1,2,2,5,6] 可能变为 [2,5,6,0,0,1,2] )。<br>编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 true，否则返回 false。<br>示例 1:<br>输入: nums &#x3D; [2,5,6,0,0,1,2], target &#x3D; 0<br>输出: true<br>示例 2:<br>输入: nums &#x3D; [2,5,6,0,0,1,2], target &#x3D; 3<br>输出: false<br><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii">题目地址</a></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>] == target;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left )/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 解决重复问题：移动一格</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == nums[right]) &#123;</span><br><span class="line">                right--;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">                <span class="comment">// 最小值出现在左区间，且最小值不能到头</span></span><br><span class="line">                <span class="keyword">if</span>(nums[mid] &lt; nums[right] &amp;&amp; nums[right] &lt; target)&#123;</span><br><span class="line">                    right = mid -<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123; <span class="comment">// 正常向右</span></span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 最小值出现在右区间，且targe必然不在左</span></span><br><span class="line">                <span class="keyword">if</span>(nums[mid] &gt; nums[right] &amp;&amp; nums[left] &gt; target)&#123;</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123; <span class="comment">// 正常向左</span></span><br><span class="line">                    right = mid -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-寻找旋转排序数组中的最小值"><a href="#7-寻找旋转排序数组中的最小值" class="headerlink" title="7.寻找旋转排序数组中的最小值"></a>7.寻找旋转排序数组中的最小值</h3><blockquote><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。<br>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。<br>请找出其中最小的元素。<br>你可以假设数组中不存在重复元素。<br>示例 1:<br>输入: [3,4,5,1,2]<br>输出: 1<br>示例 2:<br>输入: [4,5,6,7,0,1,2]<br>输出: 0<br><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array">题目地址</a></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMin</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[<span class="number">0</span>] &lt;= nums[nums.length-<span class="number">1</span>]) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span><span class="number">0</span>, right = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>( left &lt; right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left ) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 排除法，正常情况下，最小应该直接选左边区间，但排除一下这种情况</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; nums[right] )&#123;</span><br><span class="line">                <span class="comment">// 左边单调增，且旋转分界点在右边区间</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-最长上升子序列"><a href="#8-最长上升子序列" class="headerlink" title="8. 最长上升子序列"></a>8. 最长上升子序列</h3><blockquote><p>给定一个无序的整数数组，找到其中最长上升子序列的长度。<br>示例:<br>输入: [10,9,2,5,3,7,101,18]<br>输出: 4<br>解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。<br>说明:<br>可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。<br>你算法的时间复杂度应该为 O(n2) 。<br>进阶: 你能将算法的时间复杂度降低到 O(n log n) 吗?<br><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence">题目地址</a></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> [] tails = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> findFirstLarge(tails, index, nums[i]);</span><br><span class="line">            tails[pos] = nums[i];</span><br><span class="line">            <span class="keyword">if</span>(pos == index) index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查找第一个大于自己的位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">findFirstLarge</span><span class="params">(<span class="type">int</span> [] tails,<span class="type">int</span> size, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = size;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(tails[mid] &lt; target)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-寻找重复数"><a href="#9-寻找重复数" class="headerlink" title="9.寻找重复数"></a>9.寻找重复数</h3><blockquote><p>给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。<br>示例 1:<br>输入: [1,3,4,2,2]<br>输出: 2<br>示例 2:<br>输入: [3,1,3,4,2]<br>输出: 3<br>说明：<br>不能更改原数组（假设数组是只读的）。<br>只能使用额外的 O(1) 的空间。<br>时间复杂度小于 O(n2) 。<br>数组中只有一个重复的数字，但它可能不止重复出现一次。<br><a href="https://leetcode-cn.com/problems/find-the-duplicate-number">题目地址</a></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findDuplicate</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">1</span>, right = nums.length -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>( left &lt; right )&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 统计nums中小于等于mid的个数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt; nums.length; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &lt;= mid) count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 鸽巢原理</span></span><br><span class="line">            <span class="keyword">if</span>(count &gt; mid)&#123;</span><br><span class="line">                <span class="comment">// count个数，这些数位于1-mid，count比mid大，则这些数中必有重复的</span></span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left = mid +<span class="number">1</span>; <span class="comment">// 上边区间的相反</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-猜数字大小"><a href="#10-猜数字大小" class="headerlink" title="10.猜数字大小"></a>10.猜数字大小</h3><blockquote><p>猜数字游戏的规则如下：<br>每轮游戏，系统都会从 1 到 n 随机选择一个数字。 请你猜选出的是哪个数字。<br>如果你猜错了，系统会告诉你这个数字比系统选出的数字是大了还是小了。<br>你可以通过调用一个预先定义好的接口 guess(int num) 来获取猜测结果，返回值一共有 3 种可能的情况（-1，1 或 0）：<br>-1 : 系统选出的数字比你猜测的数字小<br> 1 : 系统选出的数字比你猜测的数字大<br> 0 : 恭喜！你猜对了！<br>示例 :<br>输入: n &#x3D; 10, pick &#x3D; 6<br>输出: 6<br><a href="https://leetcode-cn.com/problems/guess-number-higher-or-lower">题目地址</a></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Forward declaration of guess API.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  num   your guess</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>      -1 if num is lower than the guess number</span></span><br><span class="line"><span class="comment"> *      1 if num is higher than the guess number</span></span><br><span class="line"><span class="comment"> *               otherwise return 0</span></span><br><span class="line"><span class="comment"> * int guess(int num);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> <span class="keyword">extends</span> <span class="title class_">GuessGame</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">guessNumber</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">1</span>, right = n;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left + <span class="number">1</span>) /<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(guess((<span class="type">int</span>)mid) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">// mid 大了</span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-寻找两个正序数组的中位数"><a href="#11-寻找两个正序数组的中位数" class="headerlink" title="11.寻找两个正序数组的中位数"></a>11.寻找两个正序数组的中位数</h3><blockquote><p>给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。<br>请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。<br>你可以假设 nums1 和 nums2 不会同时为空。<br>示例 1:<br>nums1 &#x3D; [1, 3]<br>nums2 &#x3D; [2]<br>则中位数是 2.0<br>示例 2:<br>nums1 &#x3D; [1, 2]<br>nums2 &#x3D; [3, 4]<br>则中位数是 (2 + 3)&#x2F;2 &#x3D; 2.5<br><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays">题目地址</a></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMedianSortedArrays</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span>(nums1.length &gt; nums2.length)&#123;</span><br><span class="line">            <span class="type">int</span> [] temp = nums1;</span><br><span class="line">            nums1 = nums2;</span><br><span class="line">            nums2 = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums1.length-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums1.length + nums2.length;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (left + right+<span class="number">1</span>) / <span class="number">2</span>; <span class="comment">// 向上取整</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> len/<span class="number">2</span> - i;</span><br><span class="line">            <span class="keyword">if</span> (nums1[i - <span class="number">1</span>] &gt; nums2[j]) &#123;</span><br><span class="line">                right = i-<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> len/<span class="number">2</span> - i;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLeftNums1</span> <span class="operator">=</span> i == <span class="number">0</span>? Integer.MIN_VALUE:nums1[i-<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">minRightNums1</span> <span class="operator">=</span> i== nums1.length? Integer.MAX_VALUE:nums1[i];</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLeftNums2</span> <span class="operator">=</span> j == <span class="number">0</span>? Integer.MIN_VALUE:nums2[j-<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">minRightNums2</span> <span class="operator">=</span> j==nums2.length? Integer.MAX_VALUE:nums2[j];</span><br><span class="line">        <span class="keyword">if</span>(( len &amp; <span class="number">1</span>) == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">double</span>) Math.min(minRightNums1,minRightNums2);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">double</span>) (Math.min(minRightNums1,minRightNums2) + Math.max(maxLeftNums1,maxLeftNums2)) / <span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-第一个错误的版本"><a href="#12-第一个错误的版本" class="headerlink" title="12. 第一个错误的版本"></a>12. 第一个错误的版本</h3><blockquote><p>你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。<br>假设你有 n 个版本 [1, 2, …, n]，你想找出导致之后所有版本出错的第一个错误的版本。<br>你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。<br>示例:<br>给定 n &#x3D; 5，并且 version &#x3D; 4 是第一个错误的版本。<br>调用 isBadVersion(3) -&gt; false<br>调用 isBadVersion(5) -&gt; true<br>调用 isBadVersion(4) -&gt; true<br>所以，4 是第一个错误的版本。 <br><a href="https://leetcode-cn.com/problems/first-bad-version">题目地址</a></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The isBadVersion API is defined in the parent class VersionControl.</span></span><br><span class="line"><span class="comment">      boolean isBadVersion(int version); */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> <span class="keyword">extends</span> <span class="title class_">VersionControl</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">firstBadVersion</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = n;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right-left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(!isBadVersion(mid))&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-找到-K-个最接近的元素"><a href="#13-找到-K-个最接近的元素" class="headerlink" title="13. 找到 K 个最接近的元素"></a>13. 找到 K 个最接近的元素</h3><blockquote><p>给定一个排序好的数组，两个整数 k 和 x，从数组中找到最靠近 x（两数之差最小）的 k 个数。返回的结果必须要是按升序排好的。如果有两个数与 x 的差值一样，优先选择数值较小的那个数。<br>示例 1:<br>输入: [1,2,3,4,5], k&#x3D;4, x&#x3D;3<br>输出: [1,2,3,4]<br>示例 2:<br>输入: [1,2,3,4,5], k&#x3D;4, x&#x3D;-1<br>输出: [1,2,3,4]<br><a href="https://leetcode-cn.com/problems/find-k-closest-elements">题目地址</a></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findClosestElements</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> k, <span class="type">int</span> x)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = arr.length;</span><br><span class="line">        LinkedList&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) /<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(arr[mid] &lt; x)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// left 为第一个 大于等于 x的</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">front</span> <span class="operator">=</span> left -<span class="number">1</span>, back = left;</span><br><span class="line">        <span class="keyword">while</span>(result.size() &lt; k)&#123;</span><br><span class="line">            <span class="keyword">if</span>(front &lt; <span class="number">0</span> </span><br><span class="line">            || back &lt; arr.length &amp;&amp; Math.abs(arr[front]-x) &gt; Math.abs(arr[back]-x))&#123;</span><br><span class="line">                result.addLast(arr[back]);</span><br><span class="line">                back++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                result.addFirst(arr[front]);</span><br><span class="line">                front--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法范式系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode Hot 100 刷题 [21-30]</title>
      <link href="/2022/07/28/LeetCode-Hot-100-%E5%88%B7%E9%A2%98-21-30/"/>
      <url>/2022/07/28/LeetCode-Hot-100-%E5%88%B7%E9%A2%98-21-30/</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode-Hot-100-11-20"><a href="#LeetCode-Hot-100-11-20" class="headerlink" title="LeetCode Hot 100 [11-20]"></a>LeetCode Hot 100 [11-20]</h1><blockquote><p>刷完了《剑指Offer》，下一阶段，开始 LeetCode Hot 100。 之前一直都用思维导图记录，今天发现思维导图可以导出成markdown，简单编辑一下就可以成为文章。相比Xmind，博客文章打开和查看更加方便，所以之后每次Xmind记录之后，会再在这里同时同步一下</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>HOT100，之前的文章传送门<br><a href="http://blog.zwboy.cn/suan-fa/leetcode/leetcode-hot100-shua-ti-1-10.html">LeetCode Hot 100 刷题 [1-10]</a><br><a href="http://blog.zwboy.cn/suan-fa/leetcode/leetcode-hot-100-shua-ti-11-20.html">LeetCode Hot 100 刷题 [11-20]</a></p><h2 id="21-接雨水问题"><a href="#21-接雨水问题" class="headerlink" title="21.接雨水问题"></a>21.接雨水问题</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><blockquote><ul><li>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</li></ul></blockquote><ul><li>输入: [0,1,0,2,1,0,1,3,2,1,2,1]</li><li>输出: 6</li><li><a href="https://leetcode-cn.com/problems/trapping-rain-water/">题目地址</a></li><li>这是一道Hard题</li></ul><p></p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="思路1：暴力算法"><a href="#思路1：暴力算法" class="headerlink" title="思路1：暴力算法"></a>思路1：暴力算法</h4><ul><li>按列，统计每个列上可以存的雨水的量</li><li>如何计算某个列上存水的量<ol><li>遍历找出该列左边的最大高度，maxleft</li><li>遍历找出该列右边的最大高度，maxRight</li><li>水的高度取决于maxLeft和maxRight中的较小者</li><li>这个列上水的深度为水的高度 - 该列的高度</li></ol></li><li>代码实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>; i &lt; height.length; i++)&#123;</span><br><span class="line">          <span class="comment">// find max left</span></span><br><span class="line">          <span class="type">int</span> <span class="variable">leftMax</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">              leftMax = Math.max(leftMax, height[j]);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// find max right</span></span><br><span class="line">          <span class="type">int</span> <span class="variable">rightMax</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i+<span class="number">1</span>; j&lt;height.length; j++)&#123;</span><br><span class="line">              rightMax = Math.max(rightMax, height[j]);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="type">int</span> <span class="variable">validHeight</span> <span class="operator">=</span> Math.min(leftMax,rightMax);</span><br><span class="line">          res += Math.max(<span class="number">0</span>, validHeight-height[i]);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li>算法复杂度<ul><li>时间复杂度O(N^2)</li></ul></li></ul><h4 id="思路2：动态规划"><a href="#思路2：动态规划" class="headerlink" title="思路2：动态规划"></a>思路2：动态规划</h4><ul><li>对思路1进行优化，思路1中查找左右最大值的过程可以通过DP优化</li><li>定义maxLeftDP[ i ] 为 i 左边的最大高度，同理，maxRightDp[ i ]为 i 右边的最大高度 </li><li>maxLeftDP[ i ] &#x3D; Max{ maxLeftDP[ i-1 ] , height[ i-1 ] }</li><li>代码实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="type">int</span> [] maxLeftDP = <span class="keyword">new</span> <span class="title class_">int</span> [height.length];</span><br><span class="line">       <span class="type">int</span> [] maxRightDP = <span class="keyword">new</span> <span class="title class_">int</span> [height.length];</span><br><span class="line">       <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> height.length;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; size-<span class="number">1</span>; i++)&#123;</span><br><span class="line">           maxLeftDP[i] = Math.max(maxLeftDP[i-<span class="number">1</span>], height[i-<span class="number">1</span>]);</span><br><span class="line">           maxRightDP[size-<span class="number">1</span>- i] = Math.max(maxRightDP[ size-i], height[size-i]);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; height.length-<span class="number">1</span>; i++)&#123;</span><br><span class="line">           <span class="type">int</span> <span class="variable">validHeight</span> <span class="operator">=</span> Math.min(maxLeftDP[i],maxRightDP[i]);</span><br><span class="line">           res += Math.max(<span class="number">0</span>, validHeight-height[i]);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li>复杂度分析<ul><li>时间复杂度O(N)</li><li>空间复杂度O(N)</li></ul></li></ul><h4 id="思路3：双指针解法"><a href="#思路3：双指针解法" class="headerlink" title="思路3：双指针解法"></a>思路3：双指针解法</h4><ul><li>对思路2中的空间复杂度还可以进一步优化</li><li>DP递推方程中，maxLeft和maxRight其实只用到左右边的一个，其实可以不用数组来存储</li><li>maxLeftDP是直接可以用变量来替代的，但是maxRightDP的求解是从右向左的，不方便直接用变量来替代</li><li>思路与过程<ul><li>left、right双指针从两端进行更新</li><li>maxLeft、maxRight记录left和right位置对应的左右最大值</li><li>maxLeft和maxRight中，起作用的是他们中的较小值，所以每次left和right指针更新较小值的一端</li></ul></li><li>如何选择更新哪一段<ul><li>maxLeft &lt; maxRight<ul><li>可以保证maxLeft为left左边最大值，且它是起作用的</li><li>left指针前进，同时更新maxleft<br>  maxLeft &gt; maxRight</li><li>同理，可以保障maxRight为right右边最大值，且它比maxLeft要小，所以即便加上右边还没检查的部分，最终的maxLeft还是比maxRight大，即起作用的还是maxRight</li><li>所以，right指针前进，同时更新maxRight</li></ul></li><li>让我想起了类似的用双指针求最大面积的题目<ul><li>每次搜索高度较小的一边</li></ul></li></ul></li><li>代码实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = height.length - <span class="number">1</span>;</span><br><span class="line">       <span class="type">int</span> <span class="variable">maxLeft</span> <span class="operator">=</span> <span class="number">0</span>, maxRight = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span>( left &lt;= right)&#123;</span><br><span class="line">           <span class="comment">// maxLeft 起作用</span></span><br><span class="line">           <span class="keyword">if</span>( height[left] &lt; maxRight &amp;&amp; maxLeft &lt; maxRight )&#123;</span><br><span class="line">               <span class="keyword">if</span>( height[left] &gt; maxLeft )&#123;</span><br><span class="line">                   maxLeft = height[left];</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   res += maxLeft - height[left];</span><br><span class="line">               &#125; </span><br><span class="line">               left++;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123; <span class="comment">// maxRight 起作用</span></span><br><span class="line">               <span class="keyword">if</span>( height[right] &gt; maxRight )&#123;</span><br><span class="line">                   maxRight = height[right];</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   res += maxRight - height[right];</span><br><span class="line">               &#125; </span><br><span class="line">               right--;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li>复杂度分析<ul><li>时间复杂度O(N)</li><li>空间复杂度O(1)</li></ul></li></ul><h2 id="22-旋转图像"><a href="#22-旋转图像" class="headerlink" title="22.旋转图像"></a>22.旋转图像</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><blockquote><ul><li>给定一个 n × n 的二维矩阵表示一个图像。</li></ul></blockquote><ul><li>将图像顺时针旋转 90 度。</li><li>你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。</li><li>给定 matrix &#x3D; <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],</span><br><span class="line">  [<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li>原地旋转输入矩阵，使其变为:<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">7</span>,<span class="number">4</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">8</span>,<span class="number">5</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">9</span>,<span class="number">6</span>,<span class="number">3</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><a href="https://leetcode-cn.com/problems/rotate-image">题目地址</a></li></ul><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="思路1：转置-行交换"><a href="#思路1：转置-行交换" class="headerlink" title="思路1：转置+行交换"></a>思路1：转置+行交换</h4><ul><li>思路与过程<ol><li>将行按照对称的方式进行交换<ul><li>a[i][j] 与 a[ len-i-1 ][j]交换</li></ul></li><li>将处理后的矩阵按对角进行转置<ul><li>a[i][j] 与 a[j][i]交换</li></ul></li></ol></li><li>代码实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">       <span class="comment">// 水平交换</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = matrix.length-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span>( left &lt; right)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; matrix[<span class="number">0</span>].length;i++)&#123;</span><br><span class="line">               rowSwap(matrix, left, right, i);</span><br><span class="line">           &#125;</span><br><span class="line">           left++;</span><br><span class="line">           right--;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 对角线对称</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;matrix.length; i++)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j&lt; i; j++)&#123;</span><br><span class="line">               angleSwap(matrix,i,j);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rowSwap</span><span class="params">(<span class="type">int</span> [][] matrix, <span class="type">int</span> left, <span class="type">int</span> right , <span class="type">int</span> i)</span>&#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> matrix[left][i];</span><br><span class="line">       matrix[left][i] = matrix[right][i];</span><br><span class="line">       matrix[right][i] = temp;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">angleSwap</span><span class="params">(<span class="type">int</span> [][] matrix, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> matrix[i][j];</span><br><span class="line">       matrix[i][j] = matrix[j][i];</span><br><span class="line">       matrix[j][i] = temp;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li>复杂度评估<ul><li>时间复杂度O(N^2)</li></ul></li></ul><h2 id="23-字母异位词分组"><a href="#23-字母异位词分组" class="headerlink" title="23.字母异位词分组"></a>23.字母异位词分组</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><blockquote><ul><li>给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。</li></ul></blockquote><ul><li>输入: [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”]</li><li>输出:<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="string">&quot;ate&quot;</span>,<span class="string">&quot;eat&quot;</span>,<span class="string">&quot;tea&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;nat&quot;</span>,<span class="string">&quot;tan&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;bat&quot;</span>]</span><br><span class="line">]</span><br><span class="line">```</span><br><span class="line">- 所有输入均为小写字母。</span><br><span class="line">- 不考虑答案输出的顺序。</span><br><span class="line">- [题目地址](https:<span class="comment">//leetcode-cn.com/problems/group-anagrams/)</span></span><br><span class="line"></span><br><span class="line">### 解题思路</span><br><span class="line">#### 思路<span class="number">1</span>：排序 + HashMap</span><br><span class="line">- 对每一个字符串的字符按字典序进行排序</span><br><span class="line">- 将排序后的结果作为HashMap的key，value为列表</span><br><span class="line">- 最终将HashMap的values输出为列表</span><br><span class="line">    - values()，返回的是数组，不是List，需要将数组转化成list</span><br><span class="line">- Java8 Stream API:`hashMap.values().stream().collect(Collectors.toList())`</span><br><span class="line">- Java8之前：`<span class="keyword">new</span> <span class="title class_">ArrayList</span>(hashMap.values())`</span><br><span class="line">- 代码实现</span><br><span class="line">```java</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">groupAnagrams</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">        HashMap&lt;String, List&lt;String&gt;&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="keyword">for</span>(String str : strs)&#123;</span><br><span class="line">            <span class="type">char</span> [] values = str.toCharArray();</span><br><span class="line">            Arrays.sort(values);</span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(values);</span><br><span class="line">            <span class="keyword">if</span>(hashMap.containsKey(key))&#123;</span><br><span class="line">                hashMap.get(key).add(str);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">                list.add(str);</span><br><span class="line">                hashMap.put(key,list);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hashMap.values().stream().collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li>复杂度分析<ul><li>时间复杂度O(Nklogk)</li><li>空间复杂度O(NK)</li></ul></li></ul><h4 id="思路2：字符计数-HashMap"><a href="#思路2：字符计数-HashMap" class="headerlink" title="思路2：字符计数 + HashMap"></a>思路2：字符计数 + HashMap</h4><ul><li>与思路1基本类似，只是key的生成方式不一样</li><li>思路1需要排序，O(klogk)，还是比较高的</li><li>可以统计每个字符串中26个字母出现的次数，作为模式，模式作为hashmap的key<ul><li>计数模式：<code>int [ ] count = new int [26]</code></li><li>最后的模式串：<code>1#0#6#...</code></li></ul></li><li>代码实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">groupAnagrams</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">       HashMap&lt;String, List&lt;String&gt;&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">       <span class="type">int</span> [] count = <span class="keyword">new</span> <span class="title class_">int</span> [<span class="number">26</span>];</span><br><span class="line">       <span class="keyword">for</span>(String str : strs)&#123;</span><br><span class="line">           <span class="type">char</span> [] values = str.toCharArray();</span><br><span class="line">           Arrays.fill(count, <span class="number">0</span>);</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">char</span> ch : values)&#123;</span><br><span class="line">               count[ch-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> num:count)&#123;</span><br><span class="line">               builder.append(num);</span><br><span class="line">               builder.append(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> builder.toString();</span><br><span class="line">           <span class="keyword">if</span>(hashMap.containsKey(key))&#123;</span><br><span class="line">               hashMap.get(key).add(str);</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">               list.add(str);</span><br><span class="line">               hashMap.put(key,list);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> hashMap.values().stream().collect(Collectors.toList());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li>复杂度分析<ul><li>时间复杂度O(NK)</li><li>空间复杂度O(NK)</li></ul></li></ul><h2 id="24-跳跃游戏"><a href="#24-跳跃游戏" class="headerlink" title="24.跳跃游戏"></a>24.跳跃游戏</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><blockquote><ul><li>给定一个非负整数数组，你最初位于数组的第一个位置。</li></ul></blockquote><ul><li>数组中的每个元素代表你在该位置可以跳跃的最大长度。</li><li>判断你是否能够到达最后一个位置。</li><li>输入: [2,3,1,1,4]</li><li>输出: true</li><li>解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。</li><li><a href="https://leetcode-cn.com/problems/jump-game/">题目地址</a></li></ul><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="思路1：排除法"><a href="#思路1：排除法" class="headerlink" title="思路1：排除法"></a>思路1：排除法</h4><ul><li>研究什么时候跳不到终点<ol><li>序列中有 0 的时候，才会可能跳不到终点</li><li>当 0 前边所有的数都无法跳过 0 ，则必定跳不过去<ul><li>即该位置的值，小于等于该位置距离0的格数</li></ul></li><li>最后一个为0不影响</li></ol></li><li>思路过程</li></ul><ol><li>遍历数组，检索所有的0<ul><li>最后一个位置是否为0不影响，所以不用判断</li></ul></li><li>对每一个0， 向前遍历，是否存在能跳跃过它的数</li><li>所有的都满足，则可以到达最后一个位置</li></ol><ul><li>代码实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canJump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;        </span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i &lt; nums.length-<span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="comment">// 最后一个是0还是非0对结果不影响</span></span><br><span class="line">           <span class="keyword">if</span>(nums[i] == <span class="number">0</span>)&#123;</span><br><span class="line">               <span class="type">int</span> j,dis=<span class="number">1</span>;</span><br><span class="line">               <span class="keyword">for</span>(j = i-<span class="number">1</span>; j &gt;= <span class="number">0</span>; j--,dis++)&#123;</span><br><span class="line">                   <span class="keyword">if</span>(nums[j] &gt; dis) <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span>(j &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li>复杂度分析<ul><li>时间复杂度O(N^2)</li><li>空间复杂度O(1)</li></ul></li></ul><h4 id="思路2：贪心算法"><a href="#思路2：贪心算法" class="headerlink" title="思路2：贪心算法"></a>思路2：贪心算法</h4><ul><li>是本题的最优解法，也应该是主要的考察点</li><li>比较不容易想到贪心规则</li><li>某一位置可达，则该位置之前的位置均是可达的</li><li>所以，只要保障能到达的位置超过数组最后一个位置就可以了<ul><li>因此，每次都尽可能的向远处跳</li></ul></li><li>思路过程</li></ul><ol><li>mostFarIndex 标识目前能到达的最远位置</li><li>当前位置在最远位置或之前，则说明最远位置可能还可以更大，更新最远位置</li><li>若当前位置在最远位置之后了，则最远位置再也没法更新了，也就最终无法超越最后一个位置了</li></ol><ul><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canJump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;        </span><br><span class="line">       <span class="type">int</span> <span class="variable">mostFarIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i &lt; nums.length-<span class="number">1</span>; i++)&#123; <span class="comment">// 最后一个不影响</span></span><br><span class="line">           <span class="keyword">if</span>( i &lt;= mostFarIndex )&#123;</span><br><span class="line">               mostFarIndex = Math.max(mostFarIndex, i + nums[i]);</span><br><span class="line">               <span class="keyword">if</span>(mostFarIndex &gt;= nums.length-<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> mostFarIndex &gt;= nums.length-<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p>复杂度分析</p><ul><li>时间复杂度O(N)</li><li>空间复杂度O(1)</li></ul></li></ul><h2 id="25-合并区间"><a href="#25-合并区间" class="headerlink" title="25.合并区间"></a>25.合并区间</h2><h3 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h3><blockquote><ul><li>出一个区间的集合，请合并所有重叠的区间。</li></ul></blockquote><ul><li>示例</li><li>输入: [[1,3],[2,6],[8,10],[15,18]]</li><li>输出: [[1,6],[8,10],[15,18]]</li><li>解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</li><li><a href="https://leetcode-cn.com/problems/merge-intervals">题目链接</a></li></ul><h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>先将区间按照左边界的大小排序<ul><li>lambda实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(intervals, (<span class="type">int</span> [] a, <span class="type">int</span> [] b)-&gt;&#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>] - b[<span class="number">0</span>];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul></li><li>然后遍历区间数组，相邻的区间能合并则合并</li><li>代码实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[][] merge(<span class="type">int</span>[][] intervals) &#123;</span><br><span class="line">       <span class="keyword">if</span>(intervals.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">       ArrayList&lt;<span class="type">int</span> []&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">       <span class="comment">// 按第一个排序</span></span><br><span class="line">       Arrays.sort(intervals, (<span class="type">int</span> [] a, <span class="type">int</span> [] b)-&gt;&#123;</span><br><span class="line">           <span class="keyword">return</span> a[<span class="number">0</span>] - b[<span class="number">0</span>];</span><br><span class="line">       &#125;);</span><br><span class="line">       <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> intervals[<span class="number">0</span>][<span class="number">0</span>], end = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;intervals.length; i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(intervals[i][<span class="number">0</span>] &lt;= end)&#123;</span><br><span class="line">               end = Math.max(end, intervals[i][<span class="number">1</span>]);</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               res.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;start, end&#125;);</span><br><span class="line">               start = intervals[i][<span class="number">0</span>];</span><br><span class="line">               end = intervals[i][<span class="number">1</span>];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       res.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;start, end&#125;);</span><br><span class="line">       <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[res.size()][<span class="number">2</span>]);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li>复杂度分析<ul><li>O(NlogN)</li></ul></li></ul><h2 id="26-不同路径"><a href="#26-不同路径" class="headerlink" title="26.不同路径"></a>26.不同路径</h2><h3 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h3><blockquote><ul><li>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</li></ul></blockquote><ul><li>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</li><li>问总共有多少条不同的路径？</li><li><a href="https://leetcode-cn.com/problems/unique-paths">题目链接</a></li></ul><h3 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>典型的深度优先遍历，动态规划解题</li></ul><h4 id="思路1：DFS-回溯"><a href="#思路1：DFS-回溯" class="headerlink" title="思路1：DFS+回溯"></a>思路1：DFS+回溯</h4><ul><li>从左上角出发，分别尝试向下和向右，然后回溯</li><li>代码实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        dfs(<span class="number">0</span>,<span class="number">0</span>,m,n);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> m, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= m || j &gt;= n) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>( i == m-<span class="number">1</span> &amp;&amp; j == n-<span class="number">1</span>)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 向右尝试</span></span><br><span class="line">        <span class="keyword">if</span>(j &lt; n-<span class="number">1</span>)&#123;</span><br><span class="line">            dfs(i,j+<span class="number">1</span>,m,n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 向左尝试</span></span><br><span class="line">        <span class="keyword">if</span>(i &lt; m -<span class="number">1</span>)&#123;</span><br><span class="line">            dfs(i+<span class="number">1</span>, j, m,n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>复杂度分析<ul><li>时间复杂度O((M+N)^2)</li><li>空间复杂度O(（M+N）^2)</li></ul></li></ul><h4 id="思路2：动态规划-1"><a href="#思路2：动态规划-1" class="headerlink" title="思路2：动态规划"></a>思路2：动态规划</h4><ul><li>dp[ i ][ j ]：到达坐标(i,j)位置有多少个路径<ul><li>&#x3D; dp[ i-1 ]dp[ j ] + dp[ i ][ j-1 ]</li></ul></li><li>思路过程<ol><li>创建二维dp数组，并进行初始化</li><li>dp数组的第一行和第一类初始化为1，因为可以确定只有1个路径</li><li>对dp数组进行填表操作</li></ol></li><li>代码实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> [][] dp = <span class="keyword">new</span> <span class="title class_">int</span> [m][n];</span><br><span class="line">    Arrays.fill(dp[<span class="number">0</span>], <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">            dp[i][j] = dp[i-<span class="number">1</span>][j] + dp[i][j-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>复杂度分析<ul><li>时间复杂度O(M*N)</li><li>空间复杂度O(M*N)</li></ul></li></ul><h4 id="思路3：动态规划空间优化"><a href="#思路3：动态规划空间优化" class="headerlink" title="思路3：动态规划空间优化"></a>思路3：动态规划空间优化</h4><ul><li>思路2中的dp二维数组，可以继续优化成一维数组</li><li>因为递归关系中，只使用到了坐标左边和左边上边的位置</li><li>代码实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> [] dp = <span class="keyword">new</span> <span class="title class_">int</span> [n];</span><br><span class="line">    Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">            dp[j] = dp[j-<span class="number">1</span>] + dp[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="27-最小路径和"><a href="#27-最小路径和" class="headerlink" title="27. 最小路径和"></a>27. 最小路径和</h2><h3 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h3><blockquote><ul><li>给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</li></ul></blockquote><ul><li>说明：每次只能向下或者向右移动一步。</li><li>输入:<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">5</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li>输出: 7</li><li>解释: 因为路径 1→3→1→1→1 的总和最小。</li><li><a href="https://leetcode-cn.com/problems/minimum-path-sum">link</a></li></ul><h3 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>思路明显，二维数组动态规划</li><li>dp[ i ][ j ]：从起点到达 (i , j)位置的路径和<ul><li>dp[ i ][ j ] &#x3D; Math.min(dp[ i ][j-1], dp[ i-1 ][ j ]) + grid[i][j];</li><li>只用到了左边和上边的位置，所以可以优化到一维数组</li><li>初始状态，i&#x3D;0 以及 j &#x3D; 0，第0行和第0列的初始化</li></ul></li><li>代码实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minPathSum</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span>(grid.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="type">int</span> dp[] = <span class="keyword">new</span> <span class="title class_">int</span> [grid[<span class="number">0</span>].length];</span><br><span class="line">       dp[<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> ; i &lt; dp.length; i++)&#123;</span><br><span class="line">           dp[i] = dp[i-<span class="number">1</span>] + grid[<span class="number">0</span>][i];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i&lt;grid.length; i++)&#123;</span><br><span class="line">           dp[<span class="number">0</span>] += grid[i][<span class="number">0</span>]; </span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j&lt;dp.length; j++)&#123;</span><br><span class="line">               dp[j] = Math.min(dp[j-<span class="number">1</span>], dp[j]) + grid[i][j];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> dp[dp.length-<span class="number">1</span>];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li>复杂度分析<ul><li>时间复杂度O(N*M)</li><li>空间复杂度O(M)</li></ul></li></ul><h2 id="28-编辑距离"><a href="#28-编辑距离" class="headerlink" title="28. 编辑距离"></a>28. 编辑距离</h2><h3 id="题目-7"><a href="#题目-7" class="headerlink" title="题目"></a>题目</h3><blockquote><ul><li>给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。</li></ul></blockquote><ul><li>你可以对一个单词进行如下三种操作：<ul><li>插入一个字符</li><li>删除一个字符</li><li>替换一个字符</li></ul></li><li>输入：word1 &#x3D; “horse”, word2 &#x3D; “ros”</li><li>输出：3</li><li>解释:<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">horse -&gt; rorse (将 <span class="string">&#x27;h&#x27;</span> 替换为 <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">rorse -&gt; rose (删除 <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">rose -&gt; ros (删除 <span class="string">&#x27;e&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li><a href="https://leetcode-cn.com/problems/edit-distance">link</a></li></ul><h3 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>动态规划解题</li></ul><ol><li>求最优解问题</li><li>是可以分阶段进行的<ul><li>每个阶段有插入、删除、替换三个选择</li><li>插入、删除、替换设定都在末尾进行<ul><li>等价的，在中间插入也是可以转换到尾部操作的</li></ul></li></ul></li><li>最优子结构<ul><li>dp[ i ][ j ]，表示将word1的前 i 位 转换成 word2的前 j 位需要的最少操作数</li><li>它可以通过三种方式获得，且取三种方式中的最小值</li></ul><ol><li>word1末尾插入<ul><li>dp[ i ][ j ] &#x3D; dp[ i-1 ][ j ] + 1;</li><li>hors -&gt; ros 需要a步，则horse -&gt; ros 需要 a+1 步</li></ul></li><li>word1末尾删除<ul><li>dp[ i ][ j ] &#x3D; dp[ i ][ j-1 ] + 1;</li><li>hors -&gt; ro需要 b 步，则 hors -&gt; ros 需要 b+1 步</li></ul></li><li>word1末尾替换<ul><li>dp[ i ][ j ] &#x3D; dp[ i-1 ][ j-1 ] + 1 ，如果 i 和 j 字符不同， 则需要额外一次替换操作<ul><li>hors - &gt; ro 为 c， 则horo -&gt; ro需要额外一次替换操作</li></ul></li><li>dp[ i ][ j ] &#x3D; dp[ i-1 ][ j ] , 如果 i 和 j 字符相同，则不需要额外一次操作 <ul><li>hor -&gt; ro 为 d ，则 hors -&gt; ros 为 d</li></ul></li></ul></li></ol></li></ol><ul><li>代码实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String word1, String word2)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">len1</span> <span class="operator">=</span> word1.length(), len2 = word2.length();</span><br><span class="line">       <span class="keyword">if</span>(len1 == <span class="number">0</span>) <span class="keyword">return</span> len2;</span><br><span class="line">       <span class="keyword">if</span>(len2 == <span class="number">0</span>) <span class="keyword">return</span> len1;</span><br><span class="line">       <span class="type">int</span> dp[][] = <span class="keyword">new</span> <span class="title class_">int</span> [len1 +<span class="number">1</span> ][len2+<span class="number">1</span>];</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= len1; i++ )&#123;</span><br><span class="line">           dp[i][<span class="number">0</span>] = i;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;= len2; i++)&#123;</span><br><span class="line">           dp[<span class="number">0</span>][i] = i;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= len1; i++)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= len2; j++)&#123;</span><br><span class="line">               <span class="type">int</span> <span class="variable">insert</span> <span class="operator">=</span> dp[i-<span class="number">1</span>][j] + <span class="number">1</span>;</span><br><span class="line">               <span class="type">int</span> <span class="variable">remove</span> <span class="operator">=</span> dp[i][j-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">               <span class="type">int</span> <span class="variable">replace</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">               <span class="keyword">if</span>(word1.charAt(i-<span class="number">1</span>) == word2.charAt(j-<span class="number">1</span>))&#123;</span><br><span class="line">                   replace = dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   replace = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               dp[i][j] = Stream.of(insert,remove, replace)</span><br><span class="line">               .min(Comparator.comparing(Integer::valueOf)).get();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> dp[len1][len2];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li>复杂度分析<ul><li>时间复杂度O(M*N)</li><li>空间复杂度O(M*N)</li></ul></li></ul><h2 id="29-颜色排序"><a href="#29-颜色排序" class="headerlink" title="29. 颜色排序"></a>29. 颜色排序</h2><h3 id="题目-8"><a href="#题目-8" class="headerlink" title="题目"></a>题目</h3><blockquote><ul><li>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</li></ul></blockquote><ul><li>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</li><li>不能使用代码库中的排序函数来解决这道题。</li><li>输入: [2,0,2,1,1,0]</li><li>输出: [0,0,1,1,2,2]</li><li>进阶<ul><li>一个直观的解决方案是使用计数排序的两趟扫描算法。</li><li>首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。</li><li>你能想出一个仅使用常数空间的一趟扫描算法吗？</li></ul></li><li><a href="https://leetcode-cn.com/problems/sort-colors">题目地址</a></li></ul><p></p><h3 id="解题思路-7"><a href="#解题思路-7" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="思路1：计数排序算法"><a href="#思路1：计数排序算法" class="headerlink" title="思路1：计数排序算法"></a>思路1：计数排序算法</h4><ul><li>计数排序<ol><li>数组统计各种元素的出现频数</li><li>对频数数组进行连续累加，对应的数字便是该类值插入位置的后一个</li><li>读取原数组中的数字，并查找频数数组，确定插入的位置<ul><li>插入成功之后，频数数组对应的值-1</li><li>即，插入位置前移一个</li></ul></li></ol></li><li>这里由于只要对值排序就可以，相同的值之间没有差异，所以得到频数数组之后，直接更改原数组即可</li><li>代码实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sortColors</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">       <span class="type">int</span>[] count = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">           count[nums[i]]++;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count.length; i++) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; count[i]; j++) &#123;</span><br><span class="line">               nums[index] = i;</span><br><span class="line">               index++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li>复杂度分析<ul><li>时间复杂度O(K+N)</li><li>空间复杂度O(K)</li></ul></li></ul><h4 id="思路2：双指针算法"><a href="#思路2：双指针算法" class="headerlink" title="思路2：双指针算法"></a>思路2：双指针算法</h4><ul><li>类似三路排序的效果，能够高效处理含有大量重复元素的情况</li><li>一路指针标记0的插入位置，另一路标记2的插入位置，0和2排序好了，中间剩下的1便也排序好了</li><li>代码实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sortColors</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">       <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> left;</span><br><span class="line">       <span class="keyword">while</span> (index &lt;= right) &#123;</span><br><span class="line">           <span class="keyword">if</span> (nums[index] == <span class="number">0</span>) &#123;</span><br><span class="line">               swap(nums, index, left);</span><br><span class="line">               left++;</span><br><span class="line">               index++;</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[index] == <span class="number">2</span>) &#123;</span><br><span class="line">               swap(nums, index, right);</span><br><span class="line">               right--;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               index++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li>复杂度分析<ul><li>时间复杂度O(N)</li><li>空间复杂度O(1)</li></ul></li></ul><h2 id="30-最小包含子串"><a href="#30-最小包含子串" class="headerlink" title="30.最小包含子串"></a>30.最小包含子串</h2><h3 id="题目-9"><a href="#题目-9" class="headerlink" title="题目"></a>题目</h3><blockquote><ul><li>给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字符的最小子串。</li></ul></blockquote><ul><li>输入: S &#x3D; “ADOBECODEBANC”, T &#x3D; “ABC”</li><li>输出: “BANC”</li><li>如果 S 中不存这样的子串，则返回空字符串 “”。</li><li>如果 S 中存在这样的子串，我们保证它是唯一的答案。</li><li><a href="https://leetcode-cn.com/problems/minimum-window-substring">link</a></li></ul><h3 id="解题思路-8"><a href="#解题思路-8" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>滑动窗口解题的典型例题</li><li>T字符中可能存在重复字符<ul><li>对字符进行计数</li><li>可以使用数组统计128所有字符</li><li>也可以通过HashMap，只统计出现的字符  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">char</span> c : tValues) &#123;</span><br><span class="line">       <span class="keyword">if</span> (tMap.containsKey(c)) &#123;</span><br><span class="line">           tMap.put(c, tMap.get(c) + <span class="number">1</span>);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           tMap.put(c, <span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ul></li><li>检测当前窗口是否包含T所有字符<ul><li>distance，即窗口内容与T之间的距离</li><li>当字符出现在T中，且该字符能缩小窗口与T距离的时候，distance++  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符在t中，更改distance</span></span><br><span class="line">      <span class="keyword">if</span> (winMap.containsKey(sValues[right])) &#123;</span><br><span class="line">          <span class="keyword">if</span> (winMap.get(sValues[right]) &lt; tMap.get(sValues[right])) &#123;</span><br><span class="line">              distance++;</span><br><span class="line">          &#125;</span><br><span class="line">          winMap.put(sValues[right], winMap.get(sValues[right]) + <span class="number">1</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          winMap.put(sValues[right], <span class="number">1</span>);</span><br><span class="line">          distance++;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></li></ul></li><li>思路与过程</li></ul><ol><li>通过HashMap，统计T字符串中字符的出现次数</li><li>left，right&#x3D;0，窗口从左出发</li><li>先right右移，right位置元素未在TMap中，则继续右移</li><li>当right位置元素出现在TMap中<ul><li>如果SMap中该字符数目 &lt; TMap中该字符数目<ul><li>distance++</li><li>说明该字符能有效降低窗口和T之间的距离</li><li>若大于等于，说明该元素重复了</li></ul></li><li>然后SMap中该字符数目+1</li></ul></li><li>检测distance<ul><li>如果比T的长度小，则right继续右移</li><li>如果和T长度相等，说明当前窗口是满足包含所有T字符的子串，但需要缩小到最小子串</li></ul></li><li>left指针右移<ul><li>移动到distance不等于T长度为止</li><li>判断left位置字符是否出现在TMap中<ul><li>出现，若SMap中该字符频数 &lt;&#x3D; TMap中该字符频数，distance–</li></ul></li><li>SMap中该字符频数-1</li></ul></li><li>最终left的位置便是子串最左位置的下一个<ul><li>length &#x3D; right -left +2</li><li>更新最短长度以及其实位置</li></ul></li></ol><ul><li>代码实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">minWindow</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">       <span class="type">char</span>[] sValues = s.toCharArray();</span><br><span class="line">       <span class="type">char</span>[] tValues = t.toCharArray();</span><br><span class="line">       <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">       HashMap&lt;Character, Integer&gt; tMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">       HashMap&lt;Character, Integer&gt; winMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">       <span class="type">int</span> <span class="variable">distance</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="type">int</span> <span class="variable">minBegin</span> <span class="operator">=</span> <span class="number">0</span>, minLength = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (<span class="type">char</span> c : tValues) &#123;</span><br><span class="line">           <span class="keyword">if</span> (tMap.containsKey(c)) &#123;</span><br><span class="line">               tMap.put(c, tMap.get(c) + <span class="number">1</span>);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               tMap.put(c, <span class="number">1</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span> (right &lt; sValues.length) &#123;</span><br><span class="line">           <span class="comment">// right 右移</span></span><br><span class="line">           <span class="keyword">if</span> (!tMap.containsKey(sValues[right])) &#123;</span><br><span class="line">               <span class="comment">// 字符不在t中，right右移</span></span><br><span class="line">               right++;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 字符在t中，更改distance</span></span><br><span class="line">           <span class="keyword">if</span> (winMap.containsKey(sValues[right])) &#123;</span><br><span class="line">               <span class="keyword">if</span> (winMap.get(sValues[right]) &lt; tMap.get(sValues[right])) &#123;</span><br><span class="line">                   distance++;</span><br><span class="line">               &#125;</span><br><span class="line">               winMap.put(sValues[right], winMap.get(sValues[right]) + <span class="number">1</span>);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               winMap.put(sValues[right], <span class="number">1</span>);</span><br><span class="line">               distance++;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (distance &lt; t.length()) &#123;</span><br><span class="line">               right++;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 判断distance,等于t串长度的时候，left开始左移</span></span><br><span class="line">           <span class="keyword">while</span> (distance == t.length()) &#123;</span><br><span class="line">               <span class="keyword">if</span> (winMap.containsKey(sValues[left])) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (winMap.get(sValues[left]) &lt;= tMap.get(sValues[left])) &#123;</span><br><span class="line">                       distance--;</span><br><span class="line">                   &#125;</span><br><span class="line">                   winMap.put(sValues[left], winMap.get(sValues[left]) - <span class="number">1</span>);</span><br><span class="line">               &#125;</span><br><span class="line">               left++;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 最终，left为满足条件的左边界的下一个</span></span><br><span class="line">           <span class="keyword">if</span> (right - left + <span class="number">2</span> &lt; minLength) &#123;</span><br><span class="line">               minBegin = left - <span class="number">1</span>;</span><br><span class="line">               minLength = right - left + <span class="number">2</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           right++;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (minLength == Integer.MAX_VALUE) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> s.substring(minBegin, minBegin + minLength);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li>复杂度分析<ul><li>时间复杂度O(N+M)</li><li>空间复杂度O(N+M)</li></ul></li></ul><h2 id="下个路口见"><a href="#下个路口见" class="headerlink" title="下个路口见"></a>下个路口见</h2><p>HOT100依然在继续，写在下一篇文章中。<a href="http://blog.zwboy.cn/suan-fa/leetcode/leetcode-hot-100-shua-ti-31-40.html">传送门</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode Hot 100 刷题 [11-20]</title>
      <link href="/2022/07/23/LeetCode-Hot-100-%E5%88%B7%E9%A2%98-11-20/"/>
      <url>/2022/07/23/LeetCode-Hot-100-%E5%88%B7%E9%A2%98-11-20/</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode-Hot-100-11-20"><a href="#LeetCode-Hot-100-11-20" class="headerlink" title="LeetCode Hot 100 [11-20]"></a>LeetCode Hot 100 [11-20]</h1><blockquote><p>刷完了《剑指Offer》，下一阶段，开始 LeetCode Hot 100。 之前一直都用思维导图记录，今天发现思维导图可以导出成markdown，简单编辑一下就可以成为文章。相比Xmind，博客文章打开和查看更加方便，所以之后每次Xmind记录之后，会再在这里同时同步一下</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>HOT100，之前的文章传送门<br><a href="http://blog.zwboy.cn/suan-fa/leetcode/leetcode-hot100-shua-ti-1-10.html">LeetCode Hot 100 刷题 [1-10]</a></p><h2 id="11-合并两个有序链表"><a href="#11-合并两个有序链表" class="headerlink" title="11. 合并两个有序链表"></a>11. 合并两个有序链表</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><blockquote><ul><li>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。<ul><li>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</li><li>输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</li></ul></li></ul></blockquote><ul><li><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">题目地址</a></li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>和两个有序数组的合并是类似的</li><li>链表有迭代和递归两种实现方式</li></ul><h4 id="迭代实现"><a href="#迭代实现" class="headerlink" title="迭代实现"></a>迭代实现</h4><ul><li><p>思路过程</p><ol><li>两个链表均非空，选择较小头节点进行归并</li><li>当有一个为空了，将非空的直接尾插到结果链表种</li></ol></li><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tempHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curr</span> <span class="operator">=</span> tempHead;</span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="literal">null</span> &amp;&amp; l2 != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1.val &lt; l2.val)&#123;</span><br><span class="line">                curr.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                curr.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            curr =  curr.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="literal">null</span>)&#123;</span><br><span class="line">            curr.next = l2;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            curr.next = l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tempHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>复杂度</p><ul><li>时间复杂度O(M+N)</li></ul></li></ul><h4 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h4><ul><li><p>思路与过程</p><ul><li>将两个链表合并的过程看作，<ol><li>先选出一个较小头节点</li><li>再对剩余节点进行合并，结果赋值给较小节点的next</li></ol></li><li>当l1头节点较小时，l1.next &#x3D; recur(l1.next, l2)</li><li>当l2头节点较小时，l2.next &#x3D; recur(l1，l2.next)</li></ul></li><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="literal">null</span>) <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span>(l2 == <span class="literal">null</span>) <span class="keyword">return</span> l1;</span><br><span class="line">        <span class="keyword">if</span>(l1.val &lt; l2.val)&#123;</span><br><span class="line">            l1.next = mergeTwoLists(l1.next,l2);</span><br><span class="line">            <span class="keyword">return</span>  l1;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            l2.next = mergeTwoLists(l1,l2.next);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>复杂度</p><ul><li>时间复杂度O(M+N)</li><li>空间复杂度O(M+N)</li></ul></li></ul><h2 id="12-括号生成"><a href="#12-括号生成" class="headerlink" title="12.括号生成"></a>12.括号生成</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><blockquote><ul><li>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。</li></ul></blockquote><ul><li>输入：n &#x3D; 3</li><li>输出： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">       <span class="string">&quot;((()))&quot;</span>,</span><br><span class="line">       <span class="string">&quot;(()())&quot;</span>,</span><br><span class="line">       <span class="string">&quot;(())()&quot;</span>,</span><br><span class="line">       <span class="string">&quot;()(())&quot;</span>,</span><br><span class="line">       <span class="string">&quot;()()()&quot;</span></span><br><span class="line">     ]</span><br></pre></td></tr></table></figure></li><li><a href="https://leetcode-cn.com/problems/generate-parentheses/">题目地址</a></li></ul><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="思路一-排列组合问题"><a href="#思路一-排列组合问题" class="headerlink" title="思路一:排列组合问题"></a>思路一:排列组合问题</h4><ul><li>属于括号的排列组合, 但不是所有的排列都满足要求</li><li>通过DFS实现排列组合的遍历过程</li><li>回溯:试过左括号之后,再尝试右括号,需要回溯之前的变更</li><li>剪枝:当肯定不满足时,剪枝<ul><li>当右括号数目大于左括号数目,则必不行</li></ul></li><li>判定括号是否匹配<ul><li>balance</li><li>左括号+1</li><li>右括号-1</li><li>遍历字符串过程中,balance必须大于等于0, 出现小于0,则不匹配</li><li>且最终balance&#x3D;0, 才能保障括号匹配</li></ul></li><li>代码实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// 一共2n个字符</span></span><br><span class="line">        <span class="type">char</span>[] values = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">2</span>*n];</span><br><span class="line">        dfs(values,<span class="number">0</span>,<span class="number">2</span>*n,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span> [] values,<span class="type">int</span> index,<span class="type">int</span> end,<span class="type">int</span> balance)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index == end)&#123;</span><br><span class="line">            <span class="keyword">if</span>(balance==<span class="number">0</span>)&#123;</span><br><span class="line">                list.add(<span class="keyword">new</span> <span class="title class_">String</span>(values));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            values[index] = <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">            dfs(values,index+<span class="number">1</span>,end,balance+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(balance-<span class="number">1</span> &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">            values[index] = <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">            dfs(values,index+<span class="number">1</span>,end,balance-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>复杂度<ul><li>时间复杂度O(2^N)</li><li>空间复杂度O(2^N)</li></ul></li></ul><h3 id="思路二-动态规划问题"><a href="#思路二-动态规划问题" class="headerlink" title="思路二:动态规划问题"></a>思路二:动态规划问题</h3><h2 id="13-合并k个有序链表"><a href="#13-合并k个有序链表" class="headerlink" title="13.合并k个有序链表"></a>13.合并k个有序链表</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><blockquote><ul><li>合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。</li></ul></blockquote><ul><li>输入:<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  <span class="number">1</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>,</span><br><span class="line">  <span class="number">1</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>,</span><br><span class="line">  <span class="number">2</span>-&gt;<span class="number">6</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li>输出: <code>1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</code></li><li><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/">题目地址</a></li></ul><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="思路1-归并合并"><a href="#思路1-归并合并" class="headerlink" title="思路1:归并合并"></a>思路1:归并合并</h4><ul><li><p>k个有序链表,两两组合,进行合并</p></li><li><p>在对合并后的两个链表,再此进行两两合并,得到最终的结果</p></li><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] lists)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> lists.length;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (len &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> <span class="number">2</span> * i;</span><br><span class="line">                <span class="keyword">if</span>(pos+<span class="number">1</span> &lt; len)&#123;</span><br><span class="line">                    lists[index] = mergeTwoLists(lists[pos],lists[pos+<span class="number">1</span>]);</span><br><span class="line">                    index++;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pos &lt; len)&#123;</span><br><span class="line">                    lists[index] = lists[pos];</span><br><span class="line">                    index++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            len = index;</span><br><span class="line">            index=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lists.length==<span class="number">0</span>?<span class="literal">null</span> : lists[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 21题中的两两合并</span></span><br><span class="line">    <span class="keyword">private</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tempHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curr</span> <span class="operator">=</span> tempHead;</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="literal">null</span> &amp;&amp; l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">                curr.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                curr.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = curr.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="literal">null</span>) &#123;</span><br><span class="line">            curr.next = l2;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            curr.next = l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tempHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>复杂度</p><ul><li>时间复杂度O(kNlogK)</li></ul></li></ul><h4 id="思路2-优先级队列"><a href="#思路2-优先级队列" class="headerlink" title="思路2: 优先级队列"></a>思路2: 优先级队列</h4><ul><li><p>和合并两个有序链表相比,不同的地方</p><ul><li>两个链表中选择最小的头节点</li><li>k个链表中选择最小的头节点</li></ul></li><li><p>k个中选最小,可以通过最小堆来实现PriorityQueue</p><ul><li>需要提供Comparator</li><li>int compare(o1, o2)</li><li>o1 - o2 &lt; 0 则o1优先级更高</li></ul></li><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] lists)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curr</span> <span class="operator">=</span> result;</span><br><span class="line">        PriorityQueue&lt;ListNode&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;ListNode&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;ListNode&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(ListNode o1, ListNode o2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> o1.val - o2.val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; lists.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(lists[i] != <span class="literal">null</span>)&#123;</span><br><span class="line">                queue.add(lists[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="keyword">if</span>(node.next != <span class="literal">null</span>)&#123;</span><br><span class="line">                queue.add(node.next);</span><br><span class="line">            &#125;</span><br><span class="line">            node.next=<span class="literal">null</span>;</span><br><span class="line">            curr.next=node;</span><br><span class="line">            curr = curr.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>复杂度</p><ul><li>时间复杂度 O(kNlogk)</li><li>空间复杂度O(k)</li></ul></li></ul><h2 id="14-下一个排列"><a href="#14-下一个排列" class="headerlink" title="14.下一个排列"></a>14.下一个排列</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><blockquote><ul><li>实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。</li></ul></blockquote><ul><li>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</li><li>必须原地修改，只允许使用额外常数空间。</li><li>以下是一些例子，输入位于左侧列，其相应输出位于右侧列。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> → <span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span></span><br><span class="line"><span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span> → <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span></span><br><span class="line"><span class="number">1</span>,<span class="number">1</span>,<span class="number">5</span> → <span class="number">1</span>,<span class="number">5</span>,<span class="number">1</span></span><br></pre></td></tr></table></figure></li><li><a href="https://leetcode-cn.com/problems/next-permutation">题目地址</a></li></ul><h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li><p>这道题需要观察总结排列数生成中的过程和规律，然后编码实现该过程</p></li><li><p>基础原理就是将第一个大于其前一个的数换到前边，得到稍大于当前排列的值</p></li><li><p>思路与过程</p><ol><li>从右向左遍历排列，找到第一个山峰（即由递增转递减）<ul><li>如果该元素为最左边元素，则直接对整个数组进行排序即可</li><li>如果该元素为最右边元素，则将该元素与倒数第二个元素交换即可</li><li>其他，则走一下步骤</li></ul></li><li>查找到山峰索引为pos，接下来需要从[pos，end]区间中选择一个合适的元素，与 pos-1 位置的交换，（即，选出新的较大的前者）<ul><li>该元素首先必须要比 pos-1 位置的要大，满足字典增序的要求</li><li>该元素为[ pos, end ] 区间中满足上输条件的最小值，即最接近 pos-1 的值</li></ul></li><li>将新元素和 pos-1 交换之后，对 [ pos-1 , end] 再进行依次排序</li><li>即可得到结果</li></ol></li><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">nextPermutation</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 从右向左，第一个增序变减序</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(pos &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[pos] &gt; nums[pos-<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pos--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pos == <span class="number">0</span>) &#123;</span><br><span class="line">            Arrays.sort(nums);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pos == nums.length-<span class="number">1</span>) &#123;</span><br><span class="line">            swap(nums,pos,pos-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从pos之后选择大于其前边数字的最小数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">selectIndex</span> <span class="operator">=</span> pos;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> pos+<span class="number">1</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; nums[pos-<span class="number">1</span>] &amp;&amp; nums[i] &lt; nums[selectIndex])&#123;</span><br><span class="line">                selectIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums,selectIndex,pos-<span class="number">1</span>);</span><br><span class="line">        Arrays.sort(nums,pos,nums.length);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> [] nums, <span class="type">int</span> aIndex, <span class="type">int</span> bIndex)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[aIndex];</span><br><span class="line">        nums[aIndex] = nums[bIndex];</span><br><span class="line">        nums[bIndex] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>复杂度分析</p><ul><li>时间复杂度：O(NlogN)</li></ul></li></ul><h2 id="15-最长有有效括号"><a href="#15-最长有有效括号" class="headerlink" title="15. 最长有有效括号"></a>15. 最长有有效括号</h2><h3 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h3><blockquote><ul><li>给定一个只包含 ‘(‘ 和 ‘)’ 的字符串，找出最长的包含有效括号的子串的长度。</li></ul></blockquote><ul><li>输入: “(()”</li><li>输出: 2</li><li>解释: 最长有效括号子串为 “()”</li><li><a href="https://leetcode-cn.com/problems/longest-valid-parentheses">题目地址</a></li></ul><h3 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="思路0-如何判断括号串是否有效"><a href="#思路0-如何判断括号串是否有效" class="headerlink" title="思路0. 如何判断括号串是否有效"></a>思路0. 如何判断括号串是否有效</h4><ul><li>balance变量<ul><li>左括号，balance++</li><li>右括号，balance–</li></ul></li><li>遍历过程中，如果balance出现 &lt; 0，则必不是有效的</li><li>遍历结束，只有当balance&#x3D;0，才说明是有效的</li></ul><h4 id="思路1-左右指针遍历"><a href="#思路1-左右指针遍历" class="headerlink" title="思路1. 左右指针遍历"></a>思路1. 左右指针遍历</h4><ul><li><p>思路与过程</p><ol><li>先从左向右遍历，统计balance<ul><li>left、right初始均为0</li><li>如果balance &#x3D;&#x3D; 0，则计算一次length，更新maxLength</li><li>如果balance &lt; 0，则 left和right直接跳到下一个字符重新统计</li></ul></li><li>再从右向左遍历，统计balance<ul><li>因为遍历时候，只有当balance&#x3D;&#x3D;0的时候，才会统计length</li><li>如果遍历结束，最终balance一直维持在 &gt; 0，则不会被统计lenth</li><li>但，balance &gt; 0 不代表没有有效括号，只是很多的左括号没有右括号来匹配它就结束了</li><li>所以需要再从右向左遍历一次，判断过程和从左向右恰好相反</li></ul></li></ol></li><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestValidParentheses</span><span class="params">(String s)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">maxLength</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right =<span class="number">0</span>;</span><br><span class="line">       <span class="type">int</span> <span class="variable">balance</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span>(right &lt; s.length())&#123;</span><br><span class="line">           <span class="keyword">if</span>(s.charAt(right) == <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">               balance++;</span><br><span class="line">           &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">               balance--;</span><br><span class="line">               <span class="keyword">if</span>(balance== <span class="number">0</span>)&#123;</span><br><span class="line">                   <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> right - left + <span class="number">1</span>;</span><br><span class="line">                   maxLength = Math.max(maxLength,length);</span><br><span class="line">               &#125;<span class="keyword">else</span> <span class="keyword">if</span>(balance &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                   left = right+<span class="number">1</span>;</span><br><span class="line">                   balance=<span class="number">0</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           right++;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 逆序再来一次</span></span><br><span class="line">       left = s.length() -<span class="number">1</span>;</span><br><span class="line">       right = left;</span><br><span class="line">       balance = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span>(left &gt;= <span class="number">0</span> )&#123;</span><br><span class="line">           <span class="keyword">if</span>(s.charAt(left) == <span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">               balance++;</span><br><span class="line">           &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">               balance--;</span><br><span class="line">               <span class="keyword">if</span>(balance== <span class="number">0</span>)&#123;</span><br><span class="line">                   <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> right - left + <span class="number">1</span>;</span><br><span class="line">                   maxLength = Math.max(maxLength,length);</span><br><span class="line">               &#125;<span class="keyword">else</span> <span class="keyword">if</span>(balance &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                   right = left - <span class="number">1</span>;</span><br><span class="line">                   balance=<span class="number">0</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           left--;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> maxLength;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="思路2-动态规划"><a href="#思路2-动态规划" class="headerlink" title="思路2. 动态规划"></a>思路2. 动态规划</h4><ul><li><p>dp[ i ] 表示以 i 为结尾的最长有效括号的长度</p></li><li><p>递推方程：dp[ i ] &#x3D;</p><ul><li>0 <ul><li>当s[ i ] &#x3D;&#x3D; ‘ ( ‘，以左括号结尾，长度肯定为0</li></ul></li><li>dp[ i-2 ] + 2<ul><li>以 ‘ ) ‘ 结尾，且，前一个括号为 ‘ ( ‘</li><li>在原有长度上，续上2</li><li>其实这种场景下，dp[ i-1 ] 必定为0</li></ul></li><li>dp[ i-1 ] + 2 + dp[ i - dp[i-1] + 1 ]<ul><li>以 ）结尾，且前一个括号为）</li><li>跳过dp[ i-1 ]对应子串的长度，查看该子串的前一个字符是否是 （，如果是，则可以和目前的）匹配</li><li>匹配，则+2</li><li>同时，匹配后，可能将（前边的子串能连续起来，所以，再加上 （ 前边位置的子串长度，即+dp[ i - dp[i-1] + 1 ]</li></ul></li></ul></li><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestValidParentheses</span><span class="params">(String s)</span> &#123;</span><br><span class="line">       <span class="type">int</span> [] dp = <span class="keyword">new</span> <span class="title class_">int</span>[s.length()];</span><br><span class="line">       <span class="comment">//dp[i] 表示以下标 ii 字符结尾的最长有效括号的长度</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">maxLength</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i&lt; s.length(); i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27;)&#x27;</span> &amp;&amp; s.charAt(i-<span class="number">1</span>) == <span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">               <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> dp[i-<span class="number">1</span>];</span><br><span class="line">               <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> i - len - <span class="number">1</span>; <span class="comment">// 前一个待匹配的左括号</span></span><br><span class="line">               <span class="keyword">if</span>( pre &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">               <span class="keyword">if</span>(s.charAt( pre ) == <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                   <span class="type">int</span> <span class="variable">preDP</span> <span class="operator">=</span> pre == <span class="number">0</span>? <span class="number">0</span>: dp[pre-<span class="number">1</span>];</span><br><span class="line">                   dp[i] = dp[i-<span class="number">1</span>] + <span class="number">2</span> + preDP;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27;)&#x27;</span> &amp;&amp; s.charAt(i-<span class="number">1</span>) == <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">               dp[i] = i==<span class="number">1</span> ? <span class="number">2</span>: dp[i-<span class="number">2</span>] + <span class="number">2</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           maxLength = Math.max(maxLength, dp[i]);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> maxLength;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p>复杂度分析</p><ul><li>时间复杂度O(N)</li><li>空间复杂度O(N)</li></ul></li></ul><h4 id="思路3-栈实现"><a href="#思路3-栈实现" class="headerlink" title="思路3. 栈实现"></a>思路3. 栈实现</h4><ul><li><p>栈中存储的元素为读取到的括号所对应的索引下标</p></li><li><p>思路与过程</p><ul><li>用栈来记录左右符号的匹配过程</li><li>过程<ol><li>如果读取到左括号，则将该左括号的索引入栈</li><li>如果读取到右括号，则弹出栈顶元素与其进行匹配<ul><li>同时计算已经匹配的子串的长度</li><li>length &#x3D; 右括号索引 - 前一个左括号索引<ul><li>前一个左括号索引，即栈中左括号的下一个元素</li></ul></li><li>在生成length过程中，记录最大值即可</li></ul></li><li>当读取到右括号，且栈为空，将右括号索引入栈</li></ol></li></ul></li><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestValidParentheses</span><span class="params">(String s)</span> &#123;</span><br><span class="line">       <span class="comment">// 用栈来实现</span></span><br><span class="line">       Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br><span class="line">       stack.push(-<span class="number">1</span>);</span><br><span class="line">       <span class="type">int</span> <span class="variable">maxLength</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;s.length(); i++ )&#123;</span><br><span class="line">           <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">               stack.push(i);</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="keyword">if</span>(!stack.isEmpty())&#123;</span><br><span class="line">                   stack.pop();</span><br><span class="line">                   <span class="keyword">if</span>(!stack.isEmpty())&#123;</span><br><span class="line">                       <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> stack.peek();</span><br><span class="line">                       <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> i - pos;</span><br><span class="line">                       maxLength = Math.max(maxLength, length);</span><br><span class="line">                   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                       stack.push(i);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> maxLength;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p>复杂度分析</p><ul><li>时间复杂度O(N)</li><li>空间复杂度O(N)</li></ul></li></ul><h2 id="16-搜索旋转排序数组"><a href="#16-搜索旋转排序数组" class="headerlink" title="16. 搜索旋转排序数组"></a>16. 搜索旋转排序数组</h2><h3 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h3><blockquote><ul><li>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</li></ul></blockquote><ul><li>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。</li><li>搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。</li><li>你可以假设数组中不存在重复的元素。</li><li>你的算法时间复杂度必须是 O(log n) 级别。</li><li>输入: nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 0</li><li>输出: 4</li><li><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array">题目地址</a></li></ul><h3 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>排序数组、O(logN)：显而易见，基于二分查找解题</li><li>查找元素，所以基于模板一</li><li>旋转数组，需要额外考虑旋转点的位置</li></ul><h4 id="1-思路与过程"><a href="#1-思路与过程" class="headerlink" title="1.思路与过程"></a>1.思路与过程</h4><ol><li>如果 mid 位置等于 target，直接返回 mid</li><li>如果 mid 位置大于 target<ul><li>正常情况下，接下来应该选择左侧区间</li><li>考虑选择右边区间的情况<ul><li>target元素被包含在较小段，并被旋转到了数组右边了</li><li>两种情况<ul><li>旋转点在mid右侧<ul><li>只有这种情况下，才是向右搜索</li><li>判断条件<ol><li>nums[ left ] &lt;&#x3D; nums[ mid ]<ul><li>左边是单调递增的</li><li>说明旋转点在右区间</li><li>需要包括等于的情况，否则会死循环<ul><li>没有左区间的时候，向右搜索，避免进入死循环</li><li>因为mid向下取整，当区间长度为2的时候，left &#x3D;&#x3D; mid</li></ul></li></ul></li><li>nums[left] &gt; target<ul><li>左边最小比target大<ul><li>说明更小的被旋转到右边了</li></ul></li></ul></li></ol></li></ul></li><li>旋转点在mid左侧<ul><li>还是向左搜索，所以只要排除上一种情况即可</li></ul></li></ul></li></ul></li></ul></li><li>如果 mid 位置小于 target<ul><li>正常情况下，接下来应该选择右侧区间</li><li>考虑选择左侧区间的情况，即，旋转点位于mid左侧，target在左侧的大值区间中</li><li>判断条件<ul><li>nums[ right ] &gt; nums [ mid ]<ul><li>右侧区间是单调的，说明旋转点在mid或者mid左侧</li></ul></li><li>nums[ right ] &lt; target<ul><li>右侧的最大值比target小，所以右侧肯定搜索不到</li></ul></li></ul></li><li>搜索左侧<ul><li>right &#x3D; mid - 1</li></ul></li></ul></li></ol><ul><li>代码实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">       <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">           <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right-left )/<span class="number">2</span>;</span><br><span class="line">           <span class="keyword">if</span>(nums[mid] == target)&#123; </span><br><span class="line">               <span class="keyword">return</span> mid;</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">               <span class="keyword">if</span>(nums[mid] &lt; nums[left] &amp;&amp; nums[right] &lt; target)&#123;</span><br><span class="line">                   right = mid -<span class="number">1</span>;</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   left = mid+<span class="number">1</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="keyword">if</span>(nums[mid] &gt;= nums[left] &amp;&amp; nums[left] &gt; target)&#123;</span><br><span class="line">                   left = mid+<span class="number">1</span>;</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   right = mid -<span class="number">1</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li>时间复杂度O(logN)</li></ul><h2 id="17-在排序数组中查找元素的第一个和最后一个"><a href="#17-在排序数组中查找元素的第一个和最后一个" class="headerlink" title="17.在排序数组中查找元素的第一个和最后一个"></a>17.在排序数组中查找元素的第一个和最后一个</h2><h3 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h3><blockquote><ul><li>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。</li></ul></blockquote><ul><li>你的算法时间复杂度必须是 O(log n) 级别。</li><li>如果数组中不存在目标值，返回 [-1, -1]。</li><li><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array">题目地址</a></li></ul><h3 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>最最典型的二分查找模板二的用法</li><li>找第一个: 即查找大于等于target元素的下标<ul><li>即排除小于target的</li></ul></li><li>找最后一个:即查找小于等于target元的的下标<ul><li>即排除大于target的</li></ul></li><li>代码实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找第一个大于等于</span></span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">findLowBound</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length-<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">while</span> (left&lt;right)&#123;</span><br><span class="line">           <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right-left) / <span class="number">2</span>;</span><br><span class="line">           <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">               left = mid + <span class="number">1</span>;</span><br><span class="line">           &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">               right = mid;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> nums[left] != target? -<span class="number">1</span>:left;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 第一个小于等于</span></span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">findUpBound</span><span class="params">(<span class="type">int</span> [] nums,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length-<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">while</span> (left&lt;right)&#123;</span><br><span class="line">           <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right-left+<span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">           <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">               right = mid - <span class="number">1</span>;</span><br><span class="line">           &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">               left = mid;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> nums[left] != target? -<span class="number">1</span>:left;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="18-组合总和"><a href="#18-组合总和" class="headerlink" title="18.组合总和"></a>18.组合总和</h2><h3 id="题目-7"><a href="#题目-7" class="headerlink" title="题目"></a>题目</h3><blockquote><ul><li>给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</li></ul></blockquote><ul><li>所有数字（包括 target）都是正整数。</li><li>candidates 中的数字可以无限制重复被选取。</li><li>解集不能包含重复的组合。 </li><li>输入：candidates &#x3D; [2,3,6,7], target &#x3D; 7,</li><li>所求解集为：</li><li><pre><code class="java"></code></pre></li></ul><p>[<br>  [7],<br>  [2,2,3]<br>]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">- [题目地址](https://leetcode-cn.com/problems/combination-sum)</span><br><span class="line"></span><br><span class="line">### 解题思路</span><br><span class="line">- 是一个排列组合问题，基于DFS + 回溯为框架</span><br><span class="line">- 同时，可以在DFS过程中，进行剪枝</span><br><span class="line">    - 当和大于target的时候，剪枝</span><br><span class="line">- 思路与过程</span><br><span class="line">1. dfs参数设计</span><br><span class="line">    - sum，记录当前累加和</span><br><span class="line">- path，记录当前路径</span><br><span class="line">- index，记录当前已经尝试到了candidates中的哪个数了</span><br><span class="line">    - 在之后的dfs中，不会再选择index之前的元素了，这样避免了重复情况</span><br><span class="line">2. dfs中，当sum == target，则说明是一个结果</span><br><span class="line">    - 基于path中的内容新创建一个list</span><br><span class="line">- 不能直接添加path到结果列表中，因为path之后还会回溯，添加做到深拷贝</span><br><span class="line">3. dfs中，让sum &gt; target，则剪枝</span><br><span class="line">4. 否则，遍历candidats数组，依次尝试每个数</span><br><span class="line">    - sum += canditates[i]</span><br><span class="line">- path.add(canditates[i])</span><br><span class="line">- dfs(index+1，path，sum)</span><br><span class="line">- 回溯，撤销更改，继续尝试下一个</span><br><span class="line">- sum -= canditates[i]</span><br><span class="line">- path.removeLast()</span><br><span class="line">- 代码实现</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">private void dfs(int [] candidates ,LinkedList&lt;Integer&gt; ans,int index,int sum, int target)&#123;</span><br><span class="line">        if(sum == target)&#123;</span><br><span class="line">            result.add(new LinkedList(ans));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if(sum &gt; target)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = index; i &lt; candidates.length; i++)&#123;</span><br><span class="line">            sum += candidates[i];</span><br><span class="line">            ans.addLast(candidates[i]);</span><br><span class="line">            dfs(candidates,ans,i,sum,target);</span><br><span class="line">            ans.removeLast();</span><br><span class="line">            sum -= candidates[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>复杂度分析<ul><li>时间复杂度,O(N^k)</li><li>空间复杂度,O（1）</li></ul></li></ul><h2 id="19-全排列"><a href="#19-全排列" class="headerlink" title="19.全排列"></a>19.全排列</h2><h3 id="题目-8"><a href="#题目-8" class="headerlink" title="题目"></a>题目</h3><blockquote><ul><li>给定一个 没有重复 数字的序列，返回其所有可能的全排列。</li></ul></blockquote><ul><li>输入: [1,2,3]</li><li>输出:<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>],</span><br><span class="line">  [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">  [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><a href="https://leetcode-cn.com/problems/permutations">题目地址</a></li></ul><h3 id="解题思路-7"><a href="#解题思路-7" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>这是典型的全排列问题</li></ul><h4 id="思路一：DFS-回溯-解决重复问题"><a href="#思路一：DFS-回溯-解决重复问题" class="headerlink" title="思路一：DFS + 回溯+解决重复问题"></a>思路一：DFS + 回溯+解决重复问题</h4><ul><li><p>思路过程</p><ol><li>path存储一次排列结果，path长度 &#x3D;&#x3D; length时候，添加到结果列表中</li><li>每次排列从数组中选择一个数，并添加到path中</li><li>避免重复：添加之前，需要检查path中是否已经有该元素了</li><li>回溯刚才选择的元素，尝试添加下一个</li></ol></li><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> [] nums, List&lt;Integer&gt; path )</span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(path.size() == nums.length)&#123;</span><br><span class="line">           result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> num:nums) &#123;</span><br><span class="line">           <span class="keyword">if</span>(!path.contains(num))&#123;</span><br><span class="line">               path.add(num);</span><br><span class="line">               dfs(nums,path);</span><br><span class="line">               path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p>复杂度分析</p><ul><li>时间复杂度O(N! * N)</li><li>空间复杂度O(N!)</li></ul></li></ul><h4 id="思路二：基于标记的回溯"><a href="#思路二：基于标记的回溯" class="headerlink" title="思路二：基于标记的回溯"></a>思路二：基于标记的回溯</h4><ul><li>通过一个标记数组来决定当前数是否被选择过，以此来解决重复问题</li><li>每次遍历选择一个没有被标记的元素</li><li>和思路一基本类似，只是通过一个标记数组来判断该元素是否使用过了</li></ul><h4 id="思路三：基于交换的回溯"><a href="#思路三：基于交换的回溯" class="headerlink" title="思路三：基于交换的回溯"></a>思路三：基于交换的回溯</h4><ul><li>空间复杂度最低，直接基于已有的数组</li><li>不过最终的排序结果不是按字典序排列的，如果需要，请使用思路一或者二</li><li>index表示当前在尝试第几个位置的元素</li><li>代码实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> [] nums,<span class="type">int</span> index )</span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(index == nums.length)&#123;</span><br><span class="line">           result.add(IntStream.of(nums).boxed().collect(Collectors.toList()));</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=index; i&lt; nums.length; i++)&#123;</span><br><span class="line">           swap(nums,index,i);</span><br><span class="line">           dfs(nums,index+<span class="number">1</span>);</span><br><span class="line">           swap(nums,index,i);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="20-最大子序和"><a href="#20-最大子序和" class="headerlink" title="20.最大子序和"></a>20.最大子序和</h2><h3 id="题目-9"><a href="#题目-9" class="headerlink" title="题目"></a>题目</h3><blockquote><ul><li>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</li></ul></blockquote><ul><li>输入: [-2,1,-3,4,-1,2,1,-5,4]</li><li>输出: 6</li><li>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</li><li><a href="https://leetcode-cn.com/problems/maximum-subarray">题目地址</a></li></ul><h3 id="解题思路-8"><a href="#解题思路-8" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="思路一：动态规划"><a href="#思路一：动态规划" class="headerlink" title="思路一：动态规划"></a>思路一：动态规划</h4><ul><li>dp[ i ] 表示以 i 位置为结尾的数列的最大子序和</li><li>dp[ i ] &#x3D; <ul><li>num[ i ] ，当dp[ i-1 ] &lt;&#x3D; 0</li><li>dp[ i-1 ] + nums[ i ] ，当dp[ i-1 ] &gt; 0</li></ul></li><li>代码实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> [] dp = <span class="keyword">new</span> <span class="title class_">int</span> [nums.length];</span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxSum</span> <span class="operator">=</span> dp[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i&lt;nums.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[i-<span class="number">1</span>] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            dp[i] = dp[i-<span class="number">1</span>] + nums[i];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            dp[i] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        maxSum = Math.max(maxSum, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="思路二：分治算法，线段树"><a href="#思路二：分治算法，线段树" class="headerlink" title="思路二：分治算法，线段树"></a>思路二：分治算法，线段树</h4><ul><li>待定</li></ul><h2 id="下个路口见"><a href="#下个路口见" class="headerlink" title="下个路口见"></a>下个路口见</h2><p>HOT100依然在继续，写在下一篇文章中。<a href="http://blog.zwboy.cn/ji-zhu/leetcode-hot-100-shua-ti-21-30.html">传送门</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode Hot 100 刷题 [1-10]</title>
      <link href="/2022/07/19/LeetCode-Hot100-%E5%88%B7%E9%A2%98%5B1-10%5D/"/>
      <url>/2022/07/19/LeetCode-Hot100-%E5%88%B7%E9%A2%98%5B1-10%5D/</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode-Hot-100-1-10"><a href="#LeetCode-Hot-100-1-10" class="headerlink" title="LeetCode Hot 100 [1-10]"></a>LeetCode Hot 100 [1-10]</h1><blockquote><p>刷完了《剑指Offer》，下一阶段，开始 LeetCode Hot 100。 之前一直都用思维导图记录，今天发现思维导图可以导出成markdown，简单编辑一下就可以成为文章。相比Xmind，博客文章打开和查看更加方便，所以之后每次Xmind记录之后，会再在这里同时同步一下</p></blockquote><h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1.两数之和"></a>1.两数之和</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><blockquote><ul><li>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</li></ul></blockquote><ul><li>示例：给定 nums &#x3D; [2, 7, 11, 15], target &#x3D; 9，因为 nums[0] + nums[1] &#x3D; 2 + 7 &#x3D; 9，所以返回 [0, 1]</li><li><a href="https://leetcode-cn.com/problems/two-sum/">LeetCode地址</a></li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="思路0：排序-双指针（不可行）"><a href="#思路0：排序-双指针（不可行）" class="headerlink" title="思路0：排序+双指针（不可行）"></a>思路0：排序+双指针（不可行）</h4><ul><li>联想到之前一个题的思路，最开始想到的便是这个思路</li><li>但需要返回数组下标，所以不能用排序，且复杂度比O(N)高</li></ul><h4 id="思路1：暴力解法"><a href="#思路1：暴力解法" class="headerlink" title="思路1：暴力解法"></a>思路1：暴力解法</h4><ul><li>两个for循环，两个数依次都搭配组合一下，直到有和target相等的</li><li>在没有很好的思路之前，不妨先试试暴力解法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i+<span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">              <span class="keyword">if</span>(nums[i] + nums[j] == target)&#123;</span><br><span class="line">                  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i,j&#125;;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度O(N^2)，空间复杂度O(1)</li></ul><h4 id="思路2：HashMap快速查找"><a href="#思路2：HashMap快速查找" class="headerlink" title="思路2：HashMap快速查找"></a>思路2：HashMap快速查找</h4><ul><li>暴力解法优化：主要是在元素的查找上耗费，荣国HashMap O(1)的查找能力进行优化</li><li>思路与过程<ol><li>遍历数组，将元素依次以值为key，索引作为value加入到HashMap中</li><li>在将元素加入到HashMap前，计算target-当前元素 &#x3D; left</li><li>检查hashMap中是否有为left的key，如果有，则返回两个数的下标即可</li></ol></li><li>代码实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        HashMap&lt;Integer,Integer&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">diff</span> <span class="operator">=</span> target - nums[i];</span><br><span class="line">            <span class="keyword">if</span>(hashMap.containsKey(diff))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;hashMap.get(target-nums[i]),i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            hashMap.put(nums[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度O(N)，空间复杂度O(N)</li></ul><h2 id="2-链表两数加法"><a href="#2-链表两数加法" class="headerlink" title="2.链表两数加法"></a>2.链表两数加法</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><blockquote><ul><li>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</li></ul></blockquote><ul><li>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。您可以假设除了数字 0 之外，这两个数都不会以 0 开头</li><li>示例<ul><li>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</li><li>输出：7 -&gt; 0 -&gt; 8</li><li>原因：342 + 465 &#x3D; 807</li></ul></li><li><a href="https://leetcode-cn.com/problems/add-two-numbers/">LeetCode地址</a></li></ul><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li><p>两个链表逆序的，低位在前，对齐，所以比较容易</p></li><li><p>核心就是模拟加法过程，如何写出优雅的代码</p></li></ul><h3 id="思路与过程"><a href="#思路与过程" class="headerlink" title="思路与过程"></a>思路与过程</h3><ol><li>遍历两个链表，依次取值参与加法计算，flag记录加法进位</li><li>结果中对应位 &#x3D; ( a + b + flag )% 10</li><li>进位flag &#x3D;  ( a+b+flag ) &#x2F; 10</li><li>如果有链表遍历空，则对应值赋值0，参与计算</li></ol><ul><li>直到两个链表均遍历完</li></ul><ol start="5"><li>链表遍历完之后，还需要检查是否还有进位，如果flag为1，则再进行依次计算</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><ul><li>迭代实现</li></ul><figure class="highlight plaintext"><figcaption><span>java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123;</span><br><span class="line">    ListNode resultHead = new ListNode(0);</span><br><span class="line">    ListNode resCur = resultHead;</span><br><span class="line">    ListNode acurr = l1, bcurr = l2;</span><br><span class="line">    int a = 0, b = 0, flag = 0;</span><br><span class="line">    while (acurr != null || bcurr != null) &#123;</span><br><span class="line">        if (acurr != null) &#123;</span><br><span class="line">            a = acurr.val;</span><br><span class="line">            acurr = acurr.next;</span><br><span class="line">        &#125;else a=0;</span><br><span class="line">        if (bcurr != null) &#123;</span><br><span class="line">            b = bcurr.val;</span><br><span class="line">            bcurr = bcurr.next;</span><br><span class="line">        &#125;else b=0;</span><br><span class="line">        resCur.next = new ListNode((a + b + flag) % 10);</span><br><span class="line">        flag = (a + b + flag) / 10;</span><br><span class="line">        resCur = resCur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    if(flag == 1)&#123;</span><br><span class="line">        resCur.next = new ListNode(1);</span><br><span class="line">    &#125;</span><br><span class="line">    return resultHead.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>递归实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">recur</span><span class="params">(ListNode l1, ListNode l2, ListNode resCurr,<span class="type">int</span> flag)</span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(l1 == <span class="literal">null</span> &amp;&amp; l2==<span class="literal">null</span> &amp;&amp; flag==<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">       <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">if</span> (l1 != <span class="literal">null</span>) &#123;</span><br><span class="line">           a = l1.val;</span><br><span class="line">           l1 = l1.next;</span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">           a=<span class="number">0</span>;</span><br><span class="line">           l1 = <span class="literal">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">           b = l2.val;</span><br><span class="line">           l2 = l2.next;</span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">           b=<span class="number">0</span>;</span><br><span class="line">           l2 = <span class="literal">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       resCurr.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>((a + b + flag) % <span class="number">10</span>);</span><br><span class="line">       flag = (a + b+flag) / <span class="number">10</span>;</span><br><span class="line">       recur(l1,l2,resCurr.next,flag);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="评估"><a href="#评估" class="headerlink" title="评估"></a>评估</h3><ul><li>时间复杂度O(N)</li><li>空间复杂度O(1)</li></ul><h3 id="问题拓展"><a href="#问题拓展" class="headerlink" title="问题拓展"></a>问题拓展</h3><ul><li><p>如果链表是非逆序的，即高位在前？？？</p><ul><li><p>递归不好做到逆序的感觉，还是要从低位对齐才开始加法</p></li><li><p>可以使用队列或者栈，实现逆序的效果</p></li></ul></li></ul><h2 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3.无重复字符的最长子串"></a>3.无重复字符的最长子串</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><blockquote><ul><li>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</li></ul></blockquote><ul><li>输入: “abcabcbb”</li><li>输出: 3 <ul><li>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</li></ul></li><li><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">题目地址</a></li></ul><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>这个在剑指offer中有原题</li></ul><h4 id="思路一：双指针-Set集合判断重复-遍历查找区间"><a href="#思路一：双指针-Set集合判断重复-遍历查找区间" class="headerlink" title="思路一：双指针+Set集合判断重复+遍历查找区间"></a>思路一：双指针+Set集合判断重复+遍历查找区间</h4><ul><li>简单，略</li></ul><h4 id="思路二：HashMap，记录字符上次出现的索引坐标"><a href="#思路二：HashMap，记录字符上次出现的索引坐标" class="headerlink" title="思路二：HashMap，记录字符上次出现的索引坐标"></a>思路二：HashMap，记录字符上次出现的索引坐标</h4><ul><li>在判断是否重复的同时</li><li>还可以快速查找到重复元素的坐标</li><li>代码实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] chars = s.toCharArray();</span><br><span class="line">        HashMap&lt;Character, Integer&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLength</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (right &lt; s.length()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hashMap.containsKey(chars[right])) &#123;</span><br><span class="line">                <span class="keyword">if</span> (hashMap.get(chars[right]) &gt;= left) &#123;</span><br><span class="line">                    left = hashMap.get(chars[right]) + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            hashMap.put(chars[right], right);</span><br><span class="line">            right++;</span><br><span class="line">            maxLength = Math.max(maxLength, right - left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLength;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="4-寻找两个正序数组的中位数"><a href="#4-寻找两个正序数组的中位数" class="headerlink" title="4.寻找两个正序数组的中位数"></a>4.寻找两个正序数组的中位数</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><blockquote><ul><li>给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。</li></ul></blockquote><ul><li>请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。</li><li>你可以假设 nums1 和 nums2 不会同时为空。</li><li><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/">地址</a></li></ul><h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="思路一：将两个有序列表先归并成一个有序列表，然后再求中位数"><a href="#思路一：将两个有序列表先归并成一个有序列表，然后再求中位数" class="headerlink" title="思路一：将两个有序列表先归并成一个有序列表，然后再求中位数"></a>思路一：将两个有序列表先归并成一个有序列表，然后再求中位数</h4><ul><li>时间复杂度O(m+n)</li><li>空间复杂度O(m+n)</li><li>不符合题意，但比较简单</li></ul><h4 id="思路二：中位数在整个数组中最终的位置索引是已知的，所以不需要对整个数组合并排序"><a href="#思路二：中位数在整个数组中最终的位置索引是已知的，所以不需要对整个数组合并排序" class="headerlink" title="思路二：中位数在整个数组中最终的位置索引是已知的，所以不需要对整个数组合并排序"></a>思路二：中位数在整个数组中最终的位置索引是已知的，所以不需要对整个数组合并排序</h4><ul><li>如果m+n为偶数，则中位数索引为 (m+n) &#x2F; 2，以及其左边的</li><li>如果m+n为奇数，则中位数为(m+n) &#x2F; 2</li><li>所以，只要从两个数组中选出前半部分即可</li><li>时间复杂度仍然为O(m+n)，不可行</li></ul><h4 id="思路三：运用二分查找"><a href="#思路三：运用二分查找" class="headerlink" title="思路三：运用二分查找"></a>思路三：运用二分查找</h4><ul><li>这是运用二分查找的一个比较难的题目</li><li>算法复杂度要求O(log(m+n))，很容易联想到二分查找</li><li>思路与过程</li></ul><h5 id="1-查找的区间"><a href="#1-查找的区间" class="headerlink" title="1. 查找的区间"></a>1. 查找的区间</h5><ul><li>即需要在两个数组中确定一个分割线</li><li>即，在A数组中确定分割线后，B数组中分割线也就定下来了 j &#x3D; (m+n) &#x2F; 2 - i</li><li>i 和 j 表示分割线右边的索引</li></ul><h5 id="2-查找条件-排除条件"><a href="#2-查找条件-排除条件" class="headerlink" title="2. 查找条件&#x2F;排除条件"></a>2. 查找条件&#x2F;排除条件</h5><ul><li>分割线左边元素与右边偶数时相等，奇数时少一个</li><li>A左不能大于B右，A右不能小于A左</li><li>以上两个可以作为排除条件</li></ul><h5 id="3-整个查找过程即"><a href="#3-整个查找过程即" class="headerlink" title="3. 整个查找过程即"></a>3. 整个查找过程即</h5><ul><li>在 0 - m-1 上确定 i 的取值</li><li>最终使得 i 和 j 满足对于的查找条件</li><li>难就难在有很多特殊的边界情况需要特别考虑</li></ul><h5 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMedianSortedArrays</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span>(nums1.length &gt; nums2.length)&#123;</span><br><span class="line">            <span class="type">int</span> [] temp = nums1;</span><br><span class="line">            nums1 = nums2;</span><br><span class="line">            nums2 = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums1.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums1.length + nums2.length;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (left + right+<span class="number">1</span>) / <span class="number">2</span>; <span class="comment">// 向上取整</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> len/<span class="number">2</span> - i;</span><br><span class="line">            <span class="keyword">if</span> (nums1[i - <span class="number">1</span>] &gt; nums2[j]) &#123;</span><br><span class="line">                right = i-<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> len/<span class="number">2</span> - i;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLeftNums1</span> <span class="operator">=</span> i == <span class="number">0</span>? Integer.MIN_VALUE:nums1[i-<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">minRightNums1</span> <span class="operator">=</span> i== nums1.length? Integer.MAX_VALUE:nums1[i];</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLeftNums2</span> <span class="operator">=</span> j == <span class="number">0</span>? Integer.MIN_VALUE:nums2[j-<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">minRightNums2</span> <span class="operator">=</span> j==nums2.length? Integer.MAX_VALUE:nums2[j];</span><br><span class="line">        <span class="keyword">if</span>(( len &amp; <span class="number">1</span>) == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">double</span>) Math.min(minRightNums1,minRightNums2);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">double</span>) (Math.min(minRightNums1,minRightNums2) + Math.max(maxLeftNums1,maxLeftNums2)) / <span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h5><ul><li>时间复杂度O(log(m+n))</li><li>空间复杂度O(1)</li></ul><h2 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a>5. 最长回文子串</h2><h3 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h3><blockquote><ul><li>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</li></ul></blockquote><ul><li>输入: “babad”，输出: “bab”，注意: “aba” 也是一个有效答案。</li><li>输入: “cbbd”，输出: “bb”</li></ul><h3 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="思路1：中间扩散"><a href="#思路1：中间扩散" class="headerlink" title="思路1：中间扩散"></a>思路1：中间扩散</h4><ul><li>依次遍历每个字符，以每个字符为中心，向外扩散，直到获得以该字符为中心的最长回文子串</li><li>需要讨论两种情况<ul><li>奇数 bab：判断 i-j 和 i+j 位置是否相等</li><li>偶数 baab：判断 i-j 和 i-j+1位置是否相等</li></ul></li></ul><h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLength</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">maxString</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(i-j &gt;=<span class="number">0</span> &amp;&amp; i+j &lt; s.length())&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i-j) != s.charAt(i+j))&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            j--;</span><br><span class="line">            <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> <span class="number">2</span> * j + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>( length &gt; maxLength)&#123;</span><br><span class="line">                maxLength = length;</span><br><span class="line">                <span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(); </span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i-j; k &lt;= i+j;k++)&#123;</span><br><span class="line">                    builder.append(s.charAt(k));</span><br><span class="line">                &#125;</span><br><span class="line">                maxString = builder.toString();</span><br><span class="line">            &#125;</span><br><span class="line">            j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(i-j &gt;=<span class="number">0</span> &amp;&amp; i+j+<span class="number">1</span> &lt; s.length())&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i-j) != s.charAt(i+j+<span class="number">1</span>))&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            j--;</span><br><span class="line">            length = <span class="number">2</span> * (j+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>( length &gt; maxLength)&#123;</span><br><span class="line">                maxLength = length;</span><br><span class="line">                <span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(); </span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i-j; k &lt;= i+j+<span class="number">1</span>;k++)&#123;</span><br><span class="line">                    builder.append(s.charAt(k));</span><br><span class="line">                &#125;</span><br><span class="line">                maxString = builder.toString();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxString;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h4><ul><li>时间：O(n^2)</li><li>空间:O(1)</li></ul><h3 id="思路2：动态规划"><a href="#思路2：动态规划" class="headerlink" title="思路2：动态规划"></a>思路2：动态规划</h3><h4 id="1-定义dp"><a href="#1-定义dp" class="headerlink" title="1. 定义dp"></a>1. 定义dp</h4><ul><li>dp[i][j] 表示从 i 到 j 是否是回文串</li></ul><h4 id="2-递推方程"><a href="#2-递推方程" class="headerlink" title="2. 递推方程"></a>2. 递推方程</h4><ul><li>dp[i][j] &#x3D; dp[ i+1 ][ j-1 ]  &amp;&amp; s.charAt(i) &#x3D;&#x3D; s.charAt(j)</li></ul><h4 id="3-初始状态"><a href="#3-初始状态" class="headerlink" title="3. 初始状态"></a>3. 初始状态</h4><ul><li>dp[ i ][ i ] &#x3D; true</li><li>dp[ i ][ i+1 ] &#x3D; s.charAt(i) &#x3D;&#x3D; s.charAt(i+1)</li></ul><h4 id="4-填表过程"><a href="#4-填表过程" class="headerlink" title="4. 填表过程"></a>4. 填表过程</h4><ul><li>需要先填 i 大的，j 小的，所以从右下角向左上角填表</li></ul><h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">       <span class="type">boolean</span> dp[][] = <span class="keyword">new</span> <span class="title class_">boolean</span>[s.length()][s.length()];</span><br><span class="line">       <span class="type">int</span> <span class="variable">maxLength</span> <span class="operator">=</span> s.length() == <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">       <span class="type">String</span> <span class="variable">maxString</span> <span class="operator">=</span> s.length() == <span class="number">0</span> ? <span class="string">&quot;&quot;</span> : s.substring(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">           dp[i][i] = <span class="literal">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 倒三角填表</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> s.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; s.length(); j++) &#123;</span><br><span class="line">               <span class="keyword">if</span> (s.charAt(i) != s.charAt(j)) &#123;</span><br><span class="line">                   dp[i][j] = <span class="literal">false</span>;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="keyword">if</span>(j-i == <span class="number">1</span>) dp[i][j] =<span class="literal">true</span>;</span><br><span class="line">                   <span class="keyword">else</span> dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                   <span class="keyword">if</span> (dp[i][j] &amp;&amp; j - i + <span class="number">1</span> &gt; maxLength) &#123;</span><br><span class="line">                       maxLength = j - i + <span class="number">1</span>;</span><br><span class="line">                       maxString = s.substring(i, j + <span class="number">1</span>);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> maxString;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="思路3：manacher算法（马拉车）"><a href="#思路3：manacher算法（马拉车）" class="headerlink" title="思路3：manacher算法（马拉车）"></a>思路3：manacher算法（马拉车）</h3><ul><li>专门用于解决最长回文子串的算法</li></ul><h2 id="6-盛最多水的容器"><a href="#6-盛最多水的容器" class="headerlink" title="6. 盛最多水的容器"></a>6. 盛最多水的容器</h2><h3 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h3><blockquote><ul><li>给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</li></ul></blockquote><ul><li><a href="https://leetcode-cn.com/problems/container-with-most-water/">地址连接</a></li></ul><h3 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h3><p>容纳的水最多，即长乘宽的面积最大</p><h4 id="思路一：暴力算法"><a href="#思路一：暴力算法" class="headerlink" title="思路一：暴力算法"></a>思路一：暴力算法</h4><ul><li>每两个整数之间两两组合，求得最大的</li><li>代码实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxArea</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line"></span><br><span class="line">       <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt; height.length-<span class="number">1</span>; i++)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i+<span class="number">1</span>; j&lt;height.length;j++)&#123;</span><br><span class="line">               <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> Math.min(height[i],height[j]);</span><br><span class="line">               <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> j - i;</span><br><span class="line">               <span class="type">int</span> <span class="variable">cap</span> <span class="operator">=</span> h * w;</span><br><span class="line">               <span class="keyword">if</span>(cap &gt; max)&#123;</span><br><span class="line">                   max = cap;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> max;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li>复杂度<ul><li>时间复杂度O(n^2)</li></ul></li></ul><h4 id="思路二：双指针算法"><a href="#思路二：双指针算法" class="headerlink" title="思路二：双指针算法"></a>思路二：双指针算法</h4><ul><li><p>这是双指针算法的一个很好的例子</p></li><li><p>双指针算法能够将算法复杂度从O(N^2) 优化到O（N），因为避免了两层遍历</p></li><li><p>高度取决于两个整数中较小的那个，宽度取决于下标间的距离</p></li><li><p>思路过程</p><ol><li>首尾双指针，left和right，从两端出发</li><li>计算当前组合的面积，并和当前最大面积比较<ul><li>如果大，则更新最大面积以及下标</li></ul></li><li>继续遍历，缩小较小的边<ul><li>因为当前是较小整数被选中作为高的最大面积了</li><li>再往内部要么不会被选中，要么被选中了，但是宽度没现在大</li><li>所以较小整数可以从遍历的范畴中排除了</li></ul></li></ol></li><li><p>代码实现</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxArea</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = height.length-<span class="number">1</span>;</span><br><span class="line">       <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">           <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> Math.min(height[left],height[right]);</span><br><span class="line">           <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> right - left;</span><br><span class="line">           <span class="type">int</span> <span class="variable">cap</span> <span class="operator">=</span> h * w;</span><br><span class="line">           <span class="keyword">if</span>(cap &gt; max) max = cap;</span><br><span class="line">           <span class="keyword">if</span>(height[left] &lt; height[right])&#123;</span><br><span class="line">               left++;</span><br><span class="line">           &#125;<span class="keyword">else</span> right--;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> max;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li>算法复杂度<ul><li>时间复杂度O(N)</li></ul></li></ul><h2 id="7-三数之和"><a href="#7-三数之和" class="headerlink" title="7.三数之和"></a>7.三数之和</h2><h3 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h3><blockquote><ul><li>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c &#x3D; 0 ？请你找出所有满足条件且不重复的三元组。</li></ul></blockquote><ul><li>注意：答案中不可以包含重复的三元组。</li><li><a href="https://leetcode-cn.com/problems/3sum/">地址连接</a></li></ul><h3 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>想到之前的两数问题</li></ul><h4 id="思路一：暴力算法-1"><a href="#思路一：暴力算法-1" class="headerlink" title="思路一：暴力算法"></a>思路一：暴力算法</h4><ul><li>三重循环，O(N^3)</li><li>同时还存在严重的重复问题</li></ul><h4 id="思路二：排序-暴力"><a href="#思路二：排序-暴力" class="headerlink" title="思路二：排序+暴力"></a>思路二：排序+暴力</h4><ul><li><p>重复问题解决</p><ul><li>对数组提前进行排序</li></ul></li><li><p>遍历时候，跳过同样的元素</p></li><li><p>算法复杂度依然是O(N^3)</p></li></ul><h4 id="思路三：排序-双指针"><a href="#思路三：排序-双指针" class="headerlink" title="思路三：排序+双指针"></a>思路三：排序+双指针</h4><ul><li><p>重复问题</p><ul><li>与思路二一样</li></ul></li><li><p>排序之后，通过比较双指针值和target值，能有效缩小区间</p></li><li><p>思路过程</p><ol><li>第一重循环：选取第一个数 num[ i ]<ul><li>从第个数开始，到不满足targe结束</li><li>因为排序后，第一个数必须小于等于targe才能满足三数和为target</li></ul></li><li>第二重循环：从 num[i] 之后的区间，用双指针选择两个数<ul><li>如果 num[ left ] + num[ right ] &lt; target - num[i]，说明小了，左边界搜索</li><li>反之</li></ul></li><li>跳过重复元素<ul><li>第一重循环，当 i 位置处理结束，要移动到下一个与 i 不一样的元素处</li><li>第二重循环，当 left 和 right 移动时候，要移动到与下一个与当前值不一样的位置</li></ul></li></ol></li><li><p>代码实现</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">       LinkedList&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line"></span><br><span class="line">       Arrays.sort(nums);</span><br><span class="line">       <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span> (i &lt; nums.length &amp;&amp; nums[i] &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">               i++;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i + <span class="number">1</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">           <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">               <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[i] + nums[left] + nums[right];</span><br><span class="line">               <span class="keyword">if</span> (sum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                   right--;</span><br><span class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                   left++;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="type">List</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line">                   res.add(nums[i]);</span><br><span class="line">                   res.add(nums[left]);</span><br><span class="line">                   res.add(nums[right]);</span><br><span class="line">                   list.add(res);</span><br><span class="line">                   <span class="keyword">while</span> (left+<span class="number">1</span>&lt;nums.length &amp;&amp; nums[left]==nums[left+<span class="number">1</span>])&#123;</span><br><span class="line">                       left++;</span><br><span class="line">                   &#125;</span><br><span class="line">                   left++;</span><br><span class="line">                   <span class="keyword">while</span> (right-<span class="number">1</span>&gt;=<span class="number">0</span> &amp;&amp; nums[right] == nums[right-<span class="number">1</span>])&#123;</span><br><span class="line">                       right--;</span><br><span class="line">                   &#125;</span><br><span class="line">                   right--;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           i++;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> list;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li>算法复杂度<ul><li>时间复杂度O(N)</li></ul></li></ul><h2 id="8-电话号码的字母组合"><a href="#8-电话号码的字母组合" class="headerlink" title="8.电话号码的字母组合"></a>8.电话号码的字母组合</h2><h3 id="题目-7"><a href="#题目-7" class="headerlink" title="题目"></a>题目</h3><blockquote><ul><li>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。</li></ul></blockquote><ul><li>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</li><li>输入：”23”</li><li>输出：[“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”].</li><li><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/">题目地址</a></li></ul><h3 id="解题思路-7"><a href="#解题思路-7" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li><p>属于排列组合问题</p></li><li><p>回溯算法遍历所有的情况，多叉树遍历</p></li><li><p>思路过程</p><ol><li>StringBuilder 记录从根到叶子节点的路径</li><li>对多叉树进行遍历，每个阶段将字符加入stringbuilder</li><li>回溯时候，撤销之前添加的字符</li></ol></li><li><p>代码实现</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Integer,String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">letterCombinations</span><span class="params">(String digits)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(digits.length() == <span class="number">0</span>) <span class="keyword">return</span> result;</span><br><span class="line">        map.put(<span class="number">2</span>,<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        map.put(<span class="number">3</span>,<span class="string">&quot;def&quot;</span>);</span><br><span class="line">        map.put(<span class="number">4</span>,<span class="string">&quot;ghi&quot;</span>);</span><br><span class="line">        map.put(<span class="number">5</span>,<span class="string">&quot;jkl&quot;</span>);</span><br><span class="line">        map.put(<span class="number">6</span>,<span class="string">&quot;mno&quot;</span>);</span><br><span class="line">        map.put(<span class="number">7</span>,<span class="string">&quot;pqrs&quot;</span>);</span><br><span class="line">        map.put(<span class="number">8</span>,<span class="string">&quot;tuv&quot;</span>);</span><br><span class="line">        map.put(<span class="number">9</span>,<span class="string">&quot;wxyz&quot;</span>);</span><br><span class="line">        combinations(digits,<span class="number">0</span>,<span class="keyword">new</span> <span class="title class_">StringBuilder</span>());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">combinations</span><span class="params">(String digits, <span class="type">int</span> index, StringBuilder builder)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index == digits.length()) &#123;</span><br><span class="line">            result.add(builder.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">chars</span> <span class="operator">=</span> map.get(digits.charAt(index) - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; chars.length(); i++) &#123;</span><br><span class="line">            builder.append(chars.charAt(i));</span><br><span class="line">            combinations(digits,index+<span class="number">1</span>,builder);</span><br><span class="line">            builder.deleteCharAt(builder.length()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>复杂度<ul><li>时间复杂度：O(4^n)</li><li>空间复杂度：O(4^n)</li></ul></li></ul><h2 id="9-有效的括号组合"><a href="#9-有效的括号组合" class="headerlink" title="9.有效的括号组合"></a>9.有效的括号组合</h2><h3 id="题目-8"><a href="#题目-8" class="headerlink" title="题目"></a>题目</h3><blockquote><ul><li>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</li></ul></blockquote><ul><li>有效字符串需满足：<ul><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li></ul></li><li>注意空字符串可被认为是有效字符串。</li><li>输入: “([)]”</li><li>输出: false</li><li><a href="https://leetcode-cn.com/problems/valid-parentheses/">题目地址</a></li></ul><h3 id="解题思路-8"><a href="#解题思路-8" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li><p>通过栈来暂存左括号，进行匹配</p></li><li><p>思路过程</p><ol><li><p>读取字符</p><ul><li>如果是左括号，则直接入栈</li><li>如果是右括号，步骤2</li></ul></li><li><p>如果是右括号，检查栈顶是否是该右括号的左括号</p><ul><li>是，则弹出栈顶，读取下一个</li><li>不是，则匹配失败，false</li></ul></li><li><p>最终还需要检查栈是否为空，避免最后一个字符是左括号</p></li></ol></li><li><p>代码实现</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isLeft(s.charAt(i))) &#123;</span><br><span class="line">                stack.push(s.charAt(i));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isRight(s.charAt(i))) &#123;</span><br><span class="line">                <span class="keyword">if</span>(!stack.isEmpty()&amp;&amp;isLeftMatchRight(stack.peek(),s.charAt(i)))&#123;</span><br><span class="line">                    stack.pop();</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123; </span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isLeft</span><span class="params">(<span class="type">char</span> c)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> c == <span class="string">&#x27;(&#x27;</span> || c == <span class="string">&#x27;&#123;&#x27;</span> || c == <span class="string">&#x27;[&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isRight</span><span class="params">(<span class="type">char</span> c)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> c == <span class="string">&#x27;)&#x27;</span> || c == <span class="string">&#x27;&#125;&#x27;</span> || c == <span class="string">&#x27;]&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isLeftMatchRight</span><span class="params">(<span class="type">char</span> left, <span class="type">char</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> left == <span class="string">&#x27;(&#x27;</span> &amp;&amp; right == <span class="string">&#x27;)&#x27;</span></span><br><span class="line">                || left == <span class="string">&#x27;[&#x27;</span> &amp;&amp; right == <span class="string">&#x27;]&#x27;</span></span><br><span class="line">                || left == <span class="string">&#x27;&#123;&#x27;</span> &amp;&amp; right == <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>复杂度<ul><li>时间复杂度O(N)</li><li>空间复杂度O(N)</li></ul></li></ul><h2 id="10-删除链表的倒数第N个节点"><a href="#10-删除链表的倒数第N个节点" class="headerlink" title="10. 删除链表的倒数第N个节点"></a>10. 删除链表的倒数第N个节点</h2><h3 id="题目-9"><a href="#题目-9" class="headerlink" title="题目"></a>题目</h3><blockquote><ul><li>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</li></ul></blockquote><ul><li><p>示例：给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n &#x3D; 2.</p><ul><li>当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.</li></ul></li><li><p>给定的 n 保证是有效的。</p></li><li><p>你能尝试使用一趟扫描实现吗？</p></li><li><p><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">题目地址</a></p></li></ul><h3 id="解题思路-9"><a href="#解题思路-9" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="思路一：两次遍历"><a href="#思路一：两次遍历" class="headerlink" title="思路一：两次遍历"></a>思路一：两次遍历</h4><ul><li>第一次遍历，统计链表个数</li><li>第二次遍历，删除倒数第N个节点</li><li>算法复杂度：O(N)</li></ul><h4 id="思路二：HashMap遍历-一次遍历"><a href="#思路二：HashMap遍历-一次遍历" class="headerlink" title="思路二：HashMap遍历+一次遍历"></a>思路二：HashMap遍历+一次遍历</h4><ul><li>遍历链表，将位置和节点映射关系存入hashmap，同时计数</li><li>计算倒数第N个节点的索引，直接删除</li></ul><h4 id="思路三：递归实现"><a href="#思路三：递归实现" class="headerlink" title="思路三：递归实现"></a>思路三：递归实现</h4><ul><li><p>只需要遍历一次即可</p></li><li><p>思路过程</p><ol><li>递归返回值表示当前倒数第几个节点</li><li>如果head &#x3D;&#x3D; null， ruturn 0；</li><li>如果 返回值恰好为N，则删除该节点<ul><li>head.next &#x3D; head.next.next;</li></ul></li><li>为了方便删除头节点，适用一个哨兵<ul><li>ListNode tempHead &#x3D; new ListNode(1);</li><li>tempHead.next &#x3D; head;</li></ul></li></ol></li><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tempHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        tempHead.next = head;</span><br><span class="line">        recur(tempHead,n);</span><br><span class="line">        <span class="keyword">return</span> tempHead.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">recur</span><span class="params">(ListNode head, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> recur(head.next,n);</span><br><span class="line">        <span class="keyword">if</span>(num == n)&#123;</span><br><span class="line">            <span class="comment">// 删除</span></span><br><span class="line">            head.next = head.next!=<span class="literal">null</span> ? head.next.next : <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>复杂度</p><ul><li>时间复杂度O(N)</li><li>空间复杂度O(N)</li></ul></li></ul><h2 id="下个路口见"><a href="#下个路口见" class="headerlink" title="下个路口见"></a>下个路口见</h2><p>HOT100依然在继续，写在下一篇文章中。<a href="http://blog.zwboy.cn/ji-zhu/leetcode-hot-100-shua-ti-11-20.html">传送门</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer刷题全过程</title>
      <link href="/2022/07/18/%E5%89%91%E6%8C%87offer/"/>
      <url>/2022/07/18/%E5%89%91%E6%8C%87offer/</url>
      
        <content type="html"><![CDATA[<blockquote><p>背景知识</p></blockquote><h1 id="剑指Offer刷题全过程"><a href="#剑指Offer刷题全过程" class="headerlink" title="剑指Offer刷题全过程"></a>剑指Offer刷题全过程</h1><h2 id="1-基础算法"><a href="#1-基础算法" class="headerlink" title="1. 基础算法"></a>1. 基础算法</h2><h3 id="二分查找算法"><a href="#二分查找算法" class="headerlink" title="二分查找算法"></a>二分查找算法</h3><h4 id="基础算法"><a href="#基础算法" class="headerlink" title="基础算法"></a>基础算法</h4><ul><li><p>输入</p><ul><li><p>必须是排序好的数组</p></li><li><p>二分区间起点start</p></li><li><p>二分区间终点end<br>  - 闭区间<br>  - 包括end的值<br>  - arrays.length - 1</p><ul><li>查找值</li></ul></li><li><p>返回值</p><ul><li>返回查找元素所在的下标 int</li><li>不存在，则返回下标 -1</li></ul></li><li><p>实现过程</p><ul><li><p>递归实现</p><ul><li><ol><li>重要，判断边界：if(start &gt; end) return -1;</li></ol></li><li><ol start="2"><li>计算middle &#x3D; （start + end）&#x2F;2；</li></ol></li><li><ol start="3"><li>比较middle的值</li></ol><ul><li><p>相等，则return middle</p></li><li><p>比target大，则查找左侧区间</p><ul><li>起点：start</li><li>终点：middle -1</li></ul></li><li><p>比target小，则查找右侧区间</p><ul><li>起点：middle + 1</li><li>终点：end</li></ul></li></ul></li></ul></li><li><p>循环实现</p><ul><li><ol><li>初始化 start 和 end 循环遍历</li></ol></li><li><ol start="2"><li>while循环</li></ol><ul><li><p>边界判断条件</p><ul><li>start &lt;&#x3D; end</li><li>和递归中的一样</li></ul></li><li><p>计算middle &#x3D; （start + end）&#x2F;2</p></li><li><p>middle与target相等，return middle</p></li><li><p>middle 大于 target，更新右边界</p><ul><li>end &#x3D; middle -1</li></ul></li><li><p>middle 小于 target， 更新左边界</p><ul><li>start &#x3D; middle + 1</li></ul></li></ul></li></ul></li></ul></li></ul></li><li><p>变种算法</p><ul><li><ol><li>将二分查找中的相等判断变为其他判断</li></ol><ul><li>比如 题3 中拓展题的解法2</li></ul></li><li><ol start="2"><li>用于划分有序数组的边界</li></ol><ul><li>如果数组存在target，直接返回坐标</li><li>如果数组不存在target，则返回比它小的第一个值</li></ul></li></ul></li></ul><h3 id="子主题-2"><a href="#子主题-2" class="headerlink" title="子主题 2"></a>子主题 2</h3><h2 id="2-排序算法"><a href="#2-排序算法" class="headerlink" title="2. 排序算法"></a>2. 排序算法</h2><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><ul><li><p>关于</p></li><li><p>算法思想</p><ul><li><p>分治</p><ul><li><p>基准值：pivot</p><ul><li><p>选出一个基准值（一般为第一个元素）</p></li><li><p>依据基准值的大小，将分段分两个部分</p><ul><li>左边比自己小</li><li>右边比自己大</li></ul></li></ul></li><li><p>分区：partition</p><ul><li>一个分区运行过分区算法后，将被基准值分成两个子分区</li></ul></li></ul></li><li><p>递归</p><ul><li>再各个分区上，再此选出一个基准值，再此分段</li><li>每次执行分区算法，都能确定基准值的中间位置</li><li>递归执行</li></ul></li></ul></li><li><p>算法步骤</p><ul><li><ol><li>实现分区算法</li></ol><ul><li><ol><li>参数：分区start，分区end</li></ol></li><li><ol start="2"><li>选取 start 作为基准值pivot</li></ol></li><li><ol start="3"><li>初始middle为start+1</li></ol><ul><li>表示下一个用于交换的位置</li><li>最终基准值所在的位置为 middle-1</li></ul></li><li><ol start="4"><li>依次将区间中的每个元素和基准值比较</li></ol></li><li><ol start="5"><li>重点是分区内值的交换</li></ol><ul><li>不是直接拿 基准值 和 被比较值 交换，这样不好处理</li><li>而是在基准值之后的区间中，将小于基准值的向前交换，将大于基准值的向后交换</li><li>最终遍历完，分区分为两部分了，再将基准值交换过去</li><li>引入一个index，记录大于基准值的数和小于基准值的数之间的界限，每次拿这个界限交换</li></ul></li><li><ol start="6"><li>最终将基准值和中间位置交换，中间位置为middle - 1</li></ol></li><li><ol start="7"><li>返回基准值所在的中间坐标</li></ol></li><li><p>int partition(nums, start, end) {<br>int pivot &#x3D; start;<br>int middle &#x3D; start + 1;<br>for( int i &#x3D; middle; i &lt; end; i++) {<br>if( num[i] &lt; num[pivot] ) {<br>         swap( num, i, middle );<br>         middle++;<br>}</p></li></ul><p>}<br>swap( num, pivot, middle-1 );<br>return middle - 1;</p></li></ul></li></ul><p>}</p><pre><code>- 2. 实现递归总方法    - 1. 先执行分区算法，返回分区后的中间下标        - 即上一次分区结束基准值所在的位置        - 分成两个分区            - start到middle                - 不包括middle            - middle                - 已经确定位置了，不用再参与分区了            - middle+1到end                - 不包括end    - 2. 中间下标将分区分成两个子分区，继续在两个子分区上递归执行快排        - 左边分区快排        - 右边分区快排    - void quickSort(num, start, end)&#123;    if( start &lt; end ) &#123;            int middle = partition(num, start, end);            quickSort(num, start, middle);            quickSort(num, middle+1, end);    &#125;</code></pre><p>}</p><ul><li><p>评估</p><ul><li><p>时间复杂度：Ο(nlogn) </p><ul><li>最坏运行情况是 O(n²)</li><li>最坏：顺序数列的快排</li></ul></li><li><p>相比其他排序算法，比较好</p></li><li><p>处理大数据最快的排序算法之一</p></li></ul></li></ul><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><h3 id="子主题-3"><a href="#子主题-3" class="headerlink" title="子主题 3"></a>子主题 3</h3><h2 id="3-数据重复数字"><a href="#3-数据重复数字" class="headerlink" title="3. 数据重复数字"></a>3. 数据重复数字</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><ul><li><p>一个长度为 n 的数组 nums </p><ul><li>所有数字都在 0～n-1 的范围内</li><li>数组中存在数值是重复的</li><li>不知道有几个重复，也不知道会重复几次</li></ul></li><li><p>找出任意一个重复的数值</p></li></ul><h3 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h3><ul><li><ol><li>暴力两个循环(实在不会)</li></ol><ul><li>时间复杂度O(n2)</li><li>空间复杂度O(1)</li><li>不推荐</li></ul></li><li><ol start="2"><li>先排序+查找</li></ol><ul><li><p>思路</p><ul><li><ol><li>先排序 O(nlogn)</li></ol><ul><li>快排算法</li></ul></li><li><ol start="2"><li>再查找 O(n)</li></ol><ul><li>循环遍历</li></ul></li></ul></li><li><p>评估</p><ul><li>时间复杂度 O(nlogn) + O(n)</li><li>空间复杂度 O(1)</li><li>空间复杂度优先</li></ul></li></ul></li><li><ol start="3"><li>哈希表&#x2F;哈希集（冲突检查）</li></ol><ul><li><p>思路</p><ul><li><p>扫描数组 O(n)</p><ul><li>边扫描，边判断是否哈希表中是否已经存在</li><li>存在，则查找成功了</li><li>不存在，则将该值存入哈希表，继续下一个</li></ul></li><li><p>判断哈希表中是否存在 O(1)</p></li></ul></li><li><p>评估</p><ul><li>时间复杂度 O(n)</li><li>空间复杂度 O(n)</li><li>以空间换时间，时间复杂度优先</li></ul></li></ul></li><li><ol start="4"><li>鸽巢原理（最优）</li></ol><ul><li><p>充分利用数值在 1到n-1之间的条件，数组下标与值对应关系</p></li><li><p>类似哈希表，假设数组无重复，通过冲突来检测重复</p></li><li><p>思路</p><ul><li><ol start="0"><li>假设数组无重复元素，则每个元素的值与他的下表应该是相等的</li></ol></li><li><ol><li>遍历数组每个元素，下标为i, 值为m</li></ol></li><li><ol start="2"><li>比较 m 是否和 i 相等</li></ol><ul><li>相等，说明当前数值在正确的位置上，检查下一个下标</li></ul></li><li><ol start="3"><li>m 和 i 不相等，说明不在正确的位置上</li></ol><ul><li>检查 下标 m 位置的值是否已经是 m 了</li><li>如果是 m ，说明m值重复了，查找结束</li><li>如果不是m，则将m值交换过去，另一个值交换回来</li></ul></li><li><ol start="3"><li>继续遍历</li></ol></li></ul></li><li><p>评估</p><ul><li>时间复杂度 O(n)</li><li>空间复杂度 O(1)</li><li>最优的算法了吧</li></ul></li></ul></li><li><ol start="5"><li>基于桶计数</li></ol><ul><li>能支持更多的重复次数</li><li>对各个数值出现的次数做统计</li><li>当出现次数大于等于2，则结束</li><li>类似哈希表解法的方式</li></ul></li></ul><h3 id="拓展：不允许更改数组"><a href="#拓展：不允许更改数组" class="headerlink" title="拓展：不允许更改数组"></a>拓展：不允许更改数组</h3><ul><li><ol><li>数组复制查找</li></ol><ul><li><p>思路</p><ul><li><ol><li>新建一个n长度的数组</li></ol></li><li><ol start="2"><li>将原数组中值为m的元素复制到辅助数组下标为m的位置</li></ol></li><li><ol start="3"><li>如果m位置已经有元素了，则查找重复成功</li></ol></li></ul></li><li><p>评估</p><ul><li>时间复杂度： O(n)</li><li>空间复杂度：O(n)</li></ul></li></ul></li><li><ol start="2"><li>二分查找变种</li></ol><ul><li><p>思路</p><ul><li>将数值范围分为 [ 0, n\2 ]  和 [ n\2+1 ，n-1]</li><li>如果 1 到 n\2 出现的次数大于 n\2，那么 1 到 n\2 中一定存在一个重复</li><li>是二分查找的变种，只是将查找的判断变为数数值出现的次数是否大于区间长度</li></ul></li><li><p>评估</p><ul><li>时间复杂度：O(nlogn)</li><li>空间复杂度：O(1)</li></ul></li></ul></li></ul><h2 id="4-二维数组中的查找"><a href="#4-二维数组中的查找" class="headerlink" title="4. 二维数组中的查找"></a>4. 二维数组中的查找</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><ul><li><p>一个n*m的数组</p><ul><li>每一行都按照从左到右递增的顺序排序</li><li>每一列都按照从上到下递增的顺序排序</li></ul></li><li><p>输入一个元素value，查找该元素是否在该数组中</p></li><li><p>链接</p></li></ul><h3 id="接替思路"><a href="#接替思路" class="headerlink" title="接替思路"></a>接替思路</h3><ul><li><ol><li>从右上角二分查找</li></ol><ul><li><p>思路过程</p><ul><li><p>注意边界条件判断</p><ul><li>空数组</li><li>维度为0</li></ul></li><li><ol><li>先在最右侧的列上进行二分查找，查找目标值，或则确定边界</li></ol></li><li><ol start="2"><li>排除上方较小的行，在边界行上再做二分查找</li></ol></li><li><ol start="3"><li>查找到目标支或者边界值，排除掉部分右侧的列</li></ol></li><li><ol start="4"><li>再继续在新的列上进行二分查找</li></ol></li></ul></li><li><p>评估</p><ul><li>时间复杂度 O(nlogn + mlogm)</li><li>是自己考虑到和实现的算法</li><li>原本以为使用二分查找比较高效，其实时间复杂度更大了</li><li>因为按行列挨个排除只需要在行列上进行O(n)，而二分查找在每次缩小区间之后，还要再此二分查找，整体O(nlogn + mlogm)</li></ul></li></ul></li><li><ol><li>从右上角依次行列查找</li></ol><ul><li><p>思路</p><ul><li><ol><li>也是从右上角开始</li></ol></li><li><ol start="2"><li>判断右上角的值是否等于查找值</li></ol></li><li><ol start="3"><li>比查找值大，则排除该列，列–</li></ol></li><li><ol start="4"><li>比查找值小，则排除该行，行++</li></ol></li><li><ol start="5"><li>直到最终查找成功，或者数组下标突破边界条件</li></ol></li></ul></li><li><p>评估</p><ul><li>时间复杂度 O(n+m)</li><li>剑指Offer上推荐的算法</li><li>比较简单高效</li></ul></li></ul></li></ul><h2 id="5-替换字符串空格字符"><a href="#5-替换字符串空格字符" class="headerlink" title="5. 替换字符串空格字符"></a>5. 替换字符串空格字符</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><ul><li>URL编码函数</li><li>将字符串数组中的每个空格字符替换成%20</li><li>比如 “Happy Birthday” 替换为 “Happy%20Birthday”</li><li>注意，需要在已有的字符数组上进行操作，不能拷贝新的字符串数组</li></ul><h3 id="关于字符串存储"><a href="#关于字符串存储" class="headerlink" title="关于字符串存储"></a>关于字符串存储</h3><ul><li>Java中，字符串是用常量表示的，为了复用</li><li>所以，无法更改字符串，只能用新的字符串替代已有的字符串</li><li>StringBuilder，用于组装字符串，每次向字符串追加字符，不会造成新的字符串常量的生成</li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li><p>暴力，不可取</p><ul><li><p>遍历该字符串中的所有字符，当检测到空格，则</p></li><li><p>将其后的所有字符依次右移3个位置</p></li><li><p>评估</p><ul><li>时间复杂度 O(n2)</li></ul></li></ul></li><li><p>从后向前替换</p><ul><li><p>过程</p><ul><li><ol><li>遍历字符串，计数空格的个数</li></ol></li><li><ol start="2"><li>基于空格个数，计算最终字符串的总长度，即字符串结尾</li></ol></li><li><ol start="3"><li>从后向前再此遍历字符串，并将其移动到最终的位置</li></ol></li></ul></li><li><p>评估</p><ul><li>时间复杂度O(n)</li></ul></li></ul></li></ul><h2 id="7-重建二叉树"><a href="#7-重建二叉树" class="headerlink" title="7.重建二叉树"></a>7.重建二叉树</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><ul><li><p>输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p></li><li><p>比如</p><ul><li>前序遍历 preorder &#x3D; [3,9,20,15,7]</li><li>中序遍历 inorder &#x3D; [9,3,15,20,7]</li></ul></li><li><p>结果</p><ul><li><pre><code>3</code></pre></li></ul><p> &#x2F; <br>9  20<br>  &#x2F;  <br> 15   7</p></li></ul><h3 id="接替思路-1"><a href="#接替思路-1" class="headerlink" title="接替思路"></a>接替思路</h3><ul><li><ol><li>前序遍历中最先得到的是根，而根能够将中序遍历由根分为左右两个部分</li></ol></li><li><ol start="2"><li>preorder和inorder因此可以被继续划分成更小的遍历对</li></ol></li><li><ol start="3"><li>形成一个递归问题</li></ol></li><li><pre><code>private TreeNode build(int[]preorder,int[] inorder,int start1,int end1,int start2,int end2)&#123;  if(end2 &lt; start2 || start1&gt;end1 || start2&gt;end2)&#123;      return null;  &#125;else &#123;      TreeNode node = new TreeNode(preorder[start1]);      int pos = findPos(inorder,preorder[start1]);      node.left = build(preorder,inorder,start1+1,start1+pos-start2,start2,pos-1);      node.right= build(preorder,inorder,start1+pos-start2+1,end1,pos+1,end2);      return node;  &#125;</code></pre>  }</li></ul><h2 id="8-两个栈实现队列"><a href="#8-两个栈实现队列" class="headerlink" title="8. 两个栈实现队列"></a>8. 两个栈实现队列</h2><h3 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h3><ul><li><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</p></li><li><p>输入：</p><ul><li>[“CQueue”,”appendTail”,”deleteHead”,”deleteHead”]</li><li>[[],[3],[],[]]</li></ul></li><li><p>输出：[null,null,3,-1]</p></li></ul><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li><ol><li>两个栈，左栈和右栈</li></ol></li><li><ol start="2"><li>入队列一律都是加入到左栈中</li></ol></li><li><ol start="3"><li>出队列</li></ol><ul><li>如果都在左栈，右栈为空，则全部push pop到右栈，pop右栈栈顶</li><li>如果右栈不空，则直接pop右栈即可，左栈继续作为入队列</li></ul></li></ul><h2 id="9-斐波拉契数列计算"><a href="#9-斐波拉契数列计算" class="headerlink" title="9.斐波拉契数列计算"></a>9.斐波拉契数列计算</h2><h3 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h3><ul><li>给一个n，计算斐波拉契数列中n位置的数值</li></ul><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li><p>递归实现</p><ul><li>十分简单，但是会超时</li><li>因为存在很多的重复计算子问题</li></ul></li><li><p>递归+备忘录</p><ul><li>在递归的基础上，记录以及计算过的f(n)</li><li>将计算过的数据存储到数组中</li><li>使用之前先到备忘录中查找</li><li>备忘录可以使用一维数组或者Map实现</li></ul></li><li><p>动态规划</p><ul><li>存在重复子问题</li><li>无后效性</li><li>递推方程已知道</li></ul></li></ul><h2 id="10-青蛙跳台阶问题"><a href="#10-青蛙跳台阶问题" class="headerlink" title="10.青蛙跳台阶问题"></a>10.青蛙跳台阶问题</h2><h3 id="其实是斐波拉契数列问题的变种"><a href="#其实是斐波拉契数列问题的变种" class="headerlink" title="其实是斐波拉契数列问题的变种"></a>其实是斐波拉契数列问题的变种</h3><h3 id="类似的，整钱破成零钱的组合问题"><a href="#类似的，整钱破成零钱的组合问题" class="headerlink" title="类似的，整钱破成零钱的组合问题"></a>类似的，整钱破成零钱的组合问题</h3><h2 id="11-旋转数组的最小值查找"><a href="#11-旋转数组的最小值查找" class="headerlink" title="11. 旋转数组的最小值查找"></a>11. 旋转数组的最小值查找</h2><h3 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h3><ul><li>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。  </li><li>输入：[3,4,5,1,2]</li><li>输出：1</li></ul><h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li><p>看到排序数组的查找，首先要想到二分查找</p></li><li><p>二分查找能够将复杂度从n将到对数</p></li><li><p>关键是二分中的减治过程设计</p><ul><li><p>array[middle] &gt; array[right] </p><ul><li>说明旋转点在右边</li><li>left &#x3D; middle + 1</li></ul></li><li><p>array[middle] &#x3D; array[right] </p><ul><li>无法判断旋转点在左还是右</li><li>但可以确定排除不是right</li><li>right &#x3D; right -1</li></ul></li><li><p>array[middle] &lt; array[right] </p><ul><li>说明旋转点在左边</li><li>right &#x3D; middle</li></ul></li></ul></li></ul><h2 id="12-矩阵路径查找问题"><a href="#12-矩阵路径查找问题" class="headerlink" title="12. 矩阵路径查找问题"></a>12. 矩阵路径查找问题</h2><h3 id="题目-7"><a href="#题目-7" class="headerlink" title="题目"></a>题目</h3><ul><li>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。</li><li>[<br>   [“a”,”b”,”c”,”e”],<br>   [“s”,”f”,”c”,”s”],<br>   [“a”,”d”,”e”,”e”]<br>]</li><li>但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。</li></ul><h3 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li><p>典型的矩阵中的路径搜索问题</p></li><li><p>可以使用 DFS + 剪枝 的解法</p><ul><li>为什么不用BFS，而是DFS</li><li>DFS 能够暴力遍历矩阵中的所有路径</li><li>BFS不适合用来遍历路径，而适合计算最短路径</li></ul></li><li><p>算法流程</p><ul><li><ol><li>从 board数组中查找第一个  board[i][j]  &#x3D;&#x3D; word[0];</li></ol></li><li><ol start="2"><li>visited[i][j] &#x3D; true;，先暂时标记为已经访问过了</li></ol></li><li><ol start="3"><li>如果 index &#x3D;&#x3D; word.length()，则返回true</li></ol></li><li><ol start="3"><li>遍历所有子节点，在子节点上执行DFS</li></ol></li><li><ol start="4"><li>如果所有邻接顶点经过 DFS 之后，返回false，则撤销还原 visited[i][j] &#x3D; false;</li></ol></li></ul></li></ul><h2 id="13-机器人运动范围问题"><a href="#13-机器人运动范围问题" class="headerlink" title="13. 机器人运动范围问题"></a>13. 机器人运动范围问题</h2><h3 id="题目-8"><a href="#题目-8" class="headerlink" title="题目"></a>题目</h3><ul><li><p>地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7&#x3D;18。但它不能进入方格 [35, 38]，因为3+5+3+8&#x3D;19。请问该机器人能够到达多少个格子？</p></li><li><p>输入：m &#x3D; 2, n &#x3D; 3, k &#x3D; 1</p></li><li><p>输出：3</p></li></ul><h3 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li><p>思路很清除，矩阵遍历问题，和上一题类似</p><ul><li><p>DFS</p><ul><li>更简单一些</li></ul></li><li><p>BFS</p><ul><li>使用到队列</li></ul></li></ul></li><li><p>DFS过程中基于是否能停留的条件进行剪枝</p></li></ul><h2 id="14-割绳子问题"><a href="#14-割绳子问题" class="headerlink" title="14.割绳子问题"></a>14.割绳子问题</h2><h3 id="题目-9"><a href="#题目-9" class="headerlink" title="题目"></a>题目</h3><ul><li><p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m-1] 。请问 k[0]<em>k[1]</em>…*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p></li><li><p>输入: 2</p></li><li><p>输出: 1</p></li><li><p>解释: 2 &#x3D; 1 + 1, 1 × 1 &#x3D; 1</p></li></ul><h3 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li><p>回溯算法+备忘录</p><ul><li>可以看作是对n个数进行划分</li><li>通过回溯遍历所有可能的状态</li><li>实现回溯算法</li><li>添加备忘录，参照斐波拉契数列</li><li>F(n) &#x3D; MAX{  i<em>F(n-i) , i</em>(n-i) }</li></ul></li><li><p>动态规划</p><ul><li><p>回溯+备忘录可以解决，那么DP一定也可以</p></li><li><p>dp[] 表示各个长度的绳子，最大的乘积</p><ul><li>一般dp[]存储的值就是最终的目的值</li></ul></li><li><p>状态转移方程</p><ul><li>dp[i] &#x3D; MAX{ dp[i], MAX{  j<em>dp[i-j],  j</em>(i-j) }}</li><li>i &#x3D; 2,3,4,5,…,n</li><li>j &#x3D; 1,2,3,4,…, n-2</li></ul></li></ul></li><li><p>贪婪算法</p><ul><li><p>每一步选择最优解</p></li><li><p>需要直到贪婪选择的条件</p><ul><li><ol><li>将分成以3为单位的分段越多，最后的结果越大</li></ol></li><li><ol start="2"><li>对于4，将其分为2+2，比分为3+1，结果要更好</li></ol></li></ul></li><li><p>算法实现</p><ul><li>public int cuttingRope(int n) {<br>  if( n &lt; 4 ){<br> return n-1;<br>  }<br>  int result &#x3D; 1;<br>  while( n &gt; 4 ){<br> result &#x3D; result * 3;<br> n &#x3D; n - 3;<br>  }<br>  return result * n;</li></ul></li></ul><p>  }</p></li></ul><h3 id="拓展问题：大数溢出问题"><a href="#拓展问题：大数溢出问题" class="headerlink" title="拓展问题：大数溢出问题"></a>拓展问题：大数溢出问题</h3><ul><li><p>题目</p><ul><li><p>与原题基本相同</p></li><li><p>但需要对结果进行取模</p><ul><li>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</li></ul></li></ul></li><li><p>带来的问题</p><ul><li><p>之前的DP无法使用了</p><ul><li>因为DP中需要进行比较，而溢出和取模会影响大小的比较</li></ul></li><li><p>需要对结果进行取模操作</p></li></ul></li><li><p>解题思路</p><ul><li><p>贪婪算法 + 循环取模</p><ul><li><p>循环取模原理</p><ul><li>对x的n方最终的取模，等价于乘积过程中循环取模</li></ul></li><li><p>每次计算乘积以及最后的结果都进行取模操作</p></li><li><p>其余与之前一样</p></li></ul></li><li><p>DP + BigInteger</p><ul><li><p>使用普通的int或long会造成溢出</p></li><li><p>BigInteger无限位数，解决溢出的问题</p></li><li><p>缺点是，BigInteger的计算更复杂一些</p></li><li><p>Java提供的大数</p><ul><li><p>BigInteger</p><ul><li><p>解决整数部分位数过长</p></li><li><p>初始化</p><ul><li>BigInteger（“111”）</li><li>使用字符串进行初始化</li></ul></li><li><p>加</p><ul><li>add(BigInteger val)</li><li>返回计算结果</li></ul></li><li><p>减</p><ul><li>subtract</li></ul></li><li><p>乘</p><ul><li>multiply</li></ul></li><li><p>除</p><ul><li>divide</li></ul></li><li><p>比较大</p><ul><li>max</li><li>返回较大数</li></ul></li><li><p>比较小</p><ul><li>min</li><li>返回较小数</li></ul></li><li><p>求余数</p><ul><li><p>divideAndRemainder</p></li><li><p>返回一个BigInteger</p><ul><li>0：为商</li><li>1：为余数</li></ul></li></ul></li></ul></li><li><p>BigDecimal</p><ul><li>解决小数部分位数</li></ul></li></ul></li><li><p>算法实现</p><ul><li>代码</li></ul></li></ul></li></ul></li></ul><h2 id="15-二进制数中1个数，位运算"><a href="#15-二进制数中1个数，位运算" class="headerlink" title="15. 二进制数中1个数，位运算"></a>15. 二进制数中1个数，位运算</h2><h3 id="题目-10"><a href="#题目-10" class="headerlink" title="题目"></a>题目</h3><ul><li><p>请实现一个函数，输入一个整数，输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。</p></li><li><p>输入：00000000000000000000000000001011</p></li><li><p>输出：3</p></li><li><p>解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 ‘1’。</p></li></ul><h3 id="解题思路-7"><a href="#解题思路-7" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li><p>数二进制中1的个数</p><ul><li>n % 2, 获得末位是否为1</li><li>n \ 2 ，除掉末尾，即右移一位</li><li>循环中计数1出现的次数，当n除成0时候，结束</li></ul></li><li><p>二进制位移运算</p><ul><li><p>对于二进制，需要通过位运算来操作，而不是加减乘除</p></li><li><p>&amp;</p><ul><li>n &amp; 1</li><li>取最后一位操作</li></ul></li><li><blockquote><blockquote><blockquote></blockquote></blockquote></blockquote><ul><li><p>右移操作</p></li><li><p>n &gt;&gt;&gt; 1</p><ul><li>等价于 n &#x2F; 2</li></ul></li></ul></li><li><p>public int hammingWeight(int n) {<br>  int count &#x3D; 0;<br>  while(n!&#x3D;0){<br>  int left &#x3D; n &amp; 1;<br>  if(left &#x3D;&#x3D; 1){<br>      count++;<br>  }<br>  n &#x3D; n &gt;&gt;&gt; 1;<br>  }<br>  return count;<br>  }</p></li></ul></li><li><p>位运算方法</p><ul><li><p>n &amp; （n-1）</p></li><li><p>n-1</p><ul><li>将二进制最右边第一个为1的位变为0 ，其后的位补为1</li><li>n&#x3D; 10101010000, n-1为10101001111</li><li>n &amp; (n-1) 为 10101000000</li></ul></li><li><p>public int hammingWeight(int n) {<br> int count &#x3D; 0;<br>  while(n !&#x3D; 0){<br>  count++;<br>  n &#x3D; n&amp;(n-1);<br>  }<br>  return count;<br>  }</p></li></ul></li></ul><h2 id="16-数值的整数次幂（快速幂）"><a href="#16-数值的整数次幂（快速幂）" class="headerlink" title="16. 数值的整数次幂（快速幂）"></a>16. 数值的整数次幂（快速幂）</h2><h3 id="题目-11"><a href="#题目-11" class="headerlink" title="题目"></a>题目</h3><ul><li><p>实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。</p></li><li><p>输入: 2.00000, 10</p></li><li><p>输出: 1024.00000</p></li></ul><h3 id="解题思路-8"><a href="#解题思路-8" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li><p>快速幂算法</p><ul><li>算法复杂度 O（logN）</li><li>暴力计算，需要循环计算n次，每次只乘了一个x，即只完成一步</li><li>而快速幂能够先计算x的低次幂，然后以这些低次幂的乘积，通过相乘来组合最后的乘积</li></ul></li><li><p>二进制角度</p><ul><li><p>x^n次方，比如n为9</p></li><li><p>n的二进制为1001</p></li><li><p>x^5 &#x3D; x^(2^3) * x^(2^0)</p></li><li><p>将原本计算n次，减少到只在二进制位上计算</p></li><li><p>代码实现</p><ul><li>public double myPow(double x, int n) {<br>  if( x &#x3D;&#x3D; 0){<br>  return 0;<br>  }<br>  long p &#x3D; n;<br>  if(n&lt; 0){<br>  x &#x3D; 1 &#x2F; x;<br>  p &#x3D; -p;<br>  }<br>  double result &#x3D; 1;<br>  while(p&gt;0){<br>  if((p&amp;1) &#x3D;&#x3D; 1){<br>  result &#x3D; result<em>x;<br>  }<br>  x &#x3D; x</em>x;<br>  p &#x3D; p &gt;&gt;&gt; 1;<br>  }<br>  return result;</li></ul></li></ul><p>  }</p></li><li><p>二分法角度</p><ul><li><p>思路也是尽可能的复用计算出来的幂次，而且是优先高次</p><ul><li>思路和二进制是一样的，只是角度不同</li></ul></li><li><p>对于 x^n</p></li><li><p>若n位偶数，则等价于 </p><ul><li>result &#x3D; x^(n&#x2F;2)</li><li>result &#x3D; result * result</li></ul></li><li><p>若n为奇数，则等价于</p><ul><li>result  &#x3D; x^(n&#x2F;2)</li><li>result &#x3D; result * result * x</li></ul></li><li><p>不断对n进行二分，直到为0</p><ul><li>result &#x3D; 1</li></ul></li><li><p>算法实现</p><ul><li>private double pow(double x, long n){<br>  if( n &#x3D;&#x3D; 0){<br>  return 1;<br>  }<br>  if( n &#x3D;&#x3D; 1){<br>  return x;<br>  }</li></ul><p>  if( (n&amp;1) &#x3D;&#x3D; 0){<br>      double result &#x3D; pow(x,n&#x2F;2);<br>      return result * result;<br>  }else{<br>      double result &#x3D; pow(x,n&#x2F;2);<br>      return result * result * x;<br>  }</p></li></ul><p>  }</p></li></ul><h2 id="18-删除链表的节点"><a href="#18-删除链表的节点" class="headerlink" title="18. 删除链表的节点"></a>18. 删除链表的节点</h2><h3 id="题目-12"><a href="#题目-12" class="headerlink" title="题目"></a>题目</h3><ul><li>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。</li><li>返回删除后的链表的头节点。</li><li>输入: head &#x3D; [4,5,1,9], val &#x3D; 5</li><li>输出: [4,1,9]</li><li>解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</li></ul><h3 id="解题思路-9"><a href="#解题思路-9" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li><p>方法一：通过前一个节点删除</p><ul><li><p>pre，curr</p></li><li><ol><li>定位节点</li></ol><ul><li>必须从头遍历</li></ul></li><li><ol start="2"><li>删除节点</li></ol><ul><li>pre.next &#x3D; curr.next</li></ul></li></ul></li><li><p>方法二：将后边的节点复制到待删除的节点</p><ul><li>curr.val &#x3D; next.val;</li></ul></li></ul><p>curr.next &#x3D; next.next;<br>    - 前提条件</p><pre><code>    - 1. 待删除的节点不是尾节点，如果是尾节点，只能通过方法一</code></pre><h2 id="17-打印从1到最大的n位数"><a href="#17-打印从1到最大的n位数" class="headerlink" title="17.打印从1到最大的n位数"></a>17.打印从1到最大的n位数</h2><h3 id="题目-13"><a href="#题目-13" class="headerlink" title="题目"></a>题目</h3><ul><li>输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。</li><li>输入: n &#x3D; 1</li><li>输出: [1,2,3,4,5,6,7,8,9]</li></ul><h3 id="解题思路-10"><a href="#解题思路-10" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li><p>常规直接解决</p><ul><li>计算最大值，end &#x3D; Math.pow(10, n)</li><li>for循环，从1到end，打印输出</li><li>简单，高效，但是不是面试官的面视目的</li></ul></li><li><p>用字符串模拟加法</p></li><li><p>回溯+大数</p><ul><li><p>面试官想考察的是大数解决方案</p><ul><li>当n比较大的时候，数值会特别大，用int表示会溢出</li><li>用BigInteger，通过字符串方式来表达</li></ul></li><li><p>其实就是n位的全排列，然后按照顺序输出</p></li><li><p>先固定高位，然后从0-9遍历低位</p></li><li><p>char[] num, loop &#x3D; {‘0’, ‘1’, ‘2’, ‘3’, ‘4’, ‘5’, ‘6’, ‘7’, ‘8’, ‘9’};</p></li></ul></li></ul><p>void dfs(int x) {<br>        if(x &#x3D;&#x3D; n) { &#x2F;&#x2F; 终止条件：已固定完所有位<br>            res.append(String.valueOf(num) + “,”); &#x2F;&#x2F; 拼接 num 并添加至 res 尾部，使用逗号隔开<br>            return;<br>        }<br>        for(char i : loop) { &#x2F;&#x2F; 遍历 ‘0‘ - ’9‘<br>            num[x] &#x3D; i; &#x2F;&#x2F; 固定第 x 位为 i<br>            dfs(x + 1); &#x2F;&#x2F; 开启固定第 x + 1 位<br>        }<br>    }</p><h2 id="20-判断字符串是否是合法数值"><a href="#20-判断字符串是否是合法数值" class="headerlink" title="20. 判断字符串是否是合法数值"></a>20. 判断字符串是否是合法数值</h2><h3 id="题目-14"><a href="#题目-14" class="headerlink" title="题目"></a>题目</h3><ul><li>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”、”5e2”、”-123”、”3.1416”、”0123”都表示数值，但”12e”、”1a3.14”、”1.2.3”、”+-5”、”-1E-16”及”12e+5.4”都不是。</li></ul><h3 id="解题思路-11"><a href="#解题思路-11" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>就是扫描字符串，模式匹配</li></ul><h2 id="21-调整数组顺序使奇数位于偶数前面"><a href="#21-调整数组顺序使奇数位于偶数前面" class="headerlink" title="21. 调整数组顺序使奇数位于偶数前面"></a>21. 调整数组顺序使奇数位于偶数前面</h2><h3 id="题目-15"><a href="#题目-15" class="headerlink" title="题目"></a>题目</h3><ul><li>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。</li><li>输入：nums &#x3D; [1,2,3,4]</li><li>输出：[1,3,2,4] </li><li>注：[3,1,2,4] 也是正确的答案之一。</li></ul><h3 id="解题思路-12"><a href="#解题思路-12" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li><p>思路一：首位指针</p><ul><li><p>left指针从左出发，定位第一个偶数</p></li><li><p>right指针从右边出发，定位第一个奇数</p></li><li><p>交换right 和 left 的内容</p></li><li><p>结束标志： left  &gt; right</p></li><li><p>代码实现</p><ul><li>public int[] exchange(int[] nums) {<br>  int odd &#x3D; 0;<br>  int even &#x3D; nums.length - 1; &#x2F;&#x2F; 收尾指针<br>  while (odd &lt; even) {<br>  if (isEven(nums[odd]) &#x3D;&#x3D; true &amp;&amp; isEven(nums[even]) &#x3D;&#x3D; false) {<br>  &#x2F;&#x2F;exchange<br>  int temp &#x3D; nums[odd];<br>  nums[odd] &#x3D; nums[even];<br>  nums[even] &#x3D; temp;<br>  odd++;<br>  even–;<br>  } else {<br>  if (isEven(nums[even]) &#x3D;&#x3D; true) {<br>      even–;<br>  }<br>  if (isEven(nums[odd]) &#x3D;&#x3D; false) {<br>      odd++;<br>  }<br>  }<br>  }<br>  return nums;</li></ul></li></ul><p>  }</p></li><li><p>思路二：快慢指针</p><ul><li><p>fast指针：泡在前边，寻找第一个奇数</p><ul><li>fast指针之前的全是偶数</li></ul></li><li><p>slow指针：在后边，定位第一个偶数</p></li><li><p>当fast指针找到一个奇数时候，和slow指针定位的偶数交换</p><ul><li>slow++</li><li>fast++</li></ul></li><li><p>边界：fast指针走到最后了</p></li><li><p>特殊情况：起始时候，有slow &#x3D;&#x3D; fast 时候，说明slow位置的是奇数，需要slow++</p></li><li><p>代码实现</p><ul><li>public int[] exchange(int[] nums) {<br>  int fast &#x3D; 0;<br>  int slow &#x3D; 0;<br>  while (fast &lt; nums.length) {<br>  if (isEven(nums[fast]) &#x3D;&#x3D; false) { &#x2F;&#x2F; 寻找奇数<br>  &#x2F;&#x2F; fast之前，全是偶数，或则吧fast&#x3D;&#x3D;slow<br>  if (slow &lt; fast) { &#x2F;&#x2F; 说明slow处是偶数，如果fast &#x3D;&#x3D; slow，则都是奇数<br>      int temp &#x3D; nums[fast];<br>      nums[fast] &#x3D; nums[slow];<br>      nums[slow] &#x3D; temp;<br>  }<br>  slow++; &#x2F;&#x2F; 移动到下一个待交换的偶数<br>  }<br>  fast++;<br>  }</li></ul><p>  return nums;</p></li></ul><p>  }</p></li></ul><h2 id="22-输出链表中倒数第k个节点"><a href="#22-输出链表中倒数第k个节点" class="headerlink" title="22. 输出链表中倒数第k个节点"></a>22. 输出链表中倒数第k个节点</h2><h3 id="题目-16"><a href="#题目-16" class="headerlink" title="题目"></a>题目</h3><ul><li><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。</p></li><li><p>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k &#x3D; 2.</p></li><li><p>返回链表 4-&gt;5.</p></li></ul><h3 id="解题思路-13"><a href="#解题思路-13" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li><p>双指针</p><ul><li>curr &#x3D; head</li><li>result &#x3D; head</li></ul></li><li><p>curr 指针先提前走k步</p></li><li><p>result 在k步之后，再从head出发</p></li><li><p>代码实现</p><ul><li>public ListNode getKthFromEnd(ListNode head, int k) {<br>  ListNode curr &#x3D; head;<br>  ListNode result &#x3D; head;<br>  while(curr !&#x3D; null){<br>  curr &#x3D; curr.next;<br>  if(k &gt; 0){ &#x2F;&#x2F; 晚k步再出发<br>      k–;<br>  }else{<br>      result &#x3D; result.next;<br>  }<br>  }<br>  return result;<br>  }</li></ul></li></ul><h2 id="23-反转链表"><a href="#23-反转链表" class="headerlink" title="23.反转链表"></a>23.反转链表</h2><h3 id="题目-17"><a href="#题目-17" class="headerlink" title="题目"></a>题目</h3><ul><li>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</li><li>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</li><li>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</li></ul><h3 id="解题思路-14"><a href="#解题思路-14" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li><p>双指针法</p><ul><li><p>result指针，构建新链表</p><ul><li>初始为null</li></ul></li><li><p>node 指针，记录原始剩余链表的首节点</p></li><li><p>while(head !&#x3D; null){<br>  node &#x3D; head;<br>  head &#x3D; head.next;<br>  node.next &#x3D; result; &#x2F;&#x2F;result 初始为null<br>  result &#x3D; node;</p></li></ul></li></ul><p>}</p><ul><li><p>递归法</p><ul><li><p>链表遍历可以用递归实现的</p></li><li><p>逆序反转也是递归&#x2F;栈的适用场合</p></li><li><p>递归过程</p><ul><li>记录node 的next节点，用于回溯的时候，反向修改</li><li>在复制node的next之后，将node.next设置为null，保障队首变队尾后，next为null</li><li>返回新链表的首节点</li></ul></li><li><p>代码实现</p><ul><li>ListNode reverse(ListNode node){</li></ul></li></ul><p>  if( node &#x3D;&#x3D; null){<br>       return null;<br>  } else if( node.next !&#x3D; null ){<br>      ListNode next &#x3D; node.next;<br>      node.next &#x3D; null;<br>      ListNode result &#x3D; reverse(next);<br>      next.next &#x3D; node;<br>      return result;<br>  } else {<br>      return node;<br>  }</p></li></ul><p>}</p><h2 id="24-链表合并"><a href="#24-链表合并" class="headerlink" title="24. 链表合并"></a>24. 链表合并</h2><h3 id="题目-18"><a href="#题目-18" class="headerlink" title="题目"></a>题目</h3><ul><li>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</li><li>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</li><li>输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</li></ul><h3 id="解题思路-15"><a href="#解题思路-15" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li><p>方法一：伪头节点法</p><ul><li><p>新链表的头节点初始位null，需要判断l1和l2的头节点来选择</p></li><li><p>适用伪头节点能够大大简化这个过程，只要最后的结果返回 result.next 就可以</p></li><li><p>过程</p><ul><li><ol><li>result &#x3D; new Node</li></ol></li><li><ol start="2"><li>while l1 和 l2 都不为null时</li></ol><ul><li>选择小的，插入到result尾巴</li></ul></li><li><ol start="3"><li>将l1 和 l2 中非空的，直接插入到result的尾巴</li></ol></li></ul></li><li><p>代码实现</p><ul><li>public ListNode mergeTwoLists(ListNode l1, ListNode l2) {<br>  &#x2F;&#x2F; new 一个节点，作为占位的头节点，解决头节点选择问题<br>  ListNode result &#x3D; new ListNode(1);<br>  ListNode curr &#x3D; result;<br>  &#x2F;&#x2F; 遍历<br>  while (l1 !&#x3D; null &amp;&amp; l2 !&#x3D; null) {<br>  if (l1.val &lt; l2.val) {<br>  curr.next &#x3D; l1;<br>  l1 &#x3D; l1.next;<br>  } else {<br>  curr.next &#x3D; l2;<br>  l2 &#x3D; l2.next;<br>  }<br>  curr &#x3D; curr.next;<br>  }<br>  &#x2F;&#x2F; 检查剩余的链表，直接插入到链表的结尾<br>  if (l1 &#x3D;&#x3D; null) {<br>  curr.next &#x3D; l2;<br>  } else {<br>  curr.next &#x3D; l1;<br>  }<br>  return result.next;</li></ul></li></ul><p>  }</p></li><li><p>方法二：递归法</p><ul><li><p>l1.next &#x3D; merge( l1.next, l2) </p></li><li><p>l2.next &#x3D; merge( l1, l2.next )</p></li><li><p>代码实现</p><ul><li>private ListNode merge(ListNode l1, ListNode l2) {<br>  if (l1 &#x3D;&#x3D; null) return l2;<br>  if (l2 &#x3D;&#x3D; null) return l1;<br>  if (l1.val &lt; l2.val) {<br>  l1.next &#x3D; merge(l1.next, l2);<br>  return l1;<br>  } else {<br>  l2.next &#x3D; merge(l1, l2.next);<br>  return l2;<br>  }</li></ul></li></ul><p>  }</p></li></ul><h2 id="25-判断树的子结构"><a href="#25-判断树的子结构" class="headerlink" title="25. 判断树的子结构"></a>25. 判断树的子结构</h2><h3 id="题目-19"><a href="#题目-19" class="headerlink" title="题目"></a>题目</h3><ul><li>输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)</li></ul><p>B是A的子结构， 即 A中有出现和B相同的结构和节点值。</p><h3 id="解题思路-16"><a href="#解题思路-16" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li><ol><li>先序遍历A树的每个节点</li></ol><ul><li>if(isSub(A,B)){<br>  return true;</li></ul></li></ul><p>}else{<br>    if(A &#x3D;&#x3D; null) return false;<br>    return df(A.left, B) || df(A.right, B);<br>}<br>    - 对每个节点执行isSub( node, B)</p><ul><li><ol start="2"><li>对A的每个节点，执行判断以该节点为根的树是否包含B树</li></ol><ul><li><p>if  B &#x3D;&#x3D; null  return true;</p><ul><li>B中分支可以为空，部分匹配A树</li></ul></li><li><p>if( A.val ！&#x3D;  B val)  return false</p><ul><li>不相等，排除</li></ul></li><li><p>if A &#x3D;&#x3D; null, B !&#x3D; null return false</p></li><li><p>if( A.val &#x3D;&#x3D; B.val)</p><ul><li>A，B根相同，则继续判断各自的左右子树</li><li>result  &#x3D; isSub( A.left, B.left)</li><li>result &#x3D; iresult &amp;&amp; sSub(A.right, B.right)</li><li>return result</li></ul></li></ul></li></ul><h2 id="26-二叉树镜像"><a href="#26-二叉树镜像" class="headerlink" title="26.二叉树镜像"></a>26.二叉树镜像</h2><h3 id="题目-20"><a href="#题目-20" class="headerlink" title="题目"></a>题目</h3><ul><li>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</li></ul><h3 id="解题思路-17"><a href="#解题思路-17" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li><p>先序遍历</p><ul><li><p>思路很简单，遍历每个节点，交换他的左右节点即可</p></li><li><p>代码实现</p><ul><li>public TreeNode mirrorTree(TreeNode root) {<br>  if(root !&#x3D; null){<br>  TreeNode temp &#x3D; root.left;<br>  root.left &#x3D; root.right;<br>  root.right &#x3D; temp;<br>  mirrorTree(root.left);<br>  mirrorTree(root.right);<br>  }<br>  return root;</li></ul></li></ul><p>  }</p></li><li><p>递归实现</p><ul><li>利用递归的返回值，来实现左右的交换</li><li>更加简介和优雅</li><li><pre><code>public TreeNode mirrorTree(TreeNode root) &#123;</code></pre>  if(root &#x3D;&#x3D; null) return null;<br>  TreeNode temp &#x3D; root.left;<br>  root.left &#x3D; mirrorTree(root.right);<br>  root.right &#x3D; mirrorTree(temp);<br>  return root;<br>  }</li></ul></li></ul><h2 id="28-判断是否是对称二叉树"><a href="#28-判断是否是对称二叉树" class="headerlink" title="28. 判断是否是对称二叉树"></a>28. 判断是否是对称二叉树</h2><h3 id="题目-21"><a href="#题目-21" class="headerlink" title="题目"></a>题目</h3><ul><li>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</li></ul><h3 id="解题思路-18"><a href="#解题思路-18" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li><p>对称二叉树的定义</p><ul><li><p>每个节点的左右节点L和R</p><ul><li>L.val &#x3D; R.val</li><li>L.左子树 和 R.右子树对称</li><li>L.右子树 和 R. 左子树对称</li></ul></li><li><p>子主题 2</p></li></ul></li><li><p>左右子树需要进行比较</p><ul><li>isSymNodes(root.left, root.right)</li></ul></li><li><p>代码实现</p><ul><li>class Solution {<br>  public boolean isSymmetric(TreeNode root) {<br>  if(root &#x3D;&#x3D; null) return true;<br>  return isSymNodes(root.left, root.right);<br>  }</li></ul><p>  private boolean isSymNodes(TreeNode left, TreeNode right){<br>      if(left &#x3D;&#x3D; null &amp;&amp; right &#x3D;&#x3D; null) return true;<br>      if(left &#x3D;&#x3D; null || right &#x3D;&#x3D; null) return false;<br>      if(left.val !&#x3D; right.val)         return false;<br>      return isSymNodes(left.left,right.right) &amp;&amp; isSymNodes(left.right,right.left);<br>  }</p></li></ul><p>}</p><h2 id="29-顺时针打印矩阵"><a href="#29-顺时针打印矩阵" class="headerlink" title="29.顺时针打印矩阵"></a>29.顺时针打印矩阵</h2><h3 id="题目-22"><a href="#题目-22" class="headerlink" title="题目"></a>题目</h3><ul><li>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</li><li>输入：matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]</li><li>输出：[1,2,3,6,9,8,7,4,5]</li></ul><h3 id="解题思路-19"><a href="#解题思路-19" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li><p>方法一：四个哨兵</p><ul><li><p>上下左右边界各一个哨兵</p><ul><li>left &#x3D; 0</li><li>right &#x3D; matrix[0].length -1</li><li>up &#x3D; 0</li><li>down &#x3D; matrix.length -1</li></ul></li><li><p>向右走到头</p><ul><li><p>即，for(i&#x3D;left; i&lt;&#x3D;right; i++)</p><ul><li>result[index++] &#x3D; matrix[up][i]</li></ul></li><li><p>向右走到头后，尝试向下走</p><ul><li><p>up++</p></li><li><p>判断能走吗</p><ul><li>if（up &gt; down） break;</li></ul></li></ul></li><li><p>然后依次向下，向左，向上</p></li></ul></li><li><p>终止条件</p><ul><li>向右前，left  &gt; right</li><li>向下前，up &gt; down</li><li>向左之前，right &lt; left</li><li>向上之前，down &lt; up</li></ul></li><li><p>代码实现</p><ul><li><p>while(true){</p><p>  &#x2F;&#x2F; 向左走<br>  for(int i &#x3D; left; i&lt;&#x3D;right;i++){<br>  result[index++] &#x3D; matrix[up][i];<br>  }</p><p>  up++; &#x2F;&#x2F; 上限下移<br>  if(up &gt; down)break;<br>  &#x2F;&#x2F; 向下走<br>  for (int i &#x3D; up;i&lt;&#x3D;down;i++){<br>  result[index++] &#x3D; matrix[i][right];<br>  }</p><p>  right–;<br>  if(right &lt; left) break;<br>  &#x2F;&#x2F; 向左走<br>  for (int i&#x3D; right; i&gt;&#x3D;left;i–){<br>  result[index++] &#x3D; matrix[down][i];<br>  }</p><p>  down++;<br>  if(down&lt;up)break;<br>  &#x2F;&#x2F; 向上走<br>  for (int i &#x3D; down; i &gt;&#x3D; up ; i–) {<br>  result[index++] &#x3D; matrix[i][left];<br>  }</p><p>  left++;<br>  if(left &gt; right)break;</p></li></ul><p>  }</p></li></ul></li><li><p>方法二：数圈层</p><ul><li><p>顺时针其实是在沿边缘向内部绕圈</p></li><li><p>count 标记边界距离外边界的偏移</p><ul><li>初始count&#x3D;0</li><li>均能访问到矩阵边界</li></ul></li><li><p>每次完成向上操作之后，count++，增加一个距离边界的距离</p></li><li><p>终止条件</p><ul><li>向右之前，j &gt;&#x3D; width - count</li><li>向下之前,i &gt;&#x3D; height -count</li><li>向左之前，j &lt; count</li><li>向上之前，i &lt; count</li></ul></li><li><p>代码实现</p><ul><li>while (true) {<br>  if (j &gt;&#x3D; width - count) break; &#x2F;&#x2F; 判断向右还有路不<br>  &#x2F;&#x2F; 向右走<br>  while (j &lt; width - count) {<br>  result[index] &#x3D; matrix[i][j];<br>  index++;<br>  j++;<br>  }<br>  j–; &#x2F;&#x2F; 走过了，回退一步<br>  i++; &#x2F;&#x2F; 尝试向下走一格<br>  if (i &gt;&#x3D; height - count) break; &#x2F;&#x2F; 判断尝试走的一格是否可以<br>  &#x2F;&#x2F; 向下走<br>  while (i &lt; height - count) {<br>  result[index] &#x3D; matrix[i][j];<br>  index++;<br>  i++;<br>  }<br>  i–; &#x2F;&#x2F; 走过了，回退以步<br>  j–;<br>  if (j &lt; count) break;<br>  while (j &gt;&#x3D; count) {<br>  result[index] &#x3D; matrix[i][j];<br>  index++;<br>  j–;<br>  }<br>  j++;<br>  count++;<br>  i–;<br>  if (i &lt; count) break;<br>  while (i &gt;&#x3D; count) {<br>  result[index] &#x3D; matrix[i][j];<br>  index++;<br>  i–;<br>  }<br>  i++;<br>  j++;<br>  }</li></ul></li></ul></li></ul><h2 id="30-具有min函数的栈"><a href="#30-具有min函数的栈" class="headerlink" title="30.具有min函数的栈"></a>30.具有min函数的栈</h2><h3 id="题目-23"><a href="#题目-23" class="headerlink" title="题目"></a>题目</h3><ul><li><p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p></li><li><p>注意，min方法只需要获取最小值，不需要最小值出栈</p></li></ul><h3 id="解题思路-20"><a href="#解题思路-20" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li><p>思路一：将最小值记录在栈中</p><ul><li><p>int min，记录当前的最小值</p></li><li><p>push(x)</p><ul><li><p>if x &lt;&#x3D; min</p><ul><li><p>注意，是&lt;&#x3D;，等于min时候也要将min压栈</p></li><li><p>将旧的min值，压入栈中</p><ul><li>push(min)</li></ul></li><li><p>更新min值</p><ul><li>min &#x3D; x</li></ul></li><li><p>再压入值</p><ul><li>push(x)</li></ul></li></ul></li><li><p>if x &gt; min</p><ul><li><p>最小值没变，直接压栈</p><ul><li>push(x)</li></ul></li></ul></li></ul></li><li><p>pop</p><ul><li><p>if pop().equls( min ) </p><ul><li><p>说明最小值出栈了，min需要更新了</p></li><li><p>pop()第一次，获取结果</p></li><li><p>pop()第二次，获取剩余元素的min</p><ul><li>min &#x3D; pop</li></ul></li></ul></li><li><p>if pop() !&#x3D; min</p><ul><li>直接pop返回即可</li></ul></li></ul></li><li><p>min</p><ul><li>返回 min的值即可</li></ul></li><li><p>代码实现</p><ul><li><pre><code>private Stack&lt;Integer&gt; stack;</code></pre></li></ul></li></ul><p>  private int min &#x3D; Integer.MAX_VALUE;<br>  public SingleStackSolution() {<br>      stack &#x3D; new Stack&lt;&gt;();<br>  }<br>  public void push(int x) {<br>      if (x &lt;&#x3D; min) { &#x2F;&#x2F; 最小值需要更新<br>          stack.push(min);<br>          min &#x3D; x;<br>      }<br>      stack.push(x);<br>  }<br>  public void pop() {<br>      if (stack.pop().equals(min)) {<br>          min &#x3D; stack.pop(); &#x2F;&#x2F; 最小值出栈了，更新最小值<br>      }<br>  }<br>  public int top() {<br>      return stack.peek();<br>  }<br>  public int min() {<br>      return min;<br>  }</p></li><li><p>思路二：辅助栈实现</p><ul><li><p>与思路一实际是一样的，只是把最小值记录在了辅助栈中</p></li><li><p>stack，正常的栈</p></li><li><p>helpStack，记录最小值的栈</p></li><li><p>push(x)</p><ul><li>当 helpStack为空，或者x比helpStack栈顶的元素 &lt; &#x3D;时，将x同时也压入到helpStack栈中</li><li>否则，x只压入stack中</li></ul></li><li><p>pop(x)</p><ul><li><p>如果stack的栈顶元素与helpStack的栈顶元素相同</p><ul><li>在stack.pop的同时</li><li>helpStack.pop</li></ul></li><li><p>不同，则只pop stack的栈顶</p></li></ul></li><li><p>min()</p><ul><li>返回helpStack的栈顶元素</li></ul></li><li><p>代码实现</p><ul><li><pre><code>public void push(int x) &#123;</code></pre></li></ul><p>  if (minStack.isEmpty() || x &lt;&#x3D; minStack.peek()) {<br>      minStack.push(x);<br>  }<br>  stack.push(x);</p></li></ul><p>  }<br>  public void pop() {<br>      if (minStack.peek().equals(stack.pop())) {<br>          minStack.pop();<br>      }<br>  }<br>  public int top() {<br>      return stack.peek();<br>  }<br>  public int min() {<br>      return minStack.peek();<br>  }</p></li><li><p>思路三：链表实现，Node中记录min</p><ul><li>其实思路一样，只是实现不同</li></ul></li></ul><h2 id="31-栈的压入与弹出序列匹配"><a href="#31-栈的压入与弹出序列匹配" class="headerlink" title="31.栈的压入与弹出序列匹配"></a>31.栈的压入与弹出序列匹配</h2><h3 id="题目-24"><a href="#题目-24" class="headerlink" title="题目"></a>题目</h3><ul><li><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。</p></li><li><p>输入：pushed &#x3D; [1,2,3,4,5], popped &#x3D; [4,5,3,2,1]</p></li><li><p>输出：true</p></li></ul><h3 id="解题思路-21"><a href="#解题思路-21" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li><p>将pushed中的元素依次压入栈中</p></li><li><p>每次压入后，判断栈顶元素和 poped 中元素是否相等</p><ul><li><p>相等</p><ul><li><p>则pop栈顶元素</p></li><li><p>popped后移到下一个元素</p></li><li><p>pop之后，再循环判断栈顶元素和新的popped元素是否相等</p><ul><li>相等，继续pop</li><li>不相等，退出循环，继续将pushed元素压入栈中</li></ul></li></ul></li><li><p>不相等</p><ul><li>继续向栈中压入pushed的下一个元素</li></ul></li></ul></li><li><p>最终，pushed元素全部入栈退出循环后，检查stack是否为空，如果空，则合法</p></li><li><p>代码实现</p><ul><li>private Stack<Integer> stack;<br>  public boolean validateStackSequences(int[] pushed, int[] popped) {<br> stack &#x3D; new Stack&lt;&gt;();<br>  int j &#x3D; 0; &#x2F;&#x2F; popped数组的当前下标<br>  for (int i &#x3D; 0; i &lt; pushed.length; i++) {<br>  stack.push(pushed[i]); &#x2F;&#x2F; 入栈<br>  for (; j &lt; popped.length; j++) {<br>      if (!stack.isEmpty() &amp;&amp; stack.peek().equals(popped[j])) {<br>          &#x2F;&#x2F; 如果与栈顶相等，则pop<br>          stack.pop();<br>      } else {<br>          break; &#x2F;&#x2F; 否则，继续push元素<br>      }<br>  }<br>  }<br>  return stack.isEmpty();&#x2F;&#x2F;最终栈为空，则ok</li></ul><p>  }</p></li></ul><h2 id="32-二叉树的分层遍历"><a href="#32-二叉树的分层遍历" class="headerlink" title="32. 二叉树的分层遍历"></a>32. 二叉树的分层遍历</h2><h3 id="题目-25"><a href="#题目-25" class="headerlink" title="题目"></a>题目</h3><ul><li>基础：二叉树的层序遍历</li><li>拓展1：每个层单独输出</li><li>拓展2：奇偶层逆向输出</li></ul><h3 id="解题思路-22"><a href="#解题思路-22" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li><p>基础分层遍历</p><ul><li><p>BFS，通过队列解决</p><ul><li><p>原理思路</p><ul><li>将元素按层依次加入到队列中</li><li>然后再在队列中遍历每个元素，将他们的下层的元素再依次添加到队列中</li><li>最终的访问顺序就是分层访问的效果</li></ul></li><li><p>过程</p><ul><li><p>初始将root加入到队列中</p></li><li><p>循环处理队列中的元素，直到队列元素为空</p><ul><li><ol><li>取队列首元素，node</li></ol></li><li><ol start="2"><li>输出node.val</li></ol></li><li><ol start="3"><li>如果左节点非空，则将左节点加入队列</li></ol></li><li><ol start="4"><li>如果右节点非空，则将右节点加入队列</li></ol></li><li>循环往复</li></ul></li></ul></li><li><p>代码实现</p><ul><li>public int[] levelOrder(TreeNode root) {</li></ul></li></ul><p>  if(root &#x3D;&#x3D; null) return new int[0];<br>  LinkedList<TreeNode> queue &#x3D; new LinkedList&lt;&gt;();<br>  ArrayList<Integer> result &#x3D; new ArrayList&lt;&gt;();<br>  queue.addLast(root); &#x2F;&#x2F; 默认将root加入<br>  while(!queue.isEmpty()){<br>      TreeNode node &#x3D; queue.pollFirst();<br>      result.add(node.val);<br>      if(node.left !&#x3D;null){<br>          queue.addLast(node.left); &#x2F;&#x2F; 将左子树加入<br>      }<br>      if(node.right !&#x3D; null){<br>          queue.addLast(node.right); &#x2F;&#x2F; 将右子树加入<br>      }<br>  }<br>  return result;</p></li></ul><p>  }</p><ul><li>其他方法不是很好搞定</li></ul></li><li><p>拓展1，每层单独输出</p><ul><li><p>BFS</p><ul><li><p>基础还是基于BFS来遍历</p></li><li><p>对每一层，从队列首取元素进行技术，该层遍历结束了，则进入下一层</p></li><li><p>代码实现</p><ul><li>while (!queue.isEmpty()) {<br>  int size &#x3D; queue.size();<br>  List<Integer> values &#x3D; new ArrayList&lt;&gt;();<br>  for (int i &#x3D; 0; i &lt; size; i++) {<br>  TreeNode node &#x3D; queue.poll();<br>  values.add(node.val);<br>  if (node.left !&#x3D; null) queue.add(node.left);<br>  if (node.right !&#x3D; null) queue.add(node.right);<br>  }<br>  result.add(values);</li></ul></li></ul><p>  }</p></li><li><p>DFS</p><ul><li><p>在先序遍历的时候，带上遍历的深度即可</p></li><li><p>代码实现</p><ul><li>private void dfs(TreeNode root, int depth){</li></ul></li></ul><p>  if(root &#x3D;&#x3D; null) return;</p><p>  if(depth &gt;&#x3D; res.size()){ &#x2F;&#x2F; 第一次遍历到该层<br>      res.add(new ArrayList&lt;&gt;());<br>  }<br>  res.get(depth).add(root.val);</p><p>  dfs(root.left,depth+1);<br>  dfs(root.right,depth+1);</p></li></ul><p>  }</p></li><li><p>拓展2，奇偶层逆序输出</p><ul><li><p>每一层的遍历结果暂存在一个双端队列中</p><ul><li>奇数层，addFirst</li><li>偶数层，addLast</li></ul></li><li><p>BFS</p><ul><li><p>代码实现</p><ul><li>while (!queue.isEmpty()) {<br>  int size &#x3D; queue.size();<br>  LinkedList<Integer> values &#x3D; new LinkedList&lt;&gt;();<br>  for (int i &#x3D; 0; i &lt; size; i++) {<br>  TreeNode node &#x3D; queue.poll();<br>  if((result.size()&amp;1) &#x3D;&#x3D; 0){<br>  values.addLast(node.val);<br>  }else {<br>  values.addFirst(node.val);<br>  }<br>  if (node.left !&#x3D; null) queue.add(node.left);<br>  if (node.right !&#x3D; null) queue.add(node.right);<br>  }<br>  result.add(values);</li></ul></li></ul><p>  }</p></li><li><p>DFS</p><ul><li><pre><code>private void dfs(TreeNode root, int depth)&#123;</code></pre></li></ul><p>  if(root &#x3D;&#x3D; null) return;<br>  if(depth &gt;&#x3D; res.size()) res.add(new LinkedList&lt;&gt;());<br>  LinkedList<Integer> nodes &#x3D; (LinkedList<Integer>) res.get(depth);<br>  if((depth&amp;1) &#x3D;&#x3D; 1) nodes.addFirst(root.val);<br>  else nodes.addLast(root.val);<br>  dfs(root.left,depth+1);<br>  dfs(root.right,depth+1);</p></li></ul><p>  }<br>      - 错误的写法</p><pre><code>      - 并不是只要交换左右子树的顺序就满足逆序了      - 因为交换了左右子树的顺序，会造成子树的子树顺序也乱了      -  if((depth&amp;1) == 1)&#123;      dfs(root.left,depth+1);      dfs(root.right,depth+1);  &#125;else&#123;      dfs(root.right,depth+1);      dfs(root.left,depth+1);  &#125;</code></pre></li></ul><h2 id="33-二叉搜索树的后序遍历序列"><a href="#33-二叉搜索树的后序遍历序列" class="headerlink" title="33.二叉搜索树的后序遍历序列"></a>33.二叉搜索树的后序遍历序列</h2><h3 id="题目-26"><a href="#题目-26" class="headerlink" title="题目"></a>题目</h3><ul><li>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。</li></ul><h3 id="解题思路-23"><a href="#解题思路-23" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li><p>递归思路</p><ul><li><p>后续遍历的组成： 【左子树，右子树，根】</p></li><li><p>从左向右遍历，第一个比根大的节点，便能找到左右子树的分界</p><ul><li><p>【i，j】</p><ul><li>m为第一个值大于 j 的位置</li><li>左子树：【i,m-1】</li><li>右子树：【m，j-1】</li><li>根：j</li></ul></li></ul></li><li><p>判断是否满足后序遍历的条件</p><ul><li><p>左子树节点值都小于根</p><ul><li>这个遍历找m肯定的</li></ul></li><li><p>右子树节点值都大于根</p><ul><li>这个需要继续遍历判断</li></ul></li></ul></li><li><p>递归三要素</p><ul><li><p>Base Case</p><ul><li>i &#x3D; j，则只有一个节点，为true</li><li>i &gt; j，区间为空，为true</li></ul></li><li><p>拆解</p><ul><li><p>左子树满足后序遍历吗</p><ul><li>recur(seq, i, m-1)</li></ul></li><li><p>右子树满足后序遍历吗</p><ul><li>recur(seq, m, j-1)</li></ul></li></ul></li><li><p>组合</p><ul><li>return 当前满足 &amp;&amp; recur(左子树) &amp;&amp; recur（右子树）</li></ul></li></ul></li><li><p>代码实现</p><ul><li>private boolean recur(int[] postorder, int i, int j) {<br>  if (i &gt;&#x3D; j) return true;<br>  int m &#x3D; i;&#x2F;&#x2F; 找到左右子树的分界点<br>  while (postorder[m] &lt; postorder[j]) {<br>  m++;<br>  }<br>  boolean result &#x3D; true;<br>  for (int k &#x3D; m; k &lt; j - 1; k++) {<br>  if (postorder[k] &lt; postorder[j]) {<br>  result &#x3D; false;<br>  break;<br>  }<br>  }<br>  return result &amp;&amp; recur(postorder, i, m - 1) &amp;&amp; recur(postorder, m, j - 1);</li></ul></li></ul><p>  }</p></li><li><p>单调栈思路</p><ul><li>还没搞懂</li></ul></li></ul><h2 id="34-二叉树中和为指定长的路径"><a href="#34-二叉树中和为指定长的路径" class="headerlink" title="34. 二叉树中和为指定长的路径"></a>34. 二叉树中和为指定长的路径</h2><h3 id="题目-27"><a href="#题目-27" class="headerlink" title="题目"></a>题目</h3><ul><li>输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。</li></ul><h3 id="解题思路-24"><a href="#解题思路-24" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li><p>基于先序遍历，在遍历过程中，记录路径和长度</p></li><li><p>当到达叶子节点，判断是否等于指定值</p></li><li><p>难点在于代码实现和细节处理</p></li><li><p>路径通过一个共享的path List来存储</p><ul><li>在回溯完一个节点之后，将当前节点从path中移除</li></ul></li><li><p>代码实现</p><ul><li>private List&lt;List<Integer>&gt; result;<br>  private LinkedList<Integer> path;<br>  public List&lt;List<Integer>&gt;<br>  private void df(TreeNode root,int target){<br>  if(root &#x3D;&#x3D; null){<br>  return;<br>  }<br>  path.add(root.val);<br>  target -&#x3D; root.val;<br>  if(root.left &#x3D;&#x3D; null &amp;&amp; root.right&#x3D;&#x3D;null){<br>  if(target &#x3D;&#x3D; 0) result.add(new ArrayList&lt;&gt;(path));<br>  return;<br>  }<br>  df(root.left,target);<br>  df(root.right,target);<br>  path.removeLast();<br>  }</li></ul></li></ul><h2 id="35-复杂链表的复制"><a href="#35-复杂链表的复制" class="headerlink" title="35.复杂链表的复制"></a>35.复杂链表的复制</h2><h3 id="题目-28"><a href="#题目-28" class="headerlink" title="题目"></a>题目</h3><ul><li>请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。</li></ul><h3 id="解题思路-25"><a href="#解题思路-25" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li><p>方法一：HashMap</p><ul><li><p>HashMap&lt;Node, Node&gt;</p><ul><li>实现源节点和复制节点的映射</li><li>在设置random指针时，基于原节点查找复制节点</li></ul></li><li><p>两次循环</p><ul><li>第一次循环，沿着next方向遍历，创建新的节点，并将节点对应关系存储到HashMap中</li><li>第二次循环，遍历设置每个新节点的random指针</li></ul></li><li><p>代码实现</p><ul><li>public Node copyRandomList(Node head) {<br>  HashMap&lt;Node,Node&gt; hashMap &#x3D; new HashMap&lt;&gt;();<br>  hashMap.put(null,null);<br>  Node curr &#x3D; head;<br>  while (curr !&#x3D; null){<br>  hashMap.put(curr,new Node(curr.val));<br>  curr &#x3D; curr.next;<br>  }<br>  curr &#x3D; head;<br>  while (curr!&#x3D; null){<br>  hashMap.get(curr).next &#x3D; hashMap.get(curr.next);<br>  hashMap.get(curr).random &#x3D; hashMap.get(curr.random);<br>  curr &#x3D; curr.next;<br>  }<br>  return hashMap.get(head);</li></ul></li></ul><p>  }</p></li><li><p>方法二：一个链表</p><ul><li><p>3次循环</p><ul><li><p>第一次循环，在每个节点之后插入一个复制节点</p><ul><li>复制节点在每个原节点的后继</li><li>不需要使用HashMap来映射了</li></ul></li><li><p>第二次循环，更新复制节点的random指针</p><ul><li>把原节点的ramdom.next赋值给复制节点的random</li></ul></li><li><p>第三次循环，拆分成两个链表</p></li></ul></li><li><p>代码实现</p><ul><li>public Node copyRandomList(Node head) {<br>  &#x2F;&#x2F; 拷贝节点，放在每个原节点的下一个节点<br>  Node find &#x3D; head;<br>  while (find!&#x3D;null){<br>  Node cloneNode &#x3D; new Node(find.val);<br>  cloneNode.next &#x3D; find.next;<br>  find.next &#x3D; cloneNode;<br>  find &#x3D; cloneNode.next;<br>  }<br>  &#x2F;&#x2F; 整理随机指针<br>  find &#x3D; head;<br>  while (find !&#x3D; null){<br>  if(find.random &#x3D;&#x3D; null){<br>  find.next.random &#x3D; null;<br>  }else{<br>  find.next.random &#x3D; find.random.next;<br>  }<br>  find &#x3D; find.next.next;<br>  }<br>  &#x2F;&#x2F; 拆分链表<br>  Node result &#x3D; new Node(0); &#x2F;&#x2F; 哨兵<br>  Node curr &#x3D; result;<br>  find&#x3D;head;<br>  while (find !&#x3D; null){<br>  Node cloneNode &#x3D; find.next;<br>  curr.next &#x3D; cloneNode;<br>  find.next &#x3D; cloneNode.next;<br>  find &#x3D; find.next;<br>  curr &#x3D; curr.next;<br>  }<br>  return result.next;</li></ul></li></ul><p>  }</p><ul><li><p>复杂度</p><ul><li>空间O(1)</li><li>时间O(n)</li></ul></li></ul></li><li><p>方法三：当作图的DFS和BFS</p><ul><li><p>对原始的复杂链表按照图的方式进行DFS或者BFS遍历</p></li><li><p>也是需要使用HashMap来进行源节点和复制节点之间的映射</p></li><li><p>代码实现</p><ul><li>private Node dfs(Node head) {<br>  if (head &#x3D;&#x3D; null) return null;<br>  if (nodes.get(head) &#x3D;&#x3D; null) { &#x2F;&#x2F; 未复制过<br>  Node cloneNode &#x3D; new Node(head.val);<br>  nodes.put(head, cloneNode);<br>  cloneNode.next &#x3D; dfs(head.next);<br>  cloneNode.random &#x3D; dfs(head.random);<br>  return cloneNode;<br>  } else {<br>  return nodes.get(head);<br>  }</li></ul></li></ul><p>  }</p></li></ul><h2 id="36-二叉搜索树与双向链表"><a href="#36-二叉搜索树与双向链表" class="headerlink" title="36.二叉搜索树与双向链表"></a>36.二叉搜索树与双向链表</h2><h3 id="题目-29"><a href="#题目-29" class="headerlink" title="题目"></a>题目</h3><ul><li>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。</li></ul><h3 id="解题思路-26"><a href="#解题思路-26" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li><p>方法一：中序遍历思路</p><ul><li><p>对二叉搜索树进行中序遍历，输出的结果是增序排序的</p></li><li><p>所以可以在中序遍历的过程中构造双向链表</p></li><li><p>最终将双向链表组织成循环链表</p></li><li><p>代码实现</p><ul><li>private Node head &#x3D; new Node(1);</li></ul></li></ul><p>  private Node curr &#x3D; head;<br>  public Node treeToDoublyList(Node root) {<br>      if(root &#x3D;&#x3D; null) return null;<br>      inorder(root);<br>      curr.right &#x3D; head.right;<br>      head &#x3D; head.right;<br>      head.left &#x3D; curr;<br>      return head;<br>  }</p><p>  private void inorder(Node root){<br>      if(root &#x3D;&#x3D; null) return;<br>      inorder(root.left);<br>      &#x2F;&#x2F; 修改节点指针<br>      curr.right &#x3D; root;<br>      root.left &#x3D; curr;<br>      curr &#x3D; curr.right;<br>      inorder(root.right);<br>  }</p></li><li><p>方法二：递归思路</p><ul><li><p>递归三要素</p><ul><li><p>BaseCase</p><ul><li>root为null，则返回null</li></ul></li><li><p>拆解</p><ul><li>Node leftHead &#x3D; recur(root.left)</li><li>Node rightHead &#x3D; recur(root.right)</li></ul></li><li><p>组合</p><ul><li>将左子树循环链表、右子树循环链表、以及root节点组织成一个循环链表</li></ul></li></ul></li><li><p>代码实现</p><ul><li><p>public Node treeToDoublyList(Node root) {<br>  if (root &#x3D;&#x3D; null) return null;<br>  Node leftHead &#x3D; treeToDoublyList(root.left);<br>  Node rightHead &#x3D; treeToDoublyList(root.right);<br>  if (leftHead &#x3D;&#x3D; null &amp;&amp; rightHead &#x3D;&#x3D; null) {<br>  root.left &#x3D; root;<br>  root.right &#x3D; root;<br>  return root;<br>  } else if (leftHead &#x3D;&#x3D; null) {<br>  root.right &#x3D; rightHead;<br>  root.left &#x3D; rightHead.left;<br>  rightHead.left.right &#x3D; root;<br>  rightHead.left &#x3D; root;<br>  return root;<br>  } else if (rightHead &#x3D;&#x3D; null) {<br>  root.left &#x3D; leftHead.left;<br>  root.right &#x3D; leftHead;<br>  leftHead.left.right &#x3D; root;<br>  leftHead.left &#x3D; root;<br>  return leftHead;<br>  } else {<br>  root.left &#x3D; leftHead.left;<br>  root.right &#x3D; rightHead;</p><p>  leftHead.left.right &#x3D; root;<br>  leftHead.left &#x3D; rightHead.left;</p><p>  rightHead.left.right &#x3D; leftHead;<br>  rightHead.left &#x3D; root;<br>  return leftHead;</p></li></ul><p>  }</p></li></ul><p>  }</p></li></ul><h2 id="37-二叉树的序列化和反序列化"><a href="#37-二叉树的序列化和反序列化" class="headerlink" title="37.二叉树的序列化和反序列化"></a>37.二叉树的序列化和反序列化</h2><h3 id="题目-30"><a href="#题目-30" class="headerlink" title="题目"></a>题目</h3><ul><li>请实现两个函数，分别用来序列化和反序列化二叉树。</li><li>序列化为 “[1,2,3,null,null,4,5]”</li></ul><h3 id="二叉树序列化"><a href="#二叉树序列化" class="headerlink" title="二叉树序列化"></a>二叉树序列化</h3><ul><li><p>层序遍历，StringBuilder，字符串输出</p></li><li><p>需要判断什么时候终止输出，因为null也要输出</p></li><li><p>代码实现</p><ul><li>while (!queue.isEmpty()){<br>  int size &#x3D; queue.size();<br>  boolean haxNext &#x3D; false;<br>  for (int i &#x3D; 0; i &lt; size; i++) {<br>      TreeNode node &#x3D; queue.pollFirst();<br>      if(node &#x3D;&#x3D; null){<br>          builder.append(“,null”);<br>      }else{<br>          builder.append(“,”+node.val);<br>          queue.addLast(node.left);<br>          queue.addLast(node.right);<br>          if(node.left !&#x3D; null || node.right!&#x3D;null){<br>              haxNext &#x3D; true;<br>          }<br>      }<br>  }<br>  if(!haxNext)break;<br>  }</li></ul></li></ul><h3 id="二叉树反序列化"><a href="#二叉树反序列化" class="headerlink" title="二叉树反序列化"></a>二叉树反序列化</h3><ul><li><p>输入 String字符串</p><ul><li>从String中解析出节点值数组</li></ul></li><li><p>输出 roo 节点</p></li><li><p>依次遍历节点值</p><ul><li><p>头节点先加入队列</p></li><li><p>队列首读取节点</p><ul><li>读取节点值</li><li>分别设置为左右节点</li></ul></li><li><p>直到节点值数组遍历结束</p></li></ul></li><li><p>代码实现</p><ul><li>TreeNode root &#x3D; new TreeNode(Integer.valueOf(values[0]));<br>  queue.addLast(root);<br>  int index &#x3D; 1;<br>  while (!queue.isEmpty()){<br>  TreeNode node &#x3D; queue.pollFirst();<br>  if(index &lt; values.length){<br>      if(values[index].equals(“null”)){<br>          node.left &#x3D; null;<br>      }else{<br>          node.left &#x3D; new TreeNode(Integer.valueOf(values[index]));<br>          queue.addLast(node.left);<br>      }<br>      index++;<br>  }else break;<br>  if(index &lt; values.length){<br>      if(values[index].equals(“null”)){<br>          node.right &#x3D; null;<br>      }else{<br>          node.right &#x3D; new TreeNode(Integer.valueOf(values[index]));<br>          queue.addLast(node.right);<br>      }<br>      index++;<br>  }else break;<br>  }</li></ul></li></ul><h2 id="38-字符全排列组合"><a href="#38-字符全排列组合" class="headerlink" title="38. 字符全排列组合"></a>38. 字符全排列组合</h2><h3 id="题目-31"><a href="#题目-31" class="headerlink" title="题目"></a>题目</h3><ul><li>输入一个字符串，打印出该字符串中字符的所有排列。</li><li>你可以以任意顺序返回这个字符串数组，但里面不能有重复元素</li><li>输入：s &#x3D; “abc”</li><li>输出：[“abc”,”acb”,”bac”,”bca”,”cab”,”cba”]</li></ul><h3 id="全排列解题思路"><a href="#全排列解题思路" class="headerlink" title="全排列解题思路"></a>全排列解题思路</h3><ul><li><p>DFS解决全排列问题的解题过程</p><ul><li><ol><li>先画出全排列问题的递归树</li></ol><ul><li>是一个隐形树</li><li>节点如何生成：在剩余字符中选择</li><li>结果位置：结果在叶子节点生成，结果值为path路径</li></ul></li><li><ol start="2"><li>设计递归树的状态参数，决定递归方法参数</li></ol></li><li><ol start="3"><li>通过 DFS 来对递归树进行遍历</li></ol><ul><li><p>注意，是对一个隐身树进行遍历</p><ul><li>如何实现对隐身树的遍历</li></ul></li><li><p>回溯：在最后记得恢复现场</p></li></ul></li><li><ol start="4"><li>能否剪枝</li></ol><ul><li>剪枝条件是什么</li></ul></li></ul></li><li><p>转化输入</p><ul><li>字符串不好处理</li><li>s.toCharArray()，转化为字符数组</li></ul></li><li><p>DFS + 回溯 + 剪枝</p><ul><li><p>values &#x3D; char []</p><ul><li>输入的字符数组</li></ul></li><li><p>result &#x3D; new ArrayList<String>()</p><ul><li>记录结果</li></ul></li><li><p>path &#x3D; new LinkedList<Charactor>()</p><ul><li>记录DFS过程中的路径，也是用于生成最终的排列</li></ul></li><li><p>used &#x3D; boolean [ ]</p><ul><li>标记该字符是否已经被选在在path里了，在则不能选了</li></ul></li><li><p>dfs(int depth)</p><ul><li><p>参数depth代表目前在哪一个位置选择字符，同时也是递归树的深度</p></li><li><p>当 depth  &#x3D; values.length</p><ul><li><p>说明完成一次排列，到达叶子节点</p></li><li><p>path内容添加到result</p><ul><li>注意，需要拷贝path，而不是直接添加</li></ul></li></ul></li><li><p>否则，从剩余字符中选择一个，for循环，把每个可能都尝试以下</p><ul><li><p>避免重复剪枝</p><ul><li>通过Set来解决</li><li>将尝试过的字符都加入到set中</li><li>尝试下一个字符时，如果发现字符再set中已存在，则说明重复了，跳过这个字符，剪枝</li></ul></li><li><p>if used[i] &#x3D;&#x3D; true  continue;</p></li></ul></li><li><p>选择一个字符之后，DFS 进入下一层</p><ul><li>path.add(values[i])</li><li>used[i] &#x3D; true;</li><li>dfs( depth + 1 )</li></ul></li><li><p>回溯恢复现场</p><ul><li>path.removeLast();</li><li>used[i] &#x3D; false;</li><li>该位置这个尝试完了，换下一个再DFS</li></ul></li></ul></li><li><p>最终结果</p><ul><li>return result.toArray(new String(result.size()))</li></ul></li><li><p>复杂度</p><ul><li>时间 O( N * N！)</li><li>空间 O（N * N！）</li></ul></li><li><p>代码实现</p><ul><li>private void dfs(int depth){<br>  if(depth &#x3D;&#x3D; values.length){<br>  result.add(path.toString());<br>  return;<br>  }<br>  HashSet<Character> set &#x3D; new HashSet&lt;&gt;();<br>  for(int i &#x3D; 0; i&lt;values.length;i++){<br>  if(!used[i] &amp;&amp; !set.contains(values[i])){ &#x2F;&#x2F; 标记是否在path中<br>  used[i] &#x3D; true;<br>  set.add(values[i]);<br>  path.append(values[i]);<br>  dfs(depth +1);<br>  path.deleteCharAt(depth);<br>  used[i] &#x3D; false;<br>  }<br>  }</li></ul></li></ul><p>  }</p></li><li><p>DFS + 交换 + 剪枝</p><ul><li><p>values &#x3D; char []</p><ul><li>输入的字符数组</li></ul></li><li><p>result &#x3D; new ArrayList<String>()</p><ul><li>记录结果</li></ul></li><li><p>不需要 used，path等辅助</p></li><li><p>dfs(int depth)</p><ul><li><p>当 depth  &#x3D; values.length</p><ul><li>将value内容添加到result</li><li>而之前是将path添加到result</li></ul></li><li><p>否则，从剩余字符中选择一个，for循环，把每个可能都尝试以下</p><ul><li><p>避免重复剪枝</p><ul><li>通过Set来解决</li><li>与之前算法一样</li></ul></li><li><p>for 循环只在depth之后位置进行，并且通过交换来实现尝试选择不同得值</p></li></ul></li><li><p>选择一个字符之后，DFS 进入下一层</p><ul><li><p>set.add(values[i])</p></li><li><p>swap( values, depth, i )</p><ul><li>交换将i位置的值拿来尝试</li></ul></li><li><p>dfs( depth + 1 )</p></li></ul></li><li><p>回溯恢复现场</p><ul><li><p>swap( values, depth, i)</p><ul><li>回溯再交换回来</li></ul></li><li><p>该位置这个尝试完了，换下一个再DFS</p></li></ul></li></ul></li><li><p>代码实现</p><ul><li>private void dfs(int depth) {<br>  &#x2F;&#x2F; 问题的解在path上，在叶子节点结束<br>  if (depth &#x3D;&#x3D; values.length) {<br>  &#x2F;&#x2F; 将values数组中的字符串存到结果中<br>  result.add(new String(values));<br>  return;<br>  }<br>  &#x2F;&#x2F; 记录当前位置是否和之前的某次重复<br>  Set<Character> set &#x3D; new HashSet&lt;&gt;();<br>  &#x2F;&#x2F; for循环是分支的生成，从剩余的选择一个<br>  for (int i &#x3D; depth; i &lt; values.length; i++) {<br>  &#x2F;&#x2F; 未重复，则继续。该字符试过了，则剪枝<br>  if (!set.contains(values[i])) {<br>  set.add(values[i]); &#x2F;&#x2F; 将尝试字符加入set<br>  &#x2F;&#x2F; 交换位置<br>  char temp &#x3D; values[depth];<br>  values[depth] &#x3D; values[i];<br>  values[i] &#x3D; temp;<br>  dfs(depth + 1);<br>  &#x2F;&#x2F; 回溯交换回来<br>  temp &#x3D; values[depth];<br>  values[depth] &#x3D; values[i];<br>  values[i] &#x3D; temp;<br>  }<br>  }</li></ul></li></ul><p>  }</p></li></ul><h2 id="39-（众数）数组中出现次数超过一半的数字"><a href="#39-（众数）数组中出现次数超过一半的数字" class="headerlink" title="39. （众数）数组中出现次数超过一半的数字"></a>39. （众数）数组中出现次数超过一半的数字</h2><h3 id="题目-32"><a href="#题目-32" class="headerlink" title="题目"></a>题目</h3><ul><li><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。</p></li><li><p>你可以假设数组是非空的，并且给定的数组总是存在多数元素</p></li><li><p>输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]</p></li><li><p>输出: 2</p></li></ul><h3 id="解题思路-27"><a href="#解题思路-27" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li><p>排序取中间位置</p><ul><li>复杂度O（NlogN）</li></ul></li><li><p>HashMap 频率统计</p><ul><li>hashMap &#x3D; new HashMap&lt;Integer, Integer&gt;</li><li>将每个数字出现的频率映射到hashMap</li><li>当出现频率超过一半的，返回</li></ul></li><li><p>摩尔投票法</p><ul><li><p>特别适用于查找众数 </p></li><li><p>人海战术</p><ul><li><p>众数代表我方 + 1，非众数代表敌方  -1，结果vote为两方势力</p><ul><li>两方单兵相遇实力抵消 ，主要拼数量</li></ul></li><li><p>两方同归于尽之后 vote &#x3D;&#x3D; 0 </p><ul><li>之前的都不算了</li><li>重新指定众数兵，再PK</li></ul></li><li><p>最终要么剩下一个众数，要么多个众数</p><ul><li>最后一次指定的一定属于众数</li><li>因为如果是非众数，肯定会被后边的众数抵消掉</li></ul></li></ul></li><li><p>思路</p><ul><li><p>初始态</p><ul><li>vote &#x3D; 0</li><li>halfNum &#x3D; array[0]</li></ul></li><li><p>遍历array</p><ul><li><p>如果 array[i] &#x3D;&#x3D; halfNum</p><ul><li>vote++</li></ul></li><li><p>否则</p><ul><li>vote–</li></ul></li><li><p>如果 vote &#x3D;&#x3D; 0 </p><ul><li>更新 halfNum &#x3D; array[i]</li></ul></li></ul></li><li><p>最终，return halfNum</p></li></ul></li><li><p>代码实现</p><ul><li>public int majorityElement(int[] nums) {<br>  int halfNum &#x3D; 0;<br>  int vote &#x3D; 0; &#x2F;&#x2F; 初始假设第一个是众数<br>  for (int i &#x3D; 0; i &lt; nums.length; i++) {<br>  if(vote &#x3D;&#x3D; 0){ &#x2F;&#x2F;抵消<br>  halfNum &#x3D; nums[i];<br>  }<br>  if(nums[i] &#x3D;&#x3D; halfNum){<br>  vote++;<br>  }else{<br>  vote–;<br>  }<br>  }<br>  return halfNum;</li></ul></li></ul><p>  }</p></li></ul><h2 id="40-最小的前K个数（TOPK问题）"><a href="#40-最小的前K个数（TOPK问题）" class="headerlink" title="40. 最小的前K个数（TOPK问题）"></a>40. 最小的前K个数（TOPK问题）</h2><h3 id="题目-33"><a href="#题目-33" class="headerlink" title="题目"></a>题目</h3><ul><li>输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</li><li>输入：arr &#x3D; [3,2,1], k &#x3D; 2</li><li>输出：[1,2] 或者 [2,1]</li></ul><h3 id="解题思路-28"><a href="#解题思路-28" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li><p>思路一：二叉堆</p><ul><li><p>思路</p><ul><li><p>Java中的PriorityQueue，内部基于最小堆实现</p></li><li><p>但实际要使用最大堆，即将前K小数的最大的放在根</p><ul><li>传入Comparator，重写compare</li><li>注意 PriorityQueue是最小堆实现，所以数值小的优先级高</li><li>public int compare(Integer o1, Integer o2) {</li></ul></li></ul></li></ul><p>&#x2F;&#x2F; PriorityQueue为最小堆，值小的优先级高<br>              return -(o1 - o2);</p></li></ul><p> }</p><pre><code>- 过程    - 1. 初始化将K个元素加入二叉堆中    - 2. 遍历剩余的元素，如果比堆顶小，则替换堆顶    - 3. 遍历结束，堆中存储的就是前K小- 代码实现    - for (int i = 0; i &lt; k; i++) &#123;        queue.add(arr[i]);    &#125;    for (int i = k; i &lt;arr.length ; i++) &#123;        if(arr[i] &lt; queue.peek())&#123;            // 替换最小值中的最大的            queue.poll();            queue.add(arr[i]);        &#125;    &#125;</code></pre><ul><li><p>思路二：类快速排序的快速查找</p><ul><li><p>快速排序中，每次partition都能确定基准值的位置</p><ul><li>左边的比基准值小</li><li>右边的比基准值大</li></ul></li><li><p>我们只要确定K位置的基准值就可以了，这样K左边的都比自己小</p></li><li><p>改造快排算法</p><ul><li>if(middle &#x3D;&#x3D; k) return</li><li>最终返回结果的前K项</li></ul></li><li><p>复杂度 O（N）</p></li></ul></li><li><p>思路三：排序，取前K</p><ul><li>O（NlogN）</li></ul></li></ul><h2 id="42-连续子数组的最大和问题"><a href="#42-连续子数组的最大和问题" class="headerlink" title="42.连续子数组的最大和问题"></a>42.连续子数组的最大和问题</h2><h3 id="题目-34"><a href="#题目-34" class="headerlink" title="题目"></a>题目</h3><ul><li><p>输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p></li><li><p>要求时间复杂度为O(n)。</p></li><li><p>输入: nums &#x3D; [-2,1,-3,4,-1,2,1,-5,4]</p></li><li><p>输出: 6</p><ul><li>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</li></ul></li></ul><h3 id="解题思路-29"><a href="#解题思路-29" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li><p>动态规划</p><ul><li><p>dp[i] 表示到 i 位置截至的最大和</p></li><li><p>递推方程</p><ul><li>如果 dp[ i-1 ] &gt; 0，则 dp[i] &#x3D; num[i] + dp[i-1]</li><li>如果 dp[ i-1 ] &lt;&#x3D; 0，则dp[i] &#x3D; num[i]</li></ul></li><li><p>由于只需要使用到前后两个dp的值，所以可以通过两个变量替代dp数组</p></li><li><p>代码实现</p><ul><li>public int maxSubArray(int[] nums) {<br>  if(nums.length &#x3D;&#x3D; 0)return 0;<br>  int dpPre &#x3D; nums[0];<br>  int dpCur &#x3D; nums[0];<br>  int maxSub &#x3D; dpCur;<br>  for (int i &#x3D; 1; i &lt;nums.length; i++) {<br>  if(dpPre &gt; 0){<br>  dpCur &#x3D; dpPre + nums[i];<br>  }else{<br>  dpCur &#x3D; nums[i];<br>  }<br>  dpPre &#x3D; dpCur;<br>  if(dpCur &gt; maxSub) maxSub &#x3D; dpCur;<br>  }<br>  return maxSub;</li></ul></li></ul><p>  }</p><ul><li>复杂度 O(N)</li></ul></li><li><p>分治法</p><ul><li><p>不断对数组进行二分，取左，右，中最大的</p></li><li><p>递归实现分治</p><ul><li><p>递归方法 int recur(int [] nums，int start，int end)</p></li><li><p>BaseCase</p><ul><li>start &gt;&#x3D; end，return nums[start];</li></ul></li><li><p>拆解</p><ul><li><p>int left &#x3D; recur(nums, start, middle -1)</p><ul><li>左边的最大和</li></ul></li><li><p>int right &#x3D; recur(nums, middle+1, end)</p><ul><li>右边的最大和</li></ul></li><li><p>横跨中点的最大和</p><ul><li>计算左边以middle为后缀的最大和</li><li>计算右边以middle为起始的最大和</li><li>计算整个的最大和</li></ul></li></ul></li><li><p>组合</p><ul><li>从 left、right 以及横跨中点的最大和中选择最大的</li></ul></li></ul></li><li><p>代码实现</p><ul><li>private int recur(int[] nums, int start, int end) {<br>  if (start &gt;&#x3D; end) {<br>  return nums[start];<br>  }<br>  &#x2F;&#x2F; 中间位置<br>  int middle &#x3D; (start + end) &#x2F; 2;</li></ul><p>  int left &#x3D; recur(nums, start, middle-1);<br>  int right &#x3D; recur(nums, middle + 1, end);</p><p>  int leftSub &#x3D; 0, maxLeftSub &#x3D; 0, rightSub &#x3D; 0, maxRightSub &#x3D; 0;<br>  for (int i &#x3D; middle - 1; i &gt;&#x3D; start; i–) {<br>      leftSub +&#x3D; nums[i];<br>      maxLeftSub &#x3D; Math.max(leftSub,maxLeftSub);<br>  }<br>  for (int i &#x3D; middle + 1; i &lt;&#x3D; end; i++) {<br>      rightSub +&#x3D; nums[i];<br>      maxRightSub &#x3D; Math.max(rightSub,maxRightSub);<br>  }<br>  int middleSub &#x3D; nums[middle];<br>  if (maxLeftSub &gt; 0) middleSub +&#x3D; maxLeftSub;<br>  if (maxRightSub &gt; 0) middleSub +&#x3D; maxRightSub;<br>  return Math.max(Math.max(left, right), middleSub);</p></li></ul><p>  }</p></li></ul><h2 id="43-1～n整数中1出现的次数"><a href="#43-1～n整数中1出现的次数" class="headerlink" title="43.1～n整数中1出现的次数"></a>43.1～n整数中1出现的次数</h2><h3 id="题目-35"><a href="#题目-35" class="headerlink" title="题目"></a>题目</h3><ul><li>输入一个整数 n ，求1～n这n个整数的十进制表示中1出现的次数。</li><li>例如，输入12，1～12这些整数中包含1 的数字有1、10、11和12，1一共出现了5次。</li></ul><h3 id="解题思路-30"><a href="#解题思路-30" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li><p>递归法</p><ul><li><p>BaseCase</p><p>  - </p></li><li><p>拆解</p><ul><li><p>设定</p><ul><li>最高位 high</li><li>余下值 last</li><li>power，对应最高位上10的幂次</li></ul></li><li><p>recur(last)</p></li></ul></li><li><p>组合</p><ul><li><p>如果high &#x3D;&#x3D; 1</p><ul><li><p>比如1222</p><ul><li>high&#x3D;1</li><li>power&#x3D;1000</li><li>last &#x3D; 222</li></ul></li><li><p>result</p><ul><li><p>recur( power-1 )</p><ul><li>high 为0 的时候，0-999中1的个数</li></ul></li><li><p>recur(last)</p><ul><li>high为1时，last部分1的个数</li></ul></li><li><p>last +1</p><ul><li>high为1时，最高位上1的个数</li></ul></li></ul></li></ul></li><li><p>如果high &gt; 1</p><ul><li><p>比如 2333</p><ul><li>high&#x3D;2</li><li>power &#x3D; 1000</li><li>last &#x3D; 333</li></ul></li><li><p>result</p><ul><li><p>high * recur( power -1)</p><ul><li>hight 为0,1，第三位0-999中1的个数</li></ul></li><li><p>power</p><ul><li>最高位为1的个数，即high取1</li></ul></li><li><p>last + 1</p><ul><li>high整后，零头last中1的个数</li></ul></li></ul></li></ul></li></ul></li><li><p>代码实现</p><ul><li>public int countDigitOne(int n) {<br>  if(n &#x3D;&#x3D; 0) return 0;<br>  String num &#x3D; String.valueOf(n);<br>  int high &#x3D; num.charAt(0) - ‘0’;<br>  int highPow &#x3D; (int)Math.pow(10,num.length()-1);<br>  int last &#x3D; n - high * highPow;<br>  if(high&#x3D;&#x3D; 1){<br>  return countDigitOne(highPow-1) &#x2F;&#x2F; high位取0的<br>      + last +1 &#x2F;&#x2F; high位取1，high位上的1个数<br>      + countDigitOne(last); &#x2F;&#x2F; high取1，last中的1个数</li></ul><p>  }else{<br>      return high * countDigitOne(highPow-1) &#x2F;&#x2F; 0 - high-1 ，低位中1的个数<br>              + highPow &#x2F;&#x2F; high以1开头的<br>              + countDigitOne(last); &#x2F;&#x2F; high为最大时候，余下的last有多少个1<br>  }</p></li></ul><p>  }</p><ul><li><p>复杂度</p><ul><li>O(log10N)</li></ul></li></ul></li><li><p>按位统计</p><ul><li><p>分为3个部分</p><ul><li><p>high curr last</p><ul><li>curr，当前位上的值</li><li>high，高位数字组成的值</li><li>last，低位数字组成的值</li></ul></li><li><p>123456</p><ul><li>如果curr &#x3D;&#x3D; 4</li><li>high &#x3D; 123</li><li>last &#x3D; 56</li></ul></li></ul></li><li><p>统计过程</p><ul><li><p>遍历n的每一位 curr</p></li><li><p>设定</p><ul><li>digit 为高位对应的10的幂</li><li>比如上边的digit &#x3D; 1000</li></ul></li><li><p>如果curr &#x3D;&#x3D; 0</p><ul><li>该位上1的个数，high*digit</li><li>即 100 - 123100</li></ul></li><li><p>如果curr &#x3D;&#x3D; 1</p><ul><li>high*digit + last + 1</li><li>在上边的基础上，多一个last+1的零头</li></ul></li><li><p>如果curr &gt; 1</p><ul><li>（high+1）*digit</li><li>整体的high*digit个，还多出一个</li></ul></li></ul></li><li><p>代码实现</p><ul><li>public int countDigitOneNew(int n) {<br>  int digit &#x3D; 1, res &#x3D; 0;<br>  int high &#x3D; n &#x2F; 10, cur &#x3D; n % 10, low &#x3D; 0;<br>  while(high !&#x3D; 0 || cur !&#x3D; 0) {<br>  if(cur &#x3D;&#x3D; 0) res +&#x3D; high * digit;<br>  else if(cur &#x3D;&#x3D; 1) res +&#x3D; high * digit + low + 1;<br>  else res +&#x3D; (high + 1) * digit;<br>  low +&#x3D; cur * digit;<br>  cur &#x3D; high % 10;<br>  high &#x2F;&#x3D; 10;<br>  digit *&#x3D; 10;<br>  }<br>  return res;</li></ul></li></ul><p>  }</p><ul><li><p>复杂度</p><ul><li>O(N)</li></ul></li></ul></li></ul><h2 id="44-数字序列中某一位的数字"><a href="#44-数字序列中某一位的数字" class="headerlink" title="44.  数字序列中某一位的数字"></a>44.  数字序列中某一位的数字</h2><h3 id="题目-36"><a href="#题目-36" class="headerlink" title="题目"></a>题目</h3><ul><li>数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。</li><li>输入：n &#x3D; 11</li><li>输出：0</li></ul><h3 id="解题思路-31"><a href="#解题思路-31" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li><p>数字序列可以组成一棵树</p><ul><li><p>第一层为 0</p><ul><li>1</li></ul></li><li><p>第二层为 1-9</p><ul><li>9x1x1</li></ul></li><li><p>第三层为 第二层每个节点末尾添加 0-9</p><ul><li>9x10x2</li></ul></li><li><p>9x100x3</p></li><li><p>9x digit x i</p><ul><li>digit：10的位数次</li><li>i：几位数</li></ul></li></ul></li><li><p>过程</p><ul><li><ol><li>定位到在树的哪一层</li></ol><ul><li>循环减去 9<em>digit</em>i</li></ul></li><li><ol start="2"><li>定位到该层的哪一个位置</li></ol><ul><li>digit + (n-1) &#x2F; i</li></ul></li><li><ol start="3"><li>定位到数字的位上的数字</li></ol><ul><li>offset &#x3D; (n-1) % i</li></ul></li></ul></li><li><p>代码实现</p><ul><li>public int findNthDigit(int n) {<br>  int i &#x3D; 1;<br>  long digit &#x3D; 1;<br>  while (n &gt; 9<em>digit</em>i){<br>  n -&#x3D; 9<em>digit</em>i;<br>  i++;<br>  digit *&#x3D; 10;<br>  }<br>  int last &#x3D; (n-1) &#x2F; i;<br>  int offset &#x3D; (n-1) % i;<br>  long num &#x3D; digit + last;<br>  String numStr &#x3D; Long.toString(num);<br>  return numStr.charAt(offset)-‘0’;<br>  }</li></ul></li><li><p>复杂度</p><ul><li>O（log10N）</li></ul></li></ul><h2 id="45-把数组排成最小的数"><a href="#45-把数组排成最小的数" class="headerlink" title="45.把数组排成最小的数"></a>45.把数组排成最小的数</h2><h3 id="题目-37"><a href="#题目-37" class="headerlink" title="题目"></a>题目</h3><ul><li>输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个</li><li>输入: [10,2]</li><li>输出: “102”</li></ul><h3 id="解题思路-32"><a href="#解题思路-32" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li><p>定义数字大小比较</p><ul><li>x + y &gt; y + x，则 x &gt; y</li><li>其中加法为字符串加法</li></ul></li><li><p>所以，只要基于此对数组按照规则进行排序就可以</p><ul><li>基于快速排序</li></ul></li><li><p>最终按升序输出即可</p></li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><ul><li>public String minNumber(int[] nums) {<br>  String[] values &#x3D; new String[nums.length];<br>  for (int i &#x3D; 0; i &lt; nums.length; i++) {<br>      values[i] &#x3D; String.valueOf(nums[i]);<br>  }<br>  fastSort(values, 0, values.length - 1);<br>  StringBuilder builder &#x3D; new StringBuilder();<br>  for (String str : values) {<br>      builder.append(str);<br>  }<br>  return builder.toString();<br>  }</li></ul><h2 id="46-把数字翻译成字符串"><a href="#46-把数字翻译成字符串" class="headerlink" title="46. 把数字翻译成字符串"></a>46. 把数字翻译成字符串</h2><h3 id="题目-38"><a href="#题目-38" class="headerlink" title="题目"></a>题目</h3><ul><li><p>给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p></li><li><p>输入: 12258</p></li><li><p>输出: 5</p><ul><li>解释: 12258有5种不同的翻译，分别是”bccfi”, “bwfi”, “bczi”, “mcfi”和”mzi”</li></ul></li></ul><h3 id="解题思路-33"><a href="#解题思路-33" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li><p>方法一：回溯算法</p><ul><li><ol><li>划出递归树</li></ol><ul><li>树的分支为下一个字符的选择问题</li><li>有一个分支或者两个分支</li></ul></li><li><ol start="2"><li>状态变量</li></ol><ul><li>left，即当前还有多少个数字字符没翻译</li></ul></li><li><ol start="3"><li>剪枝条件</li></ol><ul><li>如果数值是0，3…9，则肯定无法和后一个元素组合</li><li>如果数值是2，但后一个数 &gt; 5，也无法组合</li></ul></li><li><ol start="4"><li>dfs过程</li></ol><ul><li>private void dfs(int left){<br>  if(left &#x3D;&#x3D; 0){ &#x2F;&#x2F; 数字使用完，count++<br>  count++;<br>  return;<br>  }<br>  dfs(left-1); &#x2F;&#x2F; 用一个数字来翻译<br>  int len &#x3D; value.length();<br>  if(left &gt; 1){ &#x2F;&#x2F; 用两个数字来翻译，需要满足10-25的条件<br>  if(value.charAt(len-left) &#x3D;&#x3D; ‘1’<br>      || value.charAt(len-left) &#x3D;&#x3D; ‘2’ &amp;&amp; value.charAt(len-left + 1) &lt; ‘6’){<br>  dfs(left-2);<br>  }<br>  }</li></ul></li></ul><p>  }</p></li><li><p>方法二：动态规划</p><ul><li><ol><li>递推方程</li></ol><ul><li><p>dp[i]，表示以 i 位置数字结尾的翻译有多少种</p></li><li><p>dp[i]</p><ul><li>dp[ i-1 ]，当 i 无法和 i-1 进行组合</li><li>dp [ i-1] + dp[ i-2 ] ，当 i 可以和 i-1 进行组合</li></ul></li></ul></li><li><ol start="2"><li>代码实现</li></ol><ul><li>int preDP &#x3D; 1;<br>  int currDP &#x3D; 1;<br>  for(int i &#x3D; 1; i&lt;value.length(); i++){<br>  if(value.charAt(i-1) &#x3D;&#x3D; ‘1’<br>      || value.charAt(i-1) &#x3D;&#x3D; ‘2’ &amp;&amp; value.charAt(i)&lt;’6’){<br>  int temp &#x3D; currDP;<br>  currDP &#x3D; currDP + preDP;<br>  preDP &#x3D; temp;<br>  }else{<br>  preDP &#x3D; currDP;<br>  currDP &#x3D; currDP;<br>  }<br>  }<br>  return currDP;</li></ul></li></ul></li></ul><h2 id="47-礼物的最大价值"><a href="#47-礼物的最大价值" class="headerlink" title="47.礼物的最大价值"></a>47.礼物的最大价值</h2><h3 id="题目-39"><a href="#题目-39" class="headerlink" title="题目"></a>题目</h3><ul><li>在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？</li></ul><h3 id="解题思路-34"><a href="#解题思路-34" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li><p>动态规划</p><ul><li><p>这是典型的动态规划的题目变形</p></li><li><p>定义 dp</p><ul><li>dp[i][j] 表示到达该位置的最大价值 </li><li>这里比较只会用到左边和上边的元素，所以一个一维数组也可以搞定， 即dp[i]</li></ul></li><li><p>递推方程</p><ul><li><p>dp[ i ][ j ] &#x3D; dp[ i ][ j-1 ] + grid[ i ][ j ]</p><ul><li>当左边比上边大</li></ul></li><li><p>dp[ i ][ j ] &#x3D; dp[ i-1 ][ j ]  + grid[ i ][ j ]</p><ul><li>当上边比左边大</li></ul></li></ul></li><li><p>代码实现</p><ul><li>public int maxValue(int[][] grid) {<br>  if(grid.length &#x3D;&#x3D; 0 || grid[0].length &#x3D;&#x3D; 0) return 0;<br>  int [] dp &#x3D; new int[grid[0].length];<br>  dp[0] &#x3D; grid[0][0];<br>  for (int i &#x3D; 1; i &lt; grid[0].length; i++) {<br>  dp[i] &#x3D; dp[i-1]+grid[0][i];<br>  }<br>  for (int i &#x3D; 1; i &lt; grid.length; i++) {<br>  for (int j &#x3D; 0; j &lt; grid[0].length; j++) {<br>  if(j-1 &lt;0){<br>      dp[j] &#x3D; dp[j] + grid[i][j];<br>  }else {<br>      if(dp[j-1] &gt; dp[j]){<br>          dp[j] &#x3D; dp[j-1] + grid[i][j];<br>      }else{<br>          dp[j] &#x3D; dp[j]+grid[i][j];<br>      }<br>  }<br>  }<br>  }<br>  return dp[grid[0].length-1];</li></ul></li></ul><p>  }</p><ul><li><p>评估</p><ul><li>时间复杂度 O(M*N)</li><li>空间复杂度O（M）</li></ul></li></ul></li><li><p>DFS + 备忘录</p><ul><li><p>从起点到终点是一个DFS遍历的过程</p></li><li><p>分支生成规则</p><ul><li>可以向下、向右</li><li>右边缘和下边缘只能有一个方向，即一个分支</li></ul></li><li><p>剪枝规则</p><ul><li>备忘录记录各个点已经计算的最大价值</li><li>当再此来到这个位置时候，计算最大值，并与已有最大值比较，若小，则直接剪枝</li></ul></li><li><p>代码实现</p><ul><li>private void dfs(int i, int j, int value) {<br>  if (i &#x3D;&#x3D; M - 1 &amp;&amp; j &#x3D;&#x3D; N - 1) {<br>  if (value &gt; maxValue) {<br>  maxValue &#x3D; value;<br>  return;<br>  }<br>  }else if(i &#x3D;&#x3D; M-1){<br>  dfs(i,j+1,value + grid[i][j+1]);<br>  }else if(j &#x3D;&#x3D; N-1){<br>  dfs(i+1,j,value+grid[i+1][j]);<br>  }else{<br>  dfs(i,j+1,value + grid[i][j+1]);<br>  dfs(i+1,j,value+grid[i+1][j]);<br>  }</li></ul></li></ul><p>  }</p><ul><li><p>评估</p><ul><li>时间复杂度O( 2^(M+N))</li></ul></li></ul></li></ul><h2 id="48-最长不含重复字符的子字符串"><a href="#48-最长不含重复字符的子字符串" class="headerlink" title="48.最长不含重复字符的子字符串"></a>48.最长不含重复字符的子字符串</h2><h3 id="题目-40"><a href="#题目-40" class="headerlink" title="题目"></a>题目</h3><ul><li>请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。</li><li>输入: “abcabcbb”</li><li>输出: 3 </li><li>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</li></ul><h3 id="解题思路-35"><a href="#解题思路-35" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li><p>方法一：滑动窗口 + HashSet</p><ul><li><p>思路</p><ul><li><p>滑动窗口指定当前的子序列范围</p><ul><li>i，左边缘</li><li>j，右边缘</li></ul></li><li><p>通过HashSet记录子序列中是否有该元素，判定是否存在重复字符</p></li></ul></li><li><p>过程</p><ul><li><ol><li>j 遍历整个字符串，尝试加入到子序列中</li></ol><ul><li>检查hashSet中是否有该字符</li><li>无，则j++</li></ul></li><li><ol start="2"><li>hashSet有重复字符，则定位重复字符的位置，将其之前的字符从set中移除，并右移 i 的位置</li></ol></li><li><ol start="3"><li>用maxLength记录最大的长度</li></ol></li></ul></li><li><p>优化</p><ul><li><ol><li>子序列也可以通过一个队列来保存</li></ol><ul><li>每次检查队列中是否存在该元素</li><li>有，则poll，直到把重复元素移除出来</li></ul></li><li><ol start="2"><li>子序列中重复符号位置的查找</li></ol><ul><li>以上是用遍历的放hi</li><li>也可以通过HashMap直接定位，见方法二</li></ul></li></ul></li><li><p>代码实现</p><ul><li>public int lengthOfLongestSubstring(String s) {<br>  char[] values &#x3D; s.toCharArray();<br>  if (values.length &#x3D;&#x3D; 0) return 0;<br>  HashSet<Character> set &#x3D; new HashSet();<br>  int i &#x3D; 0, j &#x3D; 0;<br>  int maxLength &#x3D; 0;<br>  while (j &lt; values.length) {<br>  if (set.contains(values[j])) {<br>  while (i &lt; j) {<br>      set.remove(values[i]);<br>      if (values[i] &#x3D;&#x3D; values[j]) {<br>          i++;<br>          break;<br>      }<br>      i++;<br>  }<br>  }<br>  set.add(values[j]);<br>  j++;<br>  maxLength &#x3D; Math.max(maxLength, set.size());<br>  }<br>  return maxLength;</li></ul></li></ul><p>  }</p><ul><li><p>评估</p><ul><li><p>时间复杂度 O（N）</p></li><li><p>空间复杂度O(1)</p><ul><li>因为字符的数目是有限的，最多256</li></ul></li></ul></li></ul></li><li><p>方法二：动态规划 + HashMap</p><ul><li><p>思路</p><ul><li><p>HashMap用来保存字符最近一次出现的位置索引</p><ul><li>preIndex</li></ul></li><li><p>递推方程：dp[ i ] &#x3D; </p><ul><li><p>dp [ i-1 ] + 1</p><ul><li><p>当字符第一次出现，即hashMap中无访问记录</p></li><li><p>当字符非第一次出现，但preIndex并不在子序列区间中</p><ul><li>if  i - preIndex  &gt;&#x3D; length</li></ul></li></ul></li><li><p>dp [ i-1 ] - preIndex</p><ul><li><p>当字符非第一次出现，且preIndex在子序列区间中</p><ul><li>if  i - preindex &lt; length</li></ul></li></ul></li></ul></li><li><p>查看递推方程，仅和 dp[ i-1 ]相关，所以可以通过一个变量替代一维数组</p><ul><li>length</li></ul></li></ul></li><li><p>过程</p><ul><li><ol><li>length &#x3D; 0，HashMap&lt;Charactor, Integer&gt;</li></ol></li><li><ol start="2"><li>i &#x3D; 0，开始遍历所有字符</li></ol><ul><li><p>判断 hashMap中是否有该字符的key</p><ul><li>有则说明之前已经访问过，读取该字符的preIndex</li><li>无，第一次访问，将value设置为 i</li></ul></li></ul></li><li><ol start="3"><li>如果获取到preIndex</li></ol><ul><li><p>if  i - preIndex &gt;&#x3D; 0</p><ul><li>说明重复字符不在当前子序列中</li><li>length++</li></ul></li><li><p>else</p><ul><li>重复字符在子序列中</li><li>length &#x3D; i - preIndex</li><li>length 发生变更，更新maxLength</li></ul></li></ul></li><li><ol start="4"><li>return maxLength</li></ol></li></ul></li><li><p>代码实现</p><ul><li>public int lengthOfLongestSubstring(String s) {<br>  char [] values &#x3D; s.toCharArray();<br>  if(values.length &#x3D;&#x3D; 0) return 0;<br>  &#x2F;&#x2F; map 记录元素最近一次出现的索引<br>  HashMap&lt;Character,Integer&gt; map &#x3D; new HashMap&lt;&gt;();<br>  int i &#x3D; 0, j &#x3D; 0;<br>  int length &#x3D; 0;<br>  int maxLength &#x3D; 0;<br>  while (j &lt; values.length) {<br>  if(map.containsKey(values[j])){<br>  int leftIndex &#x3D; map.get(values[j]);<br>  if(j - leftIndex &lt;&#x3D; length){<br>      &#x2F;&#x2F; 说明重复字符位于当前子串中<br>      maxLength &#x3D; Math.max(maxLength, length);<br>      length &#x3D; j - leftIndex;<br>  }else{<br>      length++;<br>  }<br>  }else{<br>  length++;<br>  }<br>  map.put(values[j],j);<br>  j++;<br>  }<br>  maxLength &#x3D; Math.max(maxLength, length);<br>  return maxLength;</li></ul></li></ul><p>  }</p><ul><li><p>评估</p><ul><li>时间复杂度 O（N）</li><li>空间复杂度O（1）</li></ul></li></ul></li></ul><h2 id="49-丑数"><a href="#49-丑数" class="headerlink" title="49.丑数"></a>49.丑数</h2><h3 id="题目-41"><a href="#题目-41" class="headerlink" title="题目"></a>题目</h3><ul><li><p>我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。</p></li><li><p>输入: n &#x3D; 10</p></li><li><p>输出: 12</p></li><li><p>解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。</p></li></ul><h3 id="解题思路-36"><a href="#解题思路-36" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li><p>显然用动态规划来递推解题</p></li><li><p>递推方程</p><ul><li><p>dp[ n ] 表示第 n 个丑数</p></li><li><p>dp[ n ] &#x3D;</p><ul><li><p>2 * dp[ i ]</p><ul><li>当为三者中最小值时，当选</li><li>选中之后，i++</li></ul></li><li><p>3 * dp[ j ]</p></li><li><p>5 * dp[ k ]</p></li></ul></li></ul></li><li><p>思路过程</p><ul><li><ol><li>初始化dp[ 0 ] &#x3D; 1，i,j,k &#x3D; 0</li></ol></li><li><ol start="2"><li>从 2<em>dp[i]，3</em>dp[j]，5*dp[k]中选择最小的</li></ol></li><li><ol start="3"><li>比如，选择了 2 * dp[i ]</li></ol><ul><li>则 dp[n] &#x3D; 2 * dp[i]</li><li>n++</li><li>i++</li></ul></li><li><ol start="4"><li>直到第N个丑数</li></ol></li></ul></li><li><p>代码实现</p><ul><li>public int nthUglyNumber(int n) {<br>  int[] dp &#x3D; new int[n];<br>  dp[0] &#x3D; 1;<br>  int i &#x3D; 0, j &#x3D; 0, k &#x3D; 0;<br>  for (int m &#x3D; 1; m &lt; n; m++) {<br>  int next2&#x3D;2<em>dp[i], next3&#x3D;3</em>dp[j], next5&#x3D;5*dp[k];<br>  dp[m] &#x3D; Math.min(next2,Math.min(next3,next5));<br>  if(dp[m] &#x3D;&#x3D; next2) i++;<br>  if(dp[m] &#x3D;&#x3D; next3) j++;<br>  if(dp[m] &#x3D;&#x3D; next5) k++;<br>  }<br>  return dp[n-1];<br>  }</li></ul></li><li><p>评估</p><ul><li>时间复杂度：O(N)</li><li>空间复杂度：O(N)</li></ul></li></ul><h2 id="50-第一个只出现一次的字符"><a href="#50-第一个只出现一次的字符" class="headerlink" title="50.第一个只出现一次的字符"></a>50.第一个只出现一次的字符</h2><h3 id="题目-42"><a href="#题目-42" class="headerlink" title="题目"></a>题目</h3><ul><li>在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。</li><li>s &#x3D; “abaccdeff”</li><li>返回 “b”</li></ul><h3 id="解题思路-37"><a href="#解题思路-37" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li><p>HashMap的使用</p><ul><li><p>第一轮遍历：统计各个字符出现的个数</p></li><li><p>第二轮遍历：遍历字符串每个字符，如果该字符频率为1，则作为第一个返回</p></li><li><p>改进：HashMap&lt;Charactor, Boolean&gt;</p><ul><li>value使用布尔，减小存储</li><li>第一次出现将value设置为false</li><li>第二次出现将value设置为true</li><li>key不存在表示未出现过</li><li>最终返回第一个value为false的</li></ul></li></ul></li><li><p>评估</p><ul><li>时间复杂度 O(N)</li><li>空间复杂度 O(1)</li></ul></li></ul><h2 id="52-找出两个链表的公共节点"><a href="#52-找出两个链表的公共节点" class="headerlink" title="52. 找出两个链表的公共节点"></a>52. 找出两个链表的公共节点</h2><h3 id="题目-43"><a href="#题目-43" class="headerlink" title="题目"></a>题目</h3><ul><li>输入两个链表，找出它们的第一个公共节点。</li></ul><h3 id="解题思路-38"><a href="#解题思路-38" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li><p>方法1：HashSet</p><ul><li><p>思路</p><ul><li>先遍历第一个链表，将每个链表加入到HashSet中</li><li>然后遍历第二个链表，检查每个节点是否存在于HashSet中，存在则返回</li></ul></li><li><p>代码实现</p><ul><li>public ListNode getIntersectionNode(ListNode headA, ListNode headB) {<br>  HashSet<ListNode> set &#x3D; new HashSet&lt;&gt;();<br>  ListNode result &#x3D; null;<br>  while (headA !&#x3D; null){<br>  set.add(headA);<br>  headA &#x3D; headA.next;<br>  }<br>  while (headB !&#x3D; null){<br>  if(set.contains(headB)){<br>  result &#x3D; headB;<br>  break;<br>  }<br>  headB&#x3D;headB.next;<br>  }<br>  return result;</li></ul></li></ul><p>  }</p><ul><li><p>评估</p><ul><li>时间复杂度：O（N）</li><li>空间复杂度：O(N)</li></ul></li></ul></li><li><p>方法2：双指针二次相遇</p><ul><li><p>思路</p><ul><li><p>双指针同时遍历两个链表，遍历完成后，分别切换到对方链表上再此遍历</p></li><li><p>两个指针一定相遇在第一个公共节点</p><ul><li>因为两个指针路过的系欸但书相同</li></ul></li></ul></li><li><p>这个算法要牢记，是查找链表公共节点的方法</p><ul><li>Java中确定两个类的公共父类便是这样实现的</li></ul></li><li><p>代码实现</p><ul><li>public ListNode getIntersectionNode(ListNode headA, ListNode headB) {<br>  if(headA &#x3D;&#x3D; null || headB &#x3D;&#x3D; null) return null;<br>  ListNode nodeA&#x3D;headA, nodeB &#x3D; headB;<br>  ListNode result &#x3D; null;<br>  int count &#x3D; 0;<br>  while (count &lt; 2){<br>  if(nodeA &#x3D;&#x3D; null){<br>  nodeA &#x3D; headB;<br>  count++;<br>  }<br>  if(nodeB &#x3D;&#x3D; null) nodeB &#x3D; headA;<br>  if(nodeA &#x3D;&#x3D; nodeB) {<br>  result &#x3D; nodeA;<br>  break;<br>  }<br>  nodeA &#x3D; nodeA.next;<br>  nodeB &#x3D; nodeB.next;<br>  }<br>  return result;</li></ul></li></ul><p>  }</p><ul><li><p>评估</p><ul><li>时间复杂度 O(N)</li><li>空间复杂度O(1)</li></ul></li></ul></li></ul><h2 id="53-排序数组中的查找"><a href="#53-排序数组中的查找" class="headerlink" title="53.排序数组中的查找"></a>53.排序数组中的查找</h2><h3 id="数字在排序数组中的次数"><a href="#数字在排序数组中的次数" class="headerlink" title="数字在排序数组中的次数"></a>数字在排序数组中的次数</h3><ul><li><p>题目</p><ul><li>统计一个数字在排序数组中出现的次数。</li><li>输入: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 8</li><li>输出: 2</li></ul></li><li><p>解题思路</p><ul><li><p>很明显，基于二分查找改进</p></li><li><p>int binSearch(int [] nums, int start, int end, int target)</p></li><li><p>二分判断条件</p><ul><li><ol start="3"><li>num[middle] &lt; target</li></ol><ul><li>return 右边查找</li></ul></li><li><ol start="4"><li>num[middle] &gt; target</li></ol><ul><li>return 左边查找</li></ul></li><li><ol start="5"><li>num[middle] &#x3D;&#x3D; target</li></ol><ul><li>return 1+ 左边查找 + 右边查找</li></ul></li></ul></li><li><p>二分终止条件</p><ul><li>start &gt; end，查找区间结束</li></ul></li><li><p>代码实现</p><ul><li>int binSearch(int[] nums, int start, int end, int target) {<br>  if (start &gt; end) return 0;<br>  int middle &#x3D; start + (end - start) &#x2F; 2;<br>  if (nums[middle] &gt; target) {<br>  return binSearch(nums, start, middle - 1, target);<br>  } else if (nums[middle] &lt; target) {<br>  return binSearch(nums, middle + 1, end, target);<br>  } else {<br>  return 1 + binSearch(nums, start, middle - 1, target)<br>      + binSearch(nums, middle + 1, end, target);</li></ul><p>  }</p></li></ul><p>  }</p><ul><li><p>评估</p><ul><li>O(logN)</li></ul></li></ul></li></ul><h3 id="0～n-1中缺失的数字"><a href="#0～n-1中缺失的数字" class="headerlink" title="0～n-1中缺失的数字"></a>0～n-1中缺失的数字</h3><ul><li><p>题目</p><ul><li><p>一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</p></li><li><p>输入: [0,1,3]</p></li><li><p>输出: 2</p></li></ul></li><li><p>解题思路</p><ul><li><p>基于二分查找解决</p><ul><li>int searchMissing(int [] nums, int start, int end)</li></ul></li><li><p>二分判断条件</p><ul><li><p>如果number[middle] &#x3D;&#x3D; middle</p><ul><li>说明左边不缺少元素，查找右边</li><li>start &#x3D; middle +1</li></ul></li><li><p>如果number[middle] &gt; middle</p><ul><li>说明左边缺少元素</li><li>end &#x3D; middle -1</li></ul></li><li><p>如果number[middle] &lt; middle</p><ul><li>不存在的</li></ul></li></ul></li><li><p>二分终止条件</p><ul><li>start &gt; end</li><li>start之前的都是不缺失的，即满足number[middle] &#x3D;&#x3D; middle</li><li>end &lt; start，说明查找结束</li><li>start指向的即为确实元素</li></ul></li><li><p>代码实现</p><ul><li>int binSearchMissingNum(int[] nums, int start, int end) {<br>  if (start &gt; end) return start;<br>  int middle &#x3D; start + (end - start) &#x2F; 2;<br>  if (nums[middle] &#x3D;&#x3D; middle ) {<br>  return binSearchMissingNum(nums, middle + 1, end);<br>  } else {<br>  return binSearchMissingNum(nums, start, middle - 1);<br>  }</li></ul></li></ul><p>  }</p><ul><li><p>评估</p><ul><li>O(logN)</li></ul></li></ul></li></ul><h2 id="54-二叉搜索树的第k大节点"><a href="#54-二叉搜索树的第k大节点" class="headerlink" title="54. 二叉搜索树的第k大节点"></a>54. 二叉搜索树的第k大节点</h2><h3 id="题目-44"><a href="#题目-44" class="headerlink" title="题目"></a>题目</h3><ul><li>给定一棵二叉搜索树，请找出其中第k大的节点。</li></ul><h3 id="解题思路-39"><a href="#解题思路-39" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li><p>二叉搜索树的中序遍历是顺序的</p></li><li><p>第K大元素，就是中序遍历倒序第K个</p></li><li><p>int inOrder( Node root, int k)</p></li><li><p>中序遍历</p><ul><li><p>if(root &#x3D;&#x3D; null) return 0;</p></li><li><p>inOrder(root.right, k)</p></li><li><p>计数+判断是否终结</p><ul><li>count++</li><li>if(count &#x3D;&#x3D; k) return root.val;</li></ul></li><li><p>inOrder(root.left,k)</p></li></ul></li><li><p>难点在遍历提前终止</p><ul><li>要保护返回过程中，结果不会被再此修改</li><li>如何在递归过程中通过返回值传递结果</li></ul></li><li><p>代码实现</p><ul><li><pre><code>private int count =0;</code></pre></li></ul><p>  private int preOrder(TreeNode root, int k){<br>      if(root &#x3D;&#x3D; null) return 0;<br>      int result &#x3D; preOrder(root.right,k);<br>      count++;<br>      if(count &#x3D;&#x3D; k) result &#x3D; root.val;<br>      if(count &gt;&#x3D; k) return result;<br>      return preOrder(root.left,k);<br>  }</p></li></ul><h2 id="55-平衡二叉树"><a href="#55-平衡二叉树" class="headerlink" title="55. 平衡二叉树"></a>55. 平衡二叉树</h2><h3 id="求二叉树的深度"><a href="#求二叉树的深度" class="headerlink" title="求二叉树的深度"></a>求二叉树的深度</h3><ul><li><p>题目</p><ul><li>输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。</li></ul></li><li><p>解题思路</p><ul><li><p>递归，从底向上统计</p></li><li><p>深度 &#x3D; 左右子树深度最大值 + 1</p></li><li><p>代码实现</p><ul><li>public int maxDepth(TreeNode root) {<br>  if(root &#x3D;&#x3D; null) return 0;<br>  int left &#x3D; maxDepth(root.left);<br>  int right &#x3D; maxDepth(root.right);<br>  return Math.max(left,right) + 1;</li></ul></li></ul><p>  }</p><ul><li><p>评估</p><ul><li>O（logN）</li></ul></li></ul></li></ul><h3 id="判断是否是平衡二叉树"><a href="#判断是否是平衡二叉树" class="headerlink" title="判断是否是平衡二叉树"></a>判断是否是平衡二叉树</h3><ul><li><p>题目</p><ul><li>输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。</li><li>boolean isBalanced（Node root）</li></ul></li><li><p>解题思路</p><ul><li><p>AVL定义：左右子树高度差 &lt;&#x3D; 1</p><ul><li>递归定义</li><li>所有子树都要满足</li></ul></li><li><p>思路一：遍历 + 左右深度比较</p><ul><li>遍历每个节点，在每个节点求左右子树的深度，并比较，不满足AVL则直接返回</li><li>代码实现</li><li>评估 O(logN logN)</li></ul></li><li><p>思路二：从底向上判断</p><ul><li><p>融合求深度和遍历过程</p></li><li><p>类似求深度的程序，返回值为</p><ul><li>是AVL，则返回深度</li><li>不是AVL，则返回-1</li></ul></li><li><p>不是-1，则表明是AVL</p></li><li><p>代码实现</p><ul><li>int isBalancedNew(TreeNode root) {</li></ul></li></ul><p>  if (root &#x3D;&#x3D; null) return 0;<br>  int left &#x3D; isBalancedNew(root.left);<br>  int right &#x3D; isBalancedNew(root.right);<br>  if(left &#x3D;&#x3D; -1 || right &#x3D;&#x3D; -1) return -1;<br>  if (Math.abs(left - right) &lt;&#x3D; 1) {<br>      return Math.max(left, right) + 1;<br>  } else {<br>      return -1;<br>  }</p></li></ul><p>  }</p><pre><code>  - 评估      - O(logN)</code></pre></li></ul><h2 id="56-数组中只出现一次的数"><a href="#56-数组中只出现一次的数" class="headerlink" title="56.数组中只出现一次的数"></a>56.数组中只出现一次的数</h2><h3 id="两个数出现一次，其余均出现两次"><a href="#两个数出现一次，其余均出现两次" class="headerlink" title="两个数出现一次，其余均出现两次"></a>两个数出现一次，其余均出现两次</h3><ul><li><p>题目</p><ul><li>一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</li><li>输入：nums &#x3D; [4,1,4,6]</li><li>输出：[1,6] 或 [6,1]</li></ul></li><li><p>解题思路</p><ul><li><p>要求是O(N)和O(1)，所以无法通过hashMap统计频数</p></li><li><p>通过异或，可以求出数组中只出现一次的数</p></li><li><p>分组异或</p><ul><li><p>出现两次的数字异或之后为0，对最终的异或结果没有影响</p></li><li><p>最终异或结果为两个出现一次数字的异或</p></li><li><p>通过异或结果为1的位将数组分为2组</p><ul><li>两个出现一次的数字肯定在不同组</li><li>相同的数字肯定出现在同一组</li></ul></li><li><p>对两个分组分别异或，最后异或结果就是两个出现一次的数</p></li></ul></li><li><p>思路过程</p><ul><li><ol><li>对数组进行异或操作，得到结果M</li></ol></li><li><ol start="2"><li>M即为两个数字的异或结果，获取M最右边的1的位</li></ol><ul><li>mask &#x3D; x &amp; -x</li></ul></li><li><ol start="3"><li>基于mask位将数组分成两组，对两组分别进行异或</li></ol></li></ul></li><li><p>相关位运算</p><ul><li><p>取最右边为1的位</p><ul><li>x &amp; -x</li><li>结果一般作为mask</li></ul></li><li><p>判断对应位为0还是为1</p><ul><li>num &amp; mask &#x3D;&#x3D; 0，则为0</li><li>num &amp; mask &#x3D;&#x3D; mask，则为1</li></ul></li></ul></li><li><p>代码实现</p><ul><li>public int[] singleNumbers(int[] nums) {<br>  int result &#x3D; 0; &#x2F;&#x2F; x ^ 0 &#x3D; x<br>  for (int i &#x3D; 0; i &lt; nums.length; i++) {<br>  result ^&#x3D; nums[i];<br>  }<br>  &#x2F;&#x2F; x ^ -x：结果为右边第一个非0位，比如00001000<br>  int mask &#x3D; result &amp; -result;<br>  int first &#x3D; 0,second&#x3D;0;<br>  for (int i &#x3D; 0; i &lt; nums.length; i++) {<br>  if ((nums[i] &amp; mask) &#x3D;&#x3D; 0) {<br>  first ^&#x3D; nums[i];<br>  } else {<br>  second ^&#x3D; nums[i];<br>  }<br>  }<br>  return new int[]{first,second};</li></ul></li></ul><p>  }</p><ul><li><p>评估</p><ul><li>O(N)，O(1)</li></ul></li></ul></li></ul><h3 id="一个数出现一次，其余均出现3次"><a href="#一个数出现一次，其余均出现3次" class="headerlink" title="一个数出现一次，其余均出现3次"></a>一个数出现一次，其余均出现3次</h3><ul><li><p>题目</p><ul><li>在一个数组 nums 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。</li><li>输入：nums &#x3D; [3,4,3,3]</li><li>输出：4</li></ul></li><li><p>解题思路</p><ul><li><p>由于出现三次，无法通过上题异或方式消除抵消</p></li><li><p>基于位统计的思路</p><ul><li><p>通过所有数各个位上1的个数</p></li><li><p>对各个位的频数进行模三</p><ul><li>整除，则说明多余的数字该位为0</li><li>不能整除，则说明多余的数，该位为1</li></ul></li></ul></li><li><p>代码实现</p><ul><li>用一个 int [32] 数组统计int 各位上 1 的个数</li><li>public int singleNumber(int[] nums) {<br>  int [] bitSum &#x3D; new int[32];<br>  for (int i &#x3D; 0; i &lt; nums.length; i++) {<br>  int mask &#x3D; 1;<br>  for (int j &#x3D; 31; j &gt;&#x3D;0; j–) {<br>  if((nums[i] &amp; mask) !&#x3D; 0) bitSum[j]++;<br>  mask &#x3D; mask &lt;&lt; 1;<br>  }<br>  }<br>  int mask &#x3D; 1,result &#x3D; 0;<br>  for (int i &#x3D; 31; i &gt;&#x3D;0; i–) {<br>  if(bitSum[i] % 3 !&#x3D; 0){<br>  result +&#x3D; mask;<br>  }<br>  mask &#x3D; mask &lt;&lt; 1;<br>  }<br>  return result;</li></ul></li></ul><p>  }</p><ul><li><p>评估</p><ul><li>O(N)</li></ul></li></ul></li></ul><h2 id="57-数组中和为S的序列"><a href="#57-数组中和为S的序列" class="headerlink" title="57.数组中和为S的序列"></a>57.数组中和为S的序列</h2><h3 id="题目一：和为S的两个数"><a href="#题目一：和为S的两个数" class="headerlink" title="题目一：和为S的两个数"></a>题目一：和为S的两个数</h3><ul><li><p>题目</p><ul><li>输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。</li><li>输入：nums &#x3D; [2,7,11,15], target &#x3D; 9</li><li>输出：[2,7] 或者 [7,2]</li></ul></li><li><p>解题思路</p><ul><li><p>二分查找+双指针</p><ul><li>数组是有序数组，很容易想到二分</li><li>首尾双指针迭代检查和是否为S</li></ul></li><li><p>思路与过程</p><ul><li><ol><li>二分查找确定最后一个小于S的数</li></ol><ul><li>因为这两个数肯定比S要小</li><li>使用二分查找的模板二，middle向上取整</li></ul></li><li><p>2.首位双指针迭代检查</p><ul><li><p>i &#x3D; 0; j &#x3D; left；双指针从两端出发，终点为相遇</p></li><li><p>判断 num[ i ] + num[ j ]</p><ul><li><p>等于S</p><ul><li>查找成功，结果返回</li></ul></li><li><p>大于S</p><ul><li>右边的大了，j–</li></ul></li><li><p>小于S</p><ul><li>左边小了，i++</li></ul></li></ul></li></ul></li></ul></li><li><p>代码实现</p><ul><li>public int[] twoSum(int[] nums, int target) {<br>  &#x2F;&#x2F; 基于二分查找第一个小于等于<br>  int left &#x3D; 0, right &#x3D; nums.length-1;<br>  while (left &lt; right){<br>  int middle &#x3D; left + (right - left + 1)&#x2F;2;<br>  if(nums[middle] &gt;&#x3D; target ){<br>  right &#x3D; middle-1;<br>  }else{<br>  left &#x3D; middle;<br>  }<br>  }<br>  int i&#x3D;0, j &#x3D; left;<br>  int [] result &#x3D; new int[0];<br>  while (j &gt; i){<br>  int sum &#x3D; nums[i] + nums[j];<br>  if(sum &#x3D;&#x3D; target){<br>  result &#x3D; new int[]{nums[i],nums[j]};<br>  break;<br>  }else if (sum &lt; target){<br>  i++;<br>  }else {<br>  j–;<br>  }<br>  }<br>  return result;</li></ul></li></ul><p>  }</p><ul><li><p>评估</p><ul><li>O(N)</li></ul></li></ul></li></ul><h3 id="题目二：和为S的连续数"><a href="#题目二：和为S的连续数" class="headerlink" title="题目二：和为S的连续数"></a>题目二：和为S的连续数</h3><ul><li><p>题目</p><ul><li><p>输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。</p></li><li><p>序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。</p></li><li><p>输入：target &#x3D; 9</p></li><li><p>输出：[[2,3,4],[4,5]]</p></li></ul></li><li><p>解题思路</p><ul><li><p>滑动窗口思路</p></li><li><p>过程与思路</p><ul><li><ol><li>i&#x3D;0，j&#x3D;0；初始滑动窗口范围。sum，记录滑动窗口中的和</li></ol></li><li><p>2.循环终点： j &#x3D;&#x3D; target，则查找结束</p></li><li><ol start="3"><li>j 先右移扩展，将更大的数加入到滑动窗口</li></ol><ul><li>j++</li><li>sum +&#x3D; j</li></ul></li><li><ol start="4"><li>检查sum与target</li></ol><ul><li><p>等于</p><ul><li>记录一个结果</li><li>i + 2，左边收缩两个，之后右边继续扩展</li></ul></li><li><p>小于</p><ul><li>需要扩展更大的，j++</li></ul></li><li><p>大于</p><ul><li>需要移除较小的，i++</li></ul></li></ul></li></ul></li><li><p>代码实现</p><ul><li>public int[][] findContinuousSequence(int target) {<br>  ArrayList&lt;int[]&gt; result &#x3D; new ArrayList&lt;&gt;();<br>  int i &#x3D; 1, j &#x3D; 1, sum &#x3D; 1;<br>  while (j &lt; target) {<br>  if (sum &lt; target) {<br>  j++; &#x2F;&#x2F; 右扩展<br>  sum +&#x3D; j;<br>  } else if (sum &gt; target) {<br>  sum -&#x3D; i;<br>  i++; &#x2F;&#x2F; 左收缩<br>  } else {<br>  int[] ans &#x3D; new int[j - i + 1];<br>  for (int k &#x3D; i; k &lt;&#x3D; j; k++) {<br>      ans[k - i] &#x3D; k;<br>  }<br>  result.add(ans);<br>  sum -&#x3D; i + i + 1;<br>  i +&#x3D; 2;<br>  }<br>  }<br>  return result.toArray(new int[result.size()][]);</li></ul></li></ul><p>  }</p><ul><li><p>评估</p><ul><li>O(target)</li></ul></li></ul></li></ul><h2 id="58-旋转字符串"><a href="#58-旋转字符串" class="headerlink" title="58.旋转字符串"></a>58.旋转字符串</h2><h3 id="题目一：翻转单词顺序"><a href="#题目一：翻转单词顺序" class="headerlink" title="题目一：翻转单词顺序"></a>题目一：翻转单词顺序</h3><ul><li><p>题目</p><ul><li><p>输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串”I am a student. “，则输出”student. a am I”。</p></li><li><p>输入: “the sky is blue”</p></li><li><p>输出: “blue is sky the”</p></li></ul></li><li><p>解题思路</p><ul><li><p>思路一：基于栈的逆序</p><ul><li><ol><li>从后向前扫描字符</li></ol></li><li><ol start="2"><li>空格跳过，非空格加入栈，遇到空格终止加入</li></ol></li><li><ol start="3"><li>将栈中元素全部弹出，加入到StringBuilder</li></ol></li><li><ol start="4"><li>builder 插入一个空格</li></ol></li><li><ol start="5"><li>继续循环2操作</li></ol></li></ul></li><li><p>思路二：基于split()方法</p><ul><li><ol><li>使用split将字符串切成单词数组</li></ol></li><li><ol start="2"><li>倒叙遍历数组，将单词加入到builder</li></ol></li></ul></li><li><p>思路三：subString(start, end)</p><ul><li><ol><li>从后向前检索每个单词，i为单词首字符，j为单词尾字符索引</li></ol></li><li><ol start="2"><li>j 前移， 遇到空格跳过，直到遇到非空格字符停下</li></ol></li><li><ol start="3"><li>i 从 j 出发，前移，遇到非空格跳过，直到遇到空格字符</li></ol></li><li><ol start="4"><li>subString(i+1, j+1)即为单词，加入buidler</li></ol></li></ul></li></ul></li></ul><h3 id="题目二：左旋转字符串"><a href="#题目二：左旋转字符串" class="headerlink" title="题目二：左旋转字符串"></a>题目二：左旋转字符串</h3><ul><li><p>题目</p><ul><li>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”。</li></ul></li><li><p>解题思路</p><ul><li>return s.substring(n,s.length()) + s.substring(0,n);</li></ul></li></ul><h2 id="59-单调队列问题"><a href="#59-单调队列问题" class="headerlink" title="59.单调队列问题"></a>59.单调队列问题</h2><h3 id="滑动窗口的最大值"><a href="#滑动窗口的最大值" class="headerlink" title="滑动窗口的最大值"></a>滑动窗口的最大值</h3><ul><li><p>题目</p><ul><li>给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。</li><li>输入: nums &#x3D; [1,3,-1,-3,5,3,6,7], 和 k &#x3D; 3</li><li>输出: [3,3,5,5,6,7] </li><li>k 总是有效的，在输入数组不为空的情况下，1 ≤ k ≤ 输入数组的大小。</li><li>public int[] maxSlidingWindow(int[] nums, int k)</li></ul></li><li><p>解题思路</p><ul><li><p>滑动窗口范围通过双指针来实现</p></li><li><p>主要考察的是滑动窗口中如何求最大值</p></li><li><p>思路一：用单调队列实现</p><ul><li><p>思路与过程</p><ul><li><ol><li>单调队列用一个双端队列实现</li></ol></li><li><ol start="2"><li>单调队列中维护最大值</li></ol><ul><li>队列首为当前滑动窗口最大值</li><li>移入窗口的元素在单调栈中参与最大值精选，从后向前，将比新元素小的全部从队尾移除</li><li>最后，将新元素从队尾加入</li><li>单调队列始终保持单调递减</li></ul></li><li><ol start="3"><li>移出窗口的元素如果和队列首元素相等，则移出队列首，换之后的元素最为最大</li></ol></li></ul></li><li><p>代码实现</p><ul><li>int[] maxSlidingWindow(int[] nums, int k) {</li></ul></li></ul><p>  if(nums.length &#x3D;&#x3D; 0 ) return new int[0];<br>  int i &#x3D; 0 - k + 1, j &#x3D; 0;<br>  int[] result &#x3D; new int[nums.length - k + 1];<br>  Deque<Integer> deque &#x3D; new LinkedList&lt;&gt;();<br>  while (j &lt; nums.length) {<br>      while (!deque.isEmpty() &amp;&amp; deque.peekLast() &lt; nums[j]){<br>          deque.removeLast();<br>      }<br>      deque.addLast(nums[j++]);<br>      if(i &gt;&#x3D; 0){<br>          result[i] &#x3D; deque.peekFirst();<br>          if (nums[i] &#x3D;&#x3D; deque.peekFirst()) {<br>              deque.removeFirst();<br>          }<br>      }<br>      i++;<br>  }<br>  return result;</p></li></ul><p>  }</p><pre><code>  - 评估      - 时间复杂度 O(N)      - 空间复杂度O(K)      - 子主题 3</code></pre><ul><li><p>思路二：用优先级队列实现</p><ul><li>即用大根堆来维护滑动窗口中最大值</li><li>与单调队列类似的实现</li><li>时间复杂度为O(N + logK)</li></ul></li></ul></li></ul><h3 id="队列的最大值"><a href="#队列的最大值" class="headerlink" title="队列的最大值"></a>队列的最大值</h3><ul><li><p>题目</p><ul><li><p>请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。</p></li><li><p>即，实现一个单调队列，能快速获取队列中的最大值</p></li><li><p>若队列为空，pop_front 和 max_value 需要返回 -1</p></li></ul></li><li><p>解题思路</p><ul><li><p>和滑动窗口中的最大值类似</p></li><li><p>通过双队列来实现</p><ul><li><p>一个队列用来维护队列元素顺序</p></li><li><p>另一个队列用来维护最大值</p><ul><li>和上一题一样的实现</li></ul></li></ul></li><li><p>类似之前最小栈的实现，通过双栈实现的思路</p></li><li><p>思路与过程</p><ul><li><p>max_value方法</p><ul><li>直接返回最大值队列首元素，需要判空</li></ul></li><li><p>pop_front方法</p><ul><li>移除队列首元素，同时检查是不是最大元素</li></ul></li><li><p>push_back方法</p><ul><li>加入队列队尾，然后加入最大值队列队尾（移除其前边的小值）</li></ul></li></ul></li><li><p>代码实现</p><ul><li>void push_back(int value) {<br>  queue.addLast(value);<br>  while (!maxQueue.isEmpty() &amp;&amp; maxQueue.peekLast() &lt; value){<br>  maxQueue.removeLast();<br>  }<br>  maxQueue.addLast(value);</li></ul></li></ul><p>  }<br>      - int pop_front() {<br>      if(queue.isEmpty()) return -1;<br>      if(queue.peek().equals(maxQueue.peekFirst())){<br>          maxQueue.removeFirst();<br>      }<br>      return queue.poll();<br>  }</p></li></ul><h2 id="60-n个骰子的点数"><a href="#60-n个骰子的点数" class="headerlink" title="60.n个骰子的点数"></a>60.n个骰子的点数</h2><h3 id="题目-45"><a href="#题目-45" class="headerlink" title="题目"></a>题目</h3><ul><li>把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。</li><li>你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。</li><li>输入: 1</li><li>输出: [0.16667,0.16667,0.16667,0.16667,0.16667,0.16667]</li></ul><h3 id="解题思路-40"><a href="#解题思路-40" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li><ol><li>看到按步骤进行，则可以画出递归树</li></ol><ul><li><p>递归参数：</p><ul><li>depth，树深度，即步骤</li><li>sum，即点数之和</li></ul></li><li><p>将参数作为状态变量，则存在重复子问题</p></li><li><p>一共6^n个节点</p></li><li><p>有重复子问题，且复杂度较高，必然考虑动态规划算法</p></li></ul></li><li><ol start="2"><li>动态规划</li></ol><ul><li><p>dp[ i ][ j ]，第 i 次抛硬币，和为 j 的个数</p></li><li><p>递推方程</p><ul><li><p>dp[ i ][ j ] &#x3D; </p><ul><li>dp[ i-1 ][ j-6] + … + dp[ i-1][ j-1 ]</li><li>即这次的次数等于上次6种和的数量之和</li></ul></li></ul></li><li><p>发现 dp[ i ][ j ]之和 i-1 有关联，所以可以简化为一维数组</p></li><li><p>dp[ i ] &#x3D; </p><ul><li>dp[ i-6 ] + … + dp[ i-1]</li><li>但需要逆序求解，否则提前覆盖前边的数值，会影响之后的计算</li></ul></li></ul></li><li><p>代码实现</p><ul><li>double[] twoSum(int n) {<br>  int len &#x3D; 6*n;<br>  int [] dp &#x3D; new int[len];<br>  for (int i &#x3D; 0; i &lt; 6; i++) {<br>  dp[i] &#x3D; 1;<br>  }<br>  for (int i &#x3D; 2; i &lt;&#x3D; n; i++) {<br>  for (int j &#x3D; len -1; j &gt;&#x3D; 0 ; j–) {<br>      dp[j] &#x3D; 0;<br>      for (int k &#x3D; 1; k &lt;&#x3D; 6; k++) {<br>          if(j-k &lt; 0) break;<br>          dp[j] +&#x3D; dp[j-k];<br>      }<br>  }<br>  }<br>  double total &#x3D; Math.pow(6,n);<br>  double [] res &#x3D; new double[len-n+1];<br>  for (int i &#x3D; 0; i &lt; len-n+1; i++) {<br>  res[i] &#x3D; dp[i+n-1] &#x2F; total;<br>  }<br>  return res;<br>  }</li></ul></li><li><p>评估</p><ul><li>O(N)</li></ul></li></ul><h2 id="61-扑克牌中的顺子"><a href="#61-扑克牌中的顺子" class="headerlink" title="61. 扑克牌中的顺子"></a>61. 扑克牌中的顺子</h2><h3 id="题目-46"><a href="#题目-46" class="headerlink" title="题目"></a>题目</h3><ul><li><p>从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。</p></li><li><p>输入: [1,2,3,4,5]</p></li><li><p>输出: True</p></li></ul><h3 id="解题思路-41"><a href="#解题思路-41" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li><p>思路</p><ul><li><ol><li>肯定是先排序，排序之后检查更简单</li></ol></li><li><ol start="2"><li>解决两大问题</li></ol><ul><li><p>不能有非0的重复数字</p><ul><li>方法一：可以用Set来判断是否有重复</li><li>方法二：重复元素也会导致不满足前后差为1</li></ul></li><li><p>5个数，通过0填补之后，必须是连续的</p><ul><li>方法一：遍历，如果最终无法到达最后一个数，则不是</li><li>方法二：如果是连续的，则最大值-最小值应该&lt;</li></ul></li></ul></li></ul></li></ul><p> 5 (通过set排除重复元素)</p><ul><li><p>实现一：遍历检查</p><ul><li><p>过程</p><ul><li><ol><li>先对5个数进行排序</li></ol></li><li><ol start="2"><li>从头检索0的个数，作为替代工具</li></ol></li><li><ol start="3"><li>curr取第一个非0的数，索引index，判断其和后 index+1 位置的元素是否比它大1</li></ol><ul><li><p>是，则index++，curr++，继续判断</p><ul><li>终止条件，index + 1 &lt; length</li></ul></li><li><p>不是，则判断小王工具是否为0</p><ul><li>为0，则失败，退出</li><li>不为0，则工具数量-1，curr++，index不变</li></ul></li></ul></li></ul></li><li><p>代码实现</p><ul><li>boolean isStraight(int[] nums) {<br>  Arrays.sort(nums);<br>  int joker &#x3D; 0,index&#x3D;0;<br>  while (index &lt; nums.length &amp;&amp; nums[index] &#x3D;&#x3D; 0){<br>  joker++;<br>  index++;<br>  }<br>  if(index &gt;&#x3D; nums.length) return true;<br>  int curr &#x3D; nums[index];<br>  while (index+1 &lt; nums.length){<br>  if(nums[index+1] - curr &#x3D;&#x3D; 1){<br>  curr &#x3D; nums[++index];<br>  }else{<br>  if(joker&#x3D;&#x3D;0) break;<br>  else {<br>      joker–;<br>      curr++;<br>  }<br>  }<br>  }<br>  return index &#x3D;&#x3D; nums.length-1;</li></ul></li></ul><p>  }</p></li><li><p>实现二：通过Max-Min判断是否连续</p><ul><li><p>z</p></li><li><p>思路</p><ul><li><ol><li>遍历5个元素</li></ol><ul><li>加入set，检查是否重复，重复则直接false退出</li><li>统计最大值和最小值</li></ul></li><li><ol start="2"><li>如果不存在重复元素，那么如果是连续的，一定存在 max -min &lt; 5</li></ol></li></ul></li><li><p>代码实现</p><ul><li>boolean isStraight(int[] nums) {<br>  int max &#x3D; 0, min &#x3D; 13;<br>  Set<Integer> set &#x3D; new HashSet&lt;&gt;();<br>  for (int i &#x3D; 0; i &lt; nums.length; i++) {<br>  if(nums[i] &#x3D;&#x3D; 0){<br>  continue;<br>  }else{<br>  if(!set.contains(nums[i])){<br>      set.add(nums[i]);<br>      max &#x3D; Math.max(max,nums[i]);<br>      min &#x3D; Math.min(min,nums[i]);<br>  }else{<br>      &#x2F;&#x2F; 存在重复<br>      return false;<br>  }<br>  }<br>  }<br>  return max -min &lt; 5;</li></ul></li></ul><p>  }</p></li></ul><h2 id="62-圆圈中最后剩下的数字"><a href="#62-圆圈中最后剩下的数字" class="headerlink" title="62. 圆圈中最后剩下的数字"></a>62. 圆圈中最后剩下的数字</h2><h3 id="题目-47"><a href="#题目-47" class="headerlink" title="题目"></a>题目</h3><ul><li>0,1,,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。</li><li>例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。</li><li>输入: n &#x3D; 5, m &#x3D; 3</li><li>输出: 3</li></ul><h3 id="著名的-约瑟夫环-问题"><a href="#著名的-约瑟夫环-问题" class="headerlink" title="著名的 约瑟夫环 问题"></a>著名的 约瑟夫环 问题</h3><h3 id="解题思路-42"><a href="#解题思路-42" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li><p>思路一：队列模拟(超时)</p><ul><li><ol><li>初始将所有的数字加入队列中</li></ol></li><li><ol start="2"><li>从队首取出元素，然后再从队尾加入</li></ol></li><li><ol start="3"><li>每取m-1个，到第m个时，直接抛弃，不再入队尾</li></ol></li><li><ol start="4"><li>如果 m-1 &gt; queue.size()，取模</li></ol></li><li><p>代码实现</p><ul><li>int lastRemaining(int n, int m) {<br>  Queue<Integer> queue &#x3D; new LinkedList&lt;&gt;();<br>  for (int i &#x3D; 0; i &lt; n; i++) {<br>  queue.add(i);<br>  }</li></ul><p>  while (queue.size() &gt; 1){<br>      for (int i &#x3D; 0; i &lt; (m-1)%queue.size(); i++) {<br>          queue.add(queue.poll());<br>      }<br>      queue.poll();<br>  }<br>  return queue.poll();</p></li></ul><p>  }</p><ul><li><p>评估</p><ul><li>时间复杂度O(n^2)</li><li>空间复杂度O(N)</li></ul></li></ul></li><li><p>思路二：约瑟夫环，动态规划</p><ul><li><p>以队列模拟为基础，每次被选中的元素必然都是位于队首的</p></li><li><p>即，最终选中元素的下标为0，可以向上一次移除倒推</p></li><li><p>定义dp[ i ]，剩余 i 个数字，最终元素的坐标</p></li><li><p>dp [ i ] &#x3D; (dp[ i-1 ] + m) % n</p><ul><li>将移除的那个元素复原</li><li>如何复原，将队首m-1个以及移除的取回，所以，所有元素要向后位移 m个</li><li>可能溢出，所以取模运算</li></ul></li><li><p>代码实现</p><ul><li>int lastRemaining(int n, int m) {<br>  int ans &#x3D; 0;<br>  for (int i &#x3D; 2; i &lt; n; i++) {<br>  ans &#x3D; (ans + m) % i;<br>  }<br>  return ans;</li></ul></li></ul><p>  }</p><ul><li><p>评估</p><ul><li>时间复杂度O(N)</li></ul></li></ul></li></ul><h2 id="63-股票的最大利润"><a href="#63-股票的最大利润" class="headerlink" title="63.股票的最大利润"></a>63.股票的最大利润</h2><h3 id="题目-48"><a href="#题目-48" class="headerlink" title="题目"></a>题目</h3><ul><li>假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？</li><li>输入: [7,1,5,3,6,4]</li><li>输出: 5</li><li>0 &lt;&#x3D; 数组长度 &lt;&#x3D; 10^5</li></ul><h3 id="解题思路-43"><a href="#解题思路-43" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li><p>思路一：暴力回溯(超时)</p><ul><li>计算以 i 买入，j 卖出的所有组合的利润，求最大值</li><li>时间复杂度，O(N^2)</li></ul></li><li><p>思路二：动态规划</p><ul><li><p>区间中的最大利润：等于区间中的最高价格 - 最低价格</p></li><li><p>dp[ i ] 定义为，截至到第[ i ]天的最大利润</p></li><li><p>dp[ i ] &#x3D; max{ dp[ i-1 ] , price[ i ] - minValue }</p><ul><li>前i-1天的最大利润</li><li>最大利润在今天出现，即price[ i ] - minPrice</li><li>minPrice 表示前 i 的最低价格</li></ul></li><li><p>代码实现</p><ul><li>int maxProfit(int[] prices) {<br>  if(prices.length &#x3D;&#x3D; 0) return 0;<br>  int maxProfit &#x3D; 0;<br>  int minPrice &#x3D; prices[0];<br>  int [] dp &#x3D; new int[prices.length];<br>  for (int i &#x3D; 1; i &lt; prices.length; i++) {<br>  dp[i] &#x3D; Math.max(dp[i-1], prices[i]-minPrice);<br>  maxProfit &#x3D; Math.max(dp[i],maxProfit);<br>  minPrice &#x3D; Math.min(prices[i],minPrice);<br>  }<br>  return maxProfit;</li></ul></li></ul><p>  }</p><ul><li><p>评估</p><ul><li>时间复杂度O(N)</li><li>空间复杂度O(N)，可以做大O(1)</li></ul></li></ul></li></ul><h2 id="64-不用乘除法、条件判断语句和循环计算1-2-n"><a href="#64-不用乘除法、条件判断语句和循环计算1-2-n" class="headerlink" title="64.不用乘除法、条件判断语句和循环计算1+2+..+n"></a>64.不用乘除法、条件判断语句和循环计算1+2+..+n</h2><h3 id="题目-49"><a href="#题目-49" class="headerlink" title="题目"></a>题目</h3><ul><li>求 1+2+…+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</li></ul><h3 id="这种题，一定要从位运算、递归、二进制运算等角度去考虑"><a href="#这种题，一定要从位运算、递归、二进制运算等角度去考虑" class="headerlink" title="这种题，一定要从位运算、递归、二进制运算等角度去考虑"></a>这种题，一定要从位运算、递归、二进制运算等角度去考虑</h3><h3 id="解题思路-44"><a href="#解题思路-44" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li><p>不用乘除，那只能叠加了</p></li><li><p>不用循环，那必然要使用递归来计算了</p></li><li><p>不能用条件判断语句</p><ul><li>使用逻辑语句的短路作用</li></ul></li><li><p>代码实现</p><ul><li>public int sumNums(int n) {<br> boolean flag &#x3D; n &gt;0 &amp;&amp; (n+&#x3D;sumNums(n-1)) &#x3D;&#x3D; 0 ;<br> return n;<br>  }</li></ul></li></ul><h2 id="65-不用加减乘除做加法"><a href="#65-不用加减乘除做加法" class="headerlink" title="65.不用加减乘除做加法"></a>65.不用加减乘除做加法</h2><h3 id="题目-50"><a href="#题目-50" class="headerlink" title="题目"></a>题目</h3><ul><li>写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“&#x2F;” 四则运算符号。</li><li>a, b 均可能是负数或 0</li><li>输入: a &#x3D; 1, b &#x3D; 1</li><li>输出: 2</li></ul><h3 id="解题思路-45"><a href="#解题思路-45" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li><p>条件反射的思路</p><ul><li>不能用加减乘除，那只能用位运算，从二进制角度实现加法</li></ul></li><li><p>计算机使用补码表示，符号位直接参与计算，所以这里不需要区分正数和负数</p></li><li><p>对于 a+b</p><ul><li><p>xsum &#x3D; a^b</p><ul><li>异或运算，得到无进位加法的和</li></ul></li><li><p>full &#x3D; a&amp;b</p><ul><li>两数想并，得到各位的进位情况</li></ul></li><li><p>full &#x3D; full&gt;&gt;1</p><ul><li>进位右移，给下一位</li></ul></li><li><p>sum &#x3D; xsum + full</p><ul><li>最终进位和无进位和相加，即是最后的和</li><li>又是一个加法，继续以上操作，知道进位为0，加法结束</li></ul></li></ul></li><li><p>代码实现</p><ul><li>int add(int a, int b) {<br>  int xadd &#x3D; a^b;<br>  int full &#x3D; (a&amp;b)&lt;&lt;1;<br>  while (full !&#x3D; 0){<br>  int sum &#x3D; xadd^full;<br>  full &#x3D; (xadd&amp;full) &lt;&lt; 1;<br>  xadd &#x3D; sum;<br>  }<br>  return xadd;<br>  }</li></ul></li></ul><h2 id="66-构建乘积数组"><a href="#66-构建乘积数组" class="headerlink" title="66.构建乘积数组"></a>66.构建乘积数组</h2><h3 id="题目-51"><a href="#题目-51" class="headerlink" title="题目"></a>题目</h3><ul><li><p>给定一个数组 A[0,1,…,n-1]，请构建一个数组 B[0,1,…,n-1]，其中 B 中的元素 B[i]&#x3D;A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]。不能使用除法。</p></li><li><p>输入: [1,2,3,4,5]</p></li><li><p>输出: [120,60,40,30,24]</p></li><li><p>a.length &lt;&#x3D; 100000</p></li></ul><h3 id="解题思路-46"><a href="#解题思路-46" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li><p>思路一：暴力法</p><ul><li>两层循环，O(n(n-1))</li><li>10^5数量级，肯定超时</li></ul></li><li><p>思路二：动态规划</p><ul><li><p>思路一中有很多的重复计算</p></li><li><p>dpLeft[ i ] ，从左起，累乘到 i  的结果</p></li><li><p>dpRight[ i ]，从右起，累乘到 i 的结果</p></li><li><p>result [ i ] &#x3D; dpLeft[ i-1 ] * dpRight[ len -1 -i ]</p></li><li><p>代码实现</p><ul><li>public int[] constructArr(int[] a) {<br>  if(a.length &#x3D;&#x3D; 0) return new int[0];<br>  int [] left &#x3D; new int[a.length];<br>  int [] right &#x3D; new int[a.length];<br>  left[0] &#x3D; a[0];<br>  right[a.length-1] &#x3D; a[a.length-1];<br>  for (int i &#x3D; 1; i &lt; a.length; i++) {<br>  left[i] &#x3D; left[i-1]* a[i];<br>  right[a.length-1-i] &#x3D; right[a.length-i] * a[a.length-1-i];<br>  }<br>  int [] result &#x3D; new int[a.length];<br>  result[0] &#x3D; right[1];<br>  result[result.length-1] &#x3D; left[a.length-2];<br>  for (int i &#x3D; 1; i &lt; result.length-1; i++) {<br>  result[i] &#x3D; left[i-1]*right[i+1];<br>  }<br>  return result;</li></ul></li></ul><p>  }</p><ul><li><p>评估</p><ul><li>时间复杂度O(N)</li><li>空间复杂度O(2N)</li></ul></li></ul></li></ul><h2 id="67-把字符串转换成整数"><a href="#67-把字符串转换成整数" class="headerlink" title="67.把字符串转换成整数"></a>67.把字符串转换成整数</h2><h3 id="题目-52"><a href="#题目-52" class="headerlink" title="题目"></a>题目</h3><ul><li>写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。</li><li>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。</li><li>当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</li><li>该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。</li><li>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。</li><li>在任何情况下，若函数不能进行有效的转换时，请返回 0</li><li>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。</li></ul><h3 id="解题思路-47"><a href="#解题思路-47" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li><p>就是一个很常规的字符串处理题</p></li><li><p>过程</p><ul><li><ol><li>处理空格</li></ol><ul><li>循环读取空格</li></ul></li><li><ol start="2"><li>处理首个非空格字符，识别正负</li></ol><ul><li>数字，开始算数值</li><li>正负，记录到flag</li><li>其他字符，返回0</li></ul></li><li><ol start="3"><li>处理连续的数字，并计算值</li></ol><ul><li>res &#x3D; res * 10 +  char(i) - ‘0’</li></ul></li><li><ol start="4"><li>处理大数溢出问题</li></ol><ul><li>用long来处理</li></ul></li></ul></li><li><p>代码实现</p><ul><li>太长，见leetcode</li></ul></li></ul><h2 id="68-二叉树中两个节点的公共祖先"><a href="#68-二叉树中两个节点的公共祖先" class="headerlink" title="68. 二叉树中两个节点的公共祖先"></a>68. 二叉树中两个节点的公共祖先</h2><h3 id="对于二叉搜索树"><a href="#对于二叉搜索树" class="headerlink" title="对于二叉搜索树"></a>对于二叉搜索树</h3><h4 id="题目-53"><a href="#题目-53" class="headerlink" title="题目"></a>题目</h4><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p><h4 id="解题思路-48"><a href="#解题思路-48" class="headerlink" title="解题思路"></a>解题思路</h4><ul><li><p>BST中公共祖先的特征</p><ul><li><p>大于等于一个节点</p></li><li><p>小于等于另一个节点</p></li><li><p>且，再向下搜索就不符合了</p></li></ul></li><li><p>根据公共祖先节点的特征，在BST中查找即可</p></li><li><p>检索过程</p><ol><li><p>从根节点开始搜索BST</p></li><li><p>如果两个节点都比 当前节点小，则搜索左子树，否则右子树</p></li><li><p>当出现满足公共节点特征的时候，检索结束，返回该节点即可</p></li></ol></li></ul><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><ul><li>迭代实现,因为只有深入过程，没有回溯过程，可以用迭代实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">  <span class="comment">// 检索到一个分界点，p和q不在同一个分支上即可</span></span><br><span class="line">  <span class="type">TreeNode</span> <span class="variable">curr</span> <span class="operator">=</span> root;</span><br><span class="line">  <span class="keyword">while</span> (curr != <span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(p.val &lt; curr.val &amp;&amp; q.val &lt; curr.val)&#123;</span><br><span class="line">    curr = curr.left;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(p.val &gt; curr.val &amp;&amp; q.val &gt; curr.val)&#123;</span><br><span class="line">    curr = curr.right;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> curr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对于普通二叉树"><a href="#对于普通二叉树" class="headerlink" title="对于普通二叉树"></a>对于普通二叉树</h3><ul><li><p>题目</p><ul><li>和上题一样，只是普通的二叉树</li></ul></li><li><p>解题思路</p><ul><li><p>思路0：一下就想到了查找两个链表公共节点的问题，但发现树没有子节点向上的指针，遂放弃</p></li><li><p>思路1：队列记录两个节点的路径</p><ul><li><p>DFS两次分别检索p和q节点，将最终查找成功的路径保存在两个队列中。</p><ul><li>然后从后向前遍历队列，最后一个一样的节点，就是公共祖先</li></ul></li><li><p>难点在于遍历过程中路径队列中元素的进出</p><ul><li>回溯</li><li>bfs返回值为是否检索成功</li><li>为false时，需要将元素从中移除</li></ul></li><li><p>代码实现</p><ul><li>public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {</li></ul></li></ul><p>  Deque<TreeNode> pDeque &#x3D; new LinkedList&lt;&gt;();<br>  Deque<TreeNode> qDeque &#x3D; new LinkedList&lt;&gt;();<br>  bfs(root,p,pDeque);<br>  bfs(root,q,qDeque);<br>  TreeNode node &#x3D; null;<br>  while (!pDeque.isEmpty() &amp;&amp; !qDeque.isEmpty()){<br>      TreeNode curr &#x3D; pDeque.pollLast();<br>      if(curr &#x3D;&#x3D; qDeque.pollLast()){<br>          node &#x3D; curr;<br>      }else{<br>          break;<br>      }<br>  }<br>  return node;</p></li></ul><p>  }</p><p>  private boolean bfs(TreeNode root, TreeNode p, Deque<TreeNode> deque){<br>      if(root &#x3D;&#x3D; null) return false;<br>      deque.addFirst(root);<br>      if(root &#x3D;&#x3D; p) return true;<br>      boolean success &#x3D; bfs(root.left,p,deque);<br>      if(success) return true;<br>      if(root.left !&#x3D; null) deque.removeFirst();<br>      success &#x3D; bfs(root.right,p,deque);<br>      if(!success&amp;&amp; root.right !&#x3D; null){<br>          deque.removeFirst();<br>      }<br>      return success;<br>  }</p><ul><li><p>思路二：DFS检索特征节点</p><ul><li><p>无法再通过公共祖先的特征搜索BST了</p></li><li><p>那就只能采用DFS等遍历算法来查找了</p></li><li><p>公共祖先的特征</p><ul><li><ol><li>一个节点在左子树，一个节点在右子树</li></ol></li><li><ol start="2"><li>一个节点在左子树 &#x2F; 右子树，另一个就是祖先节点</li></ol></li><li><p>对应的不是公共祖先的特征</p><ul><li><ol><li>两个节点都在一个子树</li></ol></li><li><ol start="2"><li>左右子树每一个节点</li></ol></li></ul></li></ul></li><li><p>思路过程</p><ul><li><ol><li>执行DFS遍历每个节点</li></ol><ul><li>DFS返回值为检索到的节点</li></ul></li><li><ol start="2"><li>后序遍历，根据左右子树的检索结果，判断是否是祖先节点</li></ol><ul><li><ol start="0"><li>检索到了 p和q节点，返回p和q，用非空标识检索到了</li></ol></li><li><ol><li>left 和 right 都是null，返回null</li></ol></li><li><ol start="2"><li>left 和 right 都不是null，则符合分布在左右子树，返回当前节点</li></ol></li><li><ol start="3"><li>left 和 right 有一个非空，返回非空节点</li></ol></li></ul></li></ul></li><li><p>代码实现</p><ul><li>TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {</li></ul></li></ul><p>  if(root &#x3D;&#x3D; null) return null;<br>  if(root &#x3D;&#x3D; p || root &#x3D;&#x3D; q) return root; &#x2F;&#x2F; 自己是自己的祖先<br>  TreeNode left &#x3D; lowestCommonAncestor(root.left,p,q);<br>  TreeNode right &#x3D; lowestCommonAncestor(root.right,p,q);<br>   if(left &#x3D;&#x3D; null &amp;&amp; right &#x3D;&#x3D; null){ &#x2F;&#x2F; 叶子节点了<br>      return null;<br>  }else if(left !&#x3D; null &amp;&amp; right !&#x3D; null){ &#x2F;&#x2F; 分布在左右，ok，它是第一个祖先<br>      return root;<br>  }else if(left!&#x3D; null){<br>      return left;<br>  }else{<br>      return right;<br>  }</p></li></ul><p>  }</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【学习笔记】Three.js以及三维技术学习</title>
      <link href="/2022/02/13/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91Three-js%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/02/13/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91Three-js%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>背景知识</p></blockquote><ul><li>视频云项目又有了开发XR应用的需求了，就是实现各种AR、VR、全景视频直播等效果。Three.js是Web端进行3D展示的工具库，它对底层的WebGL进行了封装，大大简化了3D的开发。</li><li>Three.js入门学习时候的难点在于对Three.js以及三维建模领域一些关键概念的理解，本文主要以梳理Three.js中的核心概念为主。对于Three.js中的各个核心概念，通过Best Practice的形式快速了解其用途和能力。</li><li>本文追求系统性，不追求细节。旨在快速建立对Three.js整体的概念了解，能够快速看懂和利用好官方文档。</li></ul><h3 id="一、基础知识"><a href="#一、基础知识" class="headerlink" title="一、基础知识"></a>一、基础知识</h3><ul><li>场景：scene，其中可以添加object</li><li>相机：camera，对scene中的内容进行拍摄</li><li>渲染器：render，对相机拍到的画面进行渲染</li><li>网格模型：mesh，</li><li>材质：material，</li><li>几何体：geometry，</li><li>点光源：PointLight，</li><li>环境光：AmbientLight，</li></ul><span id="more"></span><h5 id="场景Scene"><a href="#场景Scene" class="headerlink" title="场景Scene"></a>场景Scene</h5><ul><li>sence：场景</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scene = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Scene</span>(); <span class="comment">// 创建场景</span></span><br><span class="line">scene.<span class="title function_">add</span>(mesh); <span class="comment">//网格模型添加到场景中</span></span><br></pre></td></tr></table></figure><h5 id="几何体Geometry"><a href="#几何体Geometry" class="headerlink" title="几何体Geometry"></a>几何体Geometry</h5><ul><li>几何框架</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//立方体 参数：长，宽，高</span></span><br><span class="line"><span class="keyword">var</span> geometry = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">BoxGeometry</span>(<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line"><span class="comment">// 球体 参数：半径60  经纬度细分数40,40</span></span><br><span class="line"><span class="keyword">var</span> geometry = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">SphereGeometry</span>(<span class="number">60</span>, <span class="number">40</span>, <span class="number">40</span>);</span><br><span class="line"><span class="comment">//圆柱  参数：圆柱面顶部、底部直径50,50   高度100  圆周分段数</span></span><br><span class="line"><span class="keyword">var</span> geometry = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">CylinderGeometry</span>(<span class="number">50</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">25</span>);</span><br><span class="line"><span class="comment">// 正八面体</span></span><br><span class="line"><span class="keyword">var</span> geometry = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">OctahedronGeometry</span>(<span class="number">50</span>);</span><br><span class="line"><span class="comment">// 正十二面体</span></span><br><span class="line"><span class="keyword">var</span> geometry = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">DodecahedronGeometry</span>(<span class="number">50</span>);</span><br><span class="line"><span class="comment">// 正二十面体</span></span><br><span class="line"><span class="keyword">var</span> geometry = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">IcosahedronGeometry</span>(<span class="number">50</span>);</span><br></pre></td></tr></table></figure><h5 id="材质Material"><a href="#材质Material" class="headerlink" title="材质Material"></a>材质Material</h5><ul><li><p>可以对几何体进行着色</p></li><li><p>本质：顶点着色器，可以被render解析加入计算</p></li><li><p>几种常用材质</p><ul><li>点材质</li><li>线材质</li><li>网格材质</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基础网格材质对象   不受光照影响  没有棱角感</span></span><br><span class="line"><span class="keyword">var</span> material = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">MeshBasicMaterial</span>(&#123;</span><br><span class="line">    <span class="attr">color</span>: <span class="number">0x0000ff</span>,</span><br><span class="line">    <span class="attr">wireframe</span>:<span class="literal">true</span>,<span class="comment">//线条模式渲染，线条编织成网</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 与光照计算  漫反射   产生棱角感</span></span><br><span class="line"><span class="keyword">var</span> material = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">MeshLambertMaterial</span>(&#123;<span class="attr">color</span>: <span class="number">0x0000ff</span> &#125;); </span><br><span class="line"><span class="comment">// 与光照计算  高光效果（镜面反射）产生棱角感</span></span><br><span class="line"><span class="keyword">var</span> material = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">MeshPhongMaterial</span>(&#123;</span><br><span class="line">    <span class="attr">color</span>: <span class="number">0xff0000</span>,</span><br><span class="line">    <span class="attr">specular</span>:<span class="number">0x444444</span>, <span class="comment">// 高光部分的颜色</span></span><br><span class="line">    <span class="attr">shininess</span>:<span class="number">30</span>, <span class="comment">// 高光部分的亮度</span></span><br><span class="line">  <span class="attr">side</span>:<span class="variable constant_">THREE</span>.<span class="property">DoubleSide</span>, <span class="comment">// 前面FrontSide  背面：BackSide 双面：DoubleSide</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 透明材质</span></span><br><span class="line"><span class="keyword">var</span> material1 = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">MeshLambertMaterial</span>(&#123;</span><br><span class="line">  <span class="attr">color</span>: <span class="number">0x0000ff</span>,<span class="comment">//材质颜色</span></span><br><span class="line">  <span class="attr">transparent</span>:<span class="literal">true</span>,<span class="comment">//开启透明度</span></span><br><span class="line">  <span class="attr">opacity</span>:<span class="number">0.5</span>,<span class="comment">//设置透明度具体值</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 点渲染模式</span></span><br><span class="line"><span class="keyword">var</span> material = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">PointsMaterial</span>(&#123;</span><br><span class="line">  <span class="attr">color</span>: <span class="number">0xff0000</span>,</span><br><span class="line">  <span class="attr">size</span>: <span class="number">5.0</span> <span class="comment">//点对象像素尺寸</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 线条渲染模式</span></span><br><span class="line"><span class="keyword">var</span> material=<span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">LineBasicMaterial</span>(&#123;</span><br><span class="line">    <span class="attr">color</span>:<span class="number">0xff0000</span> <span class="comment">//线条颜色</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="渲染模型"><a href="#渲染模型" class="headerlink" title="渲染模型"></a>渲染模型</h5><ul><li>由几何体参数+材质参数组成</li><li>与材质类似，也有三种<ul><li>点模型：Point</li><li>线模型：Line</li><li>网格模型：Mesh</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mesh = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Mesh</span>(geometry, material); <span class="comment">//网格模型对象Mesh</span></span><br><span class="line">scene.<span class="title function_">add</span>(mesh); <span class="comment">//网格模型添加到场景中</span></span><br><span class="line"></span><br><span class="line">mesh.<span class="title function_">rotateY</span>(<span class="number">0.01</span>);         <span class="comment">//绕y轴旋转0.01弧度</span></span><br><span class="line">mesh.<span class="title function_">translateY</span>(<span class="number">120</span>);       <span class="comment">//球体网格模型沿Y轴正方向平移120</span></span><br><span class="line">mesh.<span class="property">position</span>.<span class="title function_">set</span>(<span class="number">120</span>,<span class="number">0</span>,<span class="number">0</span>); <span class="comment">//设置mesh3模型对象的xyz坐标为120,0,0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> point = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Points</span>(geometry, material);</span><br><span class="line"><span class="keyword">var</span> line = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Line</span>(geometry, material); <span class="comment">//线模型对象</span></span><br></pre></td></tr></table></figure><ul><li>复制模型</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> geometry2 = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">BoxGeometry</span>(<span class="number">30</span>, <span class="number">30</span>, <span class="number">30</span>); <span class="comment">//创建一个立方体几何对象Geometry</span></span><br><span class="line"><span class="keyword">var</span> material2 = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">MeshLambertMaterial</span>(&#123;</span><br><span class="line">  <span class="attr">color</span>: <span class="number">0xff00ff</span></span><br><span class="line">&#125;); <span class="comment">//材质对象Material</span></span><br><span class="line"><span class="keyword">var</span> newMesh = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Mesh</span>(geometry2, material2);</span><br><span class="line"><span class="comment">// 复制mesh的位置、旋转、矩阵等属性(不包含geometry和material属性)</span></span><br><span class="line">newMesh.<span class="title function_">copy</span>(mesh);</span><br><span class="line"><span class="comment">//相比mesh而言，在平移</span></span><br><span class="line">newMesh.<span class="title function_">translateX</span>(-<span class="number">50</span>);</span><br><span class="line">scene.<span class="title function_">add</span>(newMesh)</span><br></pre></td></tr></table></figure><h5 id="相机Camera"><a href="#相机Camera" class="headerlink" title="相机Camera"></a>相机Camera</h5><ul><li>远景相机（PerspectiveCamera），也就是类似于人眼观察的方式<ul><li>4个参数，决定了视椎体，用来裁剪视图，在该视锥体以外的物体将不会被渲染。<ul><li>FOV：视角（field of view）</li><li>aspect_radio:相机拍摄面的长宽比（aspect ratio）,一般使用元素的宽除以高，否则会出现挤压变形。</li><li>near_plane: 近裁剪面</li><li>far_plane: 远裁剪面</li></ul></li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> width = <span class="variable language_">window</span>.<span class="property">innerWidth</span>; <span class="comment">//窗口宽度</span></span><br><span class="line"><span class="keyword">var</span> height = <span class="variable language_">window</span>.<span class="property">innerHeight</span>; <span class="comment">//窗口高度</span></span><br><span class="line"><span class="keyword">var</span> aspect = width / height; <span class="comment">//窗口宽高比</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="number">200</span>; <span class="comment">//三维场景显示范围控制系数，系数越大，显示的范围越大</span></span><br><span class="line"><span class="comment">// 创建相机对象</span></span><br><span class="line"><span class="keyword">var</span> camera = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">OrthographicCamera</span>(-s * k, s * k, s, -s, <span class="number">1</span>, <span class="number">1000</span>);</span><br><span class="line"><span class="comment">// 创建远景相机,参数（FOV，aspect_radio,near_plane,far_plane）</span></span><br><span class="line"><span class="keyword">var</span> camera = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">PerspectiveCamera</span>( <span class="number">75</span>, aspect , <span class="number">0.1</span>, <span class="number">1000</span> );</span><br><span class="line">camera.<span class="property">position</span>.<span class="title function_">set</span>(<span class="number">200</span>, <span class="number">300</span>, <span class="number">200</span>); <span class="comment">//设置相机位置</span></span><br><span class="line">camera.<span class="title function_">lookAt</span>(scene.<span class="property">position</span>); <span class="comment">//设置相机方向(指向的场景对象)</span></span><br></pre></td></tr></table></figure><h5 id="渲染器Render"><a href="#渲染器Render" class="headerlink" title="渲染器Render"></a>渲染器Render</h5><ul><li>WebGLRenderer为主，也有其他渲染器，但以兼容性为主</li><li>WebGLRenderer，使用GPU进行渲染</li><li>render负责解析数据，然后</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> renderer = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">WebGLRenderer</span>();</span><br><span class="line"><span class="comment">//设置渲染区域尺寸</span></span><br><span class="line">renderer.<span class="title function_">setSize</span>(<span class="variable language_">window</span>.<span class="property">innerWidth</span>, <span class="variable language_">window</span>.<span class="property">innerHeight</span>);</span><br><span class="line"><span class="comment">//设置背景颜色</span></span><br><span class="line">renderer.<span class="title function_">setClearColor</span>(<span class="number">0xb9d3ff</span>, <span class="number">1</span>); </span><br><span class="line"><span class="comment">// 把 renderer 元素添加到HTML文档中。这里是一个 &lt;canvas&gt; 元素，渲染器用来显示场景</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(renderer.<span class="property">domElement</span>);</span><br><span class="line"><span class="comment">//执行渲染操作</span></span><br><span class="line">renderer.<span class="title function_">render</span>(scene, camera); <span class="comment">// 只会渲染一次</span></span><br><span class="line"><span class="comment">// 循环渲染</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">  cube.<span class="property">rotation</span>.<span class="property">x</span> += <span class="number">0.1</span>; <span class="comment">// 实现动画</span></span><br><span class="line">  cube.<span class="property">rotation</span>.<span class="property">y</span> += <span class="number">0.1</span>;</span><br><span class="line">  <span class="title function_">requestAnimationFrame</span>( render ); <span class="comment">// window的函数，以每秒60次的频率来绘制场景</span></span><br><span class="line">  renderer.<span class="title function_">render</span>( scene, camera );</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">render</span>();</span><br></pre></td></tr></table></figure><ul><li>requestAnimationFrame函数：它用来替代 setInterval， 这个新接口具备多个优点，比如浏览器Tab切换后停止渲染以节约资源、和屏幕刷新同步避免无效刷新、在不支持该接口的浏览器中能安全回退为setInterval</li></ul><h3 id="二、相机控制与交互"><a href="#二、相机控制与交互" class="headerlink" title="二、相机控制与交互"></a>二、相机控制与交互</h3><ul><li>Three.js提供了OrbitControls.js，直接控制相机</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建控件对象  相机对象camera作为参数   控件可以监听鼠标的变化，改变相机对象的属性</span></span><br><span class="line"><span class="keyword">var</span> controls = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">OrbitControls</span>(camera,renderer.<span class="property">domElement</span>);</span><br><span class="line"><span class="comment">//监听鼠标事件，触发渲染函数，更新canvas画布渲染效果</span></span><br><span class="line">controls.<span class="title function_">addEventListener</span>(<span class="string">&#x27;change&#x27;</span>, render);</span><br></pre></td></tr></table></figure><ul><li>动画与交互同时控制</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">  renderer.<span class="title function_">render</span>(scene, camera); <span class="comment">//执行渲染操作</span></span><br><span class="line">  mesh.<span class="title function_">rotateY</span>(<span class="number">0.01</span>);<span class="comment">//每次绕y轴旋转0.01弧度</span></span><br><span class="line">  <span class="title function_">requestAnimationFrame</span>(render);<span class="comment">//请求再次执行渲染函数render，渲染下一帧</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">render</span>();</span><br><span class="line"><span class="comment">//创建控件对象  相机对象camera作为参数   控件可以监听鼠标的变化，改变相机对象的属性</span></span><br><span class="line"><span class="keyword">var</span> controls = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">OrbitControls</span>(camera,renderer.<span class="property">domElement</span>);</span><br></pre></td></tr></table></figure><h3 id="三、顶点"><a href="#三、顶点" class="headerlink" title="三、顶点"></a>三、顶点</h3><h5 id="顶点概念"><a href="#顶点概念" class="headerlink" title="顶点概念"></a>顶点概念</h5><ul><li>顶点连接成线，线组成三角面，三角面组成更多类型的面，顶点具有position和color等基础属性</li><li>BufferGeometry是所有几何体的基类，可以为其赋予多种属性，来实现不同的效果。</li><li>主要是通过顶点数据来确定渲染的。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> geometry = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">BufferGeometry</span>(); <span class="comment">//创建一个Buffer类型几何体对象</span></span><br><span class="line"><span class="keyword">var</span> vertices = <span class="keyword">new</span> <span class="title class_">Float32Array</span>([ <span class="comment">//类型数组创建顶点数据</span></span><br><span class="line">  <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="comment">//顶点1坐标</span></span><br><span class="line">  <span class="number">50</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="comment">//顶点2坐标</span></span><br><span class="line">  <span class="number">0</span>, <span class="number">50</span>, <span class="number">0</span>, <span class="comment">//顶点3坐标</span></span><br><span class="line">  <span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="comment">//顶点4坐标</span></span><br><span class="line">  <span class="number">0</span>, <span class="number">0</span>, <span class="number">60</span>, <span class="comment">//顶点5坐标</span></span><br><span class="line">  <span class="number">50</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="comment">//顶点6坐标</span></span><br><span class="line">]);</span><br><span class="line"><span class="comment">// 创建属性缓冲区对象</span></span><br><span class="line"><span class="keyword">var</span> attribue = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">BufferAttribute</span>(vertices, <span class="number">3</span>); <span class="comment">//3个为一组，表示一个顶点的xyz坐标</span></span><br><span class="line"><span class="comment">// 设置几何体attributes属性的位置属性</span></span><br><span class="line">geometry.<span class="property">attributes</span>.<span class="property">position</span> = attribue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类型数组创建顶点颜色color数据</span></span><br><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="title class_">Float32Array</span>([</span><br><span class="line">  <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="comment">//顶点1颜色</span></span><br><span class="line">  <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="comment">//顶点2颜色</span></span><br><span class="line">  <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="comment">//顶点3颜色</span></span><br><span class="line">  <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="comment">//顶点4颜色</span></span><br><span class="line">  <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="comment">//顶点5颜色</span></span><br><span class="line">  <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="comment">//顶点6颜色</span></span><br><span class="line">]);</span><br><span class="line"><span class="comment">// 设置几何体attributes属性的颜色color属性</span></span><br><span class="line">geometry.<span class="property">attributes</span>.<span class="property">color</span> = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">BufferAttribute</span>(colors, <span class="number">3</span>); <span class="comment">//3个为一组,表示一个顶点的颜色数据RGB</span></span><br><span class="line">  <span class="comment">//材质对象</span></span><br><span class="line"><span class="keyword">var</span> material = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">MeshBasicMaterial</span>(&#123;</span><br><span class="line">  <span class="comment">// 使用顶点颜色数据渲染模型，不需要再定义color属性</span></span><br><span class="line">  <span class="comment">// color: 0xff0000,</span></span><br><span class="line">  <span class="attr">vertexColors</span>: <span class="variable constant_">THREE</span>.<span class="property">VertexColors</span>, <span class="comment">//以顶点颜色为准,即试用上边指定的颜色数组</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="顶点法向量"><a href="#顶点法向量" class="headerlink" title="顶点法向量"></a>顶点法向量</h5><ul><li>参与光照的计算，对物体最终所呈现的实际颜色的有影响的。</li><li>法向量对应的属性为normal</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> normals = <span class="keyword">new</span> <span class="title class_">Float32Array</span>([</span><br><span class="line">    <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="comment">//顶点1法向量</span></span><br><span class="line">    <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="comment">//顶点2法向量</span></span><br><span class="line">    <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="comment">//顶点3法向量</span></span><br><span class="line"></span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="comment">//顶点4法向量</span></span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="comment">//顶点5法向量</span></span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="comment">//顶点6法向量</span></span><br><span class="line">  ]);</span><br><span class="line">  <span class="comment">// 设置几何体attributes属性的位置normal属性</span></span><br><span class="line">  geometry.<span class="property">attributes</span>.<span class="property">normal</span> = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">BufferAttribute</span>(normals, <span class="number">3</span>); <span class="comment">//3个为一组,表示一个顶点的法向量数据</span></span><br></pre></td></tr></table></figure><h5 id="顶点数据复用与索引"><a href="#顶点数据复用与索引" class="headerlink" title="顶点数据复用与索引"></a>顶点数据复用与索引</h5><ul><li>渲染一个四边形，实际需要6个顶点，是通过两个三角面实现的。</li><li>其中第二个三角面的两个顶点与第一个重合，所以可以复用。</li><li>通过顶点的索引属性来指定，实现顶点数据的复用，对应的属性名为index。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// Uint16Array类型数组创建顶点索引数据</span></span><br><span class="line"><span class="keyword">var</span> indexes = <span class="keyword">new</span> <span class="title class_">Uint16Array</span>([</span><br><span class="line">  <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>,</span><br><span class="line">])</span><br><span class="line"><span class="comment">// 索引数据赋值给几何体的index属性</span></span><br><span class="line">geometry.<span class="property">index</span> = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">BufferAttribute</span>(indexes, <span class="number">1</span>); <span class="comment">//1个为一组</span></span><br></pre></td></tr></table></figure><h5 id="设置Geometry的顶点"><a href="#设置Geometry的顶点" class="headerlink" title="设置Geometry的顶点"></a>设置Geometry的顶点</h5><ul><li>相比BufferGeomerty<ul><li>他们的属性组织架构是不同的，但实现的效果是相同的</li><li>BufferGeomerty是基于缩影的渲染，而Geometry是基于三角面的方式。</li></ul></li><li>属性<ul><li>vertices属性，顶点坐标数据</li><li>colors属性，顶点颜色数据</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> geometry = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Geometry</span>(); <span class="comment">//声明一个几何体对象Geometry</span></span><br><span class="line"><span class="comment">// Vector3向量对象表示顶点位置数据</span></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>(<span class="number">50</span>, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">//顶点1坐标</span></span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>(<span class="number">0</span>, <span class="number">70</span>, <span class="number">0</span>); <span class="comment">//顶点2坐标</span></span><br><span class="line"><span class="keyword">var</span> p3 = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>(<span class="number">80</span>, <span class="number">70</span>, <span class="number">0</span>); <span class="comment">//顶点3坐标</span></span><br><span class="line"><span class="comment">//顶点坐标添加到geometry对象</span></span><br><span class="line">geometry.<span class="property">vertices</span>.<span class="title function_">push</span>(p1, p2, p3);</span><br><span class="line"><span class="comment">// Color对象表示顶点颜色数据</span></span><br><span class="line"><span class="keyword">var</span> color1 = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Color</span>(<span class="number">0x00ff00</span>); <span class="comment">//顶点1颜色——绿色</span></span><br><span class="line"><span class="keyword">var</span> color2 = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Color</span>(<span class="number">0xff0000</span>); <span class="comment">//顶点2颜色——红色</span></span><br><span class="line"><span class="keyword">var</span> color3 = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Color</span>(<span class="number">0x0000ff</span>); <span class="comment">//顶点3颜色——蓝色</span></span><br><span class="line"><span class="comment">//顶点颜色数据添加到geometry对象</span></span><br><span class="line">geometry.<span class="property">colors</span>.<span class="title function_">push</span>(color1, color2, color3);</span><br></pre></td></tr></table></figure><h5 id="Face3对象"><a href="#Face3对象" class="headerlink" title="Face3对象"></a>Face3对象</h5><ul><li>定义几何体的三角面</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> geometry = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Geometry</span>(); <span class="comment">//声明一个几何体对象Geometry</span></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">//顶点1坐标</span></span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>(<span class="number">0</span>, <span class="number">100</span>, <span class="number">0</span>); <span class="comment">//顶点2坐标</span></span><br><span class="line"><span class="keyword">var</span> p3 = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>(<span class="number">50</span>, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">//顶点3坐标</span></span><br><span class="line"><span class="keyword">var</span> p4 = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>); <span class="comment">//顶点4坐标</span></span><br><span class="line"><span class="comment">//顶点坐标添加到geometry对象</span></span><br><span class="line">geometry.<span class="property">vertices</span>.<span class="title function_">push</span>(p1, p2, p3, p4);</span><br><span class="line"><span class="comment">// Color对象表示顶点颜色数据</span></span><br><span class="line"><span class="keyword">var</span> color1 = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Color</span>(<span class="number">0x00ff00</span>); <span class="comment">//顶点1颜色——绿色</span></span><br><span class="line"><span class="keyword">var</span> color2 = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Color</span>(<span class="number">0xff0000</span>); <span class="comment">//顶点2颜色——红色</span></span><br><span class="line"><span class="keyword">var</span> color3 = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Color</span>(<span class="number">0x0000ff</span>); <span class="comment">//顶点3颜色——蓝色</span></span><br><span class="line"><span class="keyword">var</span> color4 = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Color</span>(<span class="number">0xffff00</span>); <span class="comment">//顶点3颜色——黄色</span></span><br><span class="line"><span class="comment">//顶点颜色数据添加到geometry对象</span></span><br><span class="line">geometry.<span class="property">colors</span>.<span class="title function_">push</span>(color1, color2, color3, color4);</span><br><span class="line"><span class="comment">// Face3构造函数创建一个三角面</span></span><br><span class="line"><span class="keyword">var</span> face1 = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Face3</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">//设置三角面face1每个顶点的法向量</span></span><br><span class="line"><span class="keyword">var</span> n1 = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>(<span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> n2 = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>(<span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> n3 = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>(<span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 设置三角面Face3三个顶点的法向量</span></span><br><span class="line">face1.<span class="property">vertexNormals</span>.<span class="title function_">push</span>(n1, n2, n3);</span><br><span class="line"><span class="comment">// 设置三角面face1三个顶点的颜色</span></span><br><span class="line">face1.<span class="property">vertexColors</span> = [</span><br><span class="line">  <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Color</span>(<span class="number">0xffff00</span>),</span><br><span class="line">  <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Color</span>(<span class="number">0xff00ff</span>),</span><br><span class="line">  <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Color</span>(<span class="number">0x00ffff</span>),</span><br><span class="line">]</span><br><span class="line"><span class="comment">// 三角面2</span></span><br><span class="line"><span class="keyword">var</span> face2 = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Face3</span>(<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">// 设置三角面法向量</span></span><br><span class="line">face2.<span class="property">normal</span> = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>(<span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">face2.<span class="property">color</span> = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Color</span>(<span class="number">0x00ff00</span>);</span><br><span class="line"><span class="comment">//三角面face1、face2添加到几何体中</span></span><br><span class="line">geometry.<span class="property">faces</span>.<span class="title function_">push</span>(face1, face2);</span><br></pre></td></tr></table></figure><h5 id="几何体变换"><a href="#几何体变换" class="headerlink" title="几何体变换"></a>几何体变换</h5><ul><li>其实就是对顶点坐标进行变换</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 几何体xyz三个方向都放大2倍</span></span><br><span class="line">geometry.<span class="title function_">scale</span>(<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// 几何体沿着x轴平移50</span></span><br><span class="line">geometry.<span class="title function_">translate</span>(<span class="number">50</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 几何体绕着x轴旋转45度</span></span><br><span class="line">geometry.<span class="title function_">rotateX</span>(<span class="title class_">Math</span>.<span class="property">PI</span> / <span class="number">4</span>);</span><br><span class="line"><span class="comment">// 居中：偏移的几何体居中</span></span><br><span class="line">geometry.<span class="title function_">center</span>();</span><br></pre></td></tr></table></figure><h3 id="四、光源"><a href="#四、光源" class="headerlink" title="四、光源"></a>四、光源</h3><ul><li>可以与模型对象一起，添加到场景中</li><li>可以与材质的颜色进行计算，计算得到最终看到的颜色值</li><li>分类：<ul><li>环境光：无方向的光，其他都是有方向的</li><li>点光源</li><li>平行光源</li><li>聚光光源</li></ul></li></ul><h5 id="点光源PointLight"><a href="#点光源PointLight" class="headerlink" title="点光源PointLight"></a>点光源PointLight</h5><ul><li>add插入场景中，render的时候会获取光源的信息进行光照计算</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//点光源</span></span><br><span class="line"><span class="keyword">var</span> point = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">PointLight</span>(<span class="number">0xffffff</span>);</span><br><span class="line">point.<span class="property">position</span>.<span class="title function_">set</span>(<span class="number">400</span>, <span class="number">200</span>, <span class="number">300</span>); <span class="comment">//点光源位置</span></span><br><span class="line">scene.<span class="title function_">add</span>(point); <span class="comment">//点光源添加到场景中</span></span><br></pre></td></tr></table></figure><h5 id="环境光AmbientLight"><a href="#环境光AmbientLight" class="headerlink" title="环境光AmbientLight"></a>环境光AmbientLight</h5><ul><li>环境光颜色与网格模型的颜色进行RGB进行乘法运算</li><li>没有方向，所以没有明显的棱</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//环境光</span></span><br><span class="line"><span class="keyword">var</span> ambient = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">AmbientLight</span>(<span class="number">0x444444</span>);</span><br><span class="line">scene.<span class="title function_">add</span>(ambient);</span><br></pre></td></tr></table></figure><h5 id="聚光"><a href="#聚光" class="headerlink" title="聚光"></a>聚光</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> spotLight = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">SpotLight</span>(<span class="number">0xffffff</span>);</span><br><span class="line"><span class="comment">// 设置聚光光源位置</span></span><br><span class="line">spotLight.<span class="property">position</span>.<span class="title function_">set</span>(<span class="number">200</span>, <span class="number">200</span>, <span class="number">200</span>);</span><br><span class="line"><span class="comment">// 聚光灯光源指向网格模型mesh2</span></span><br><span class="line">spotLight.<span class="property">target</span> = mesh2;</span><br><span class="line"><span class="comment">// 设置聚光光源发散角度</span></span><br><span class="line">spotLight.<span class="property">angle</span> = <span class="title class_">Math</span>.<span class="property">PI</span> / <span class="number">6</span></span><br><span class="line">scene.<span class="title function_">add</span>(spotLight);<span class="comment">//光对象添加到scene场景中</span></span><br></pre></td></tr></table></figure><h5 id="平行光"><a href="#平行光" class="headerlink" title="平行光"></a>平行光</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> directionalLight = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">DirectionalLight</span>(<span class="number">0xffffff</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 设置光源的方向：通过光源position属性和目标指向对象的position属性计算</span></span><br><span class="line"><span class="comment">// 注意：位置属性在这里不代表方向光的位置，你可以认为方向光没有位置</span></span><br><span class="line">directionalLight.<span class="property">position</span>.<span class="title function_">set</span>(<span class="number">80</span>, <span class="number">100</span>, <span class="number">50</span>);</span><br><span class="line"><span class="comment">// 方向光指向对象，可以不设置，默认的位置是0,0,0</span></span><br><span class="line">directionalLight.<span class="property">target</span> = mesh2;</span><br><span class="line">scene.<span class="title function_">add</span>(directionalLight);</span><br></pre></td></tr></table></figure><h5 id="添加阴影"><a href="#添加阴影" class="headerlink" title="添加阴影"></a>添加阴影</h5><ul><li>分两步<ul><li>1.开启模型的阴影</li><li>2.添加一个接收阴影的模型</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mesh = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Mesh</span>(geometry, material); <span class="comment">//网格模型对象Mesh</span></span><br><span class="line">scene.<span class="title function_">add</span>(mesh); <span class="comment">//网格模型添加到场景中</span></span><br><span class="line">mesh.<span class="property">castShadow</span> = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">//创建一个平面几何体作为投影面</span></span><br><span class="line"><span class="keyword">var</span> planeGeometry = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">PlaneGeometry</span>(<span class="number">300</span>, <span class="number">200</span>);</span><br><span class="line"><span class="keyword">var</span> planeMaterial = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">MeshLambertMaterial</span>(&#123;</span><br><span class="line">  <span class="attr">color</span>: <span class="number">0x999999</span></span><br><span class="line">&#125;); <span class="comment">//材质对象Material</span></span><br><span class="line"><span class="comment">// 平面网格模型作为投影面</span></span><br><span class="line"><span class="keyword">var</span> planeMesh = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Mesh</span>(planeGeometry, planeMaterial); <span class="comment">//网格模型对象Mesh</span></span><br><span class="line">scene.<span class="title function_">add</span>(planeMesh); <span class="comment">//网格模型添加到场景中</span></span><br><span class="line">planeMesh.<span class="property">receiveShadow</span> = <span class="literal">true</span>;</span><br><span class="line">planeMesh.<span class="title function_">rotateX</span>(-<span class="title class_">Math</span>.<span class="property">PI</span> / <span class="number">2</span>)</span><br><span class="line">planeMesh.<span class="property">position</span>.<span class="property">y</span> = -<span class="number">25</span>;</span><br></pre></td></tr></table></figure><h3 id="五、组对象Group"><a href="#五、组对象Group" class="headerlink" title="五、组对象Group"></a>五、组对象Group</h3><ul><li>目的是方便批量处理，可以将多个模型对象组合成一个Group，然后对这个Group进行统一的处理。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> group1 = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Group</span>();</span><br><span class="line"><span class="keyword">var</span> mesh = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Mesh</span>(geometry, material);</span><br><span class="line">group1.<span class="title function_">add</span>(mesh); <span class="comment">//把网格模型插入到组group1中</span></span><br><span class="line">scene.<span class="title function_">add</span>(group);</span><br></pre></td></tr></table></figure><h3 id="六、位置坐标"><a href="#六、位置坐标" class="headerlink" title="六、位置坐标"></a>六、位置坐标</h3><ul><li>本地与世界作保<ul><li>本地坐标：该模型对象属性中设置的坐标</li><li>世界坐标：一个模型对象可能还存在其他Group中，Group的坐标变化也会造成该模型对象的位置变化，最终该模型的坐标便是它的世界坐标。</li></ul></li><li>获得世界坐标的方法</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scene.<span class="title function_">updateMatrixWorld</span>(<span class="literal">true</span>); <span class="comment">// 更新世界坐标矩阵，不可缺少</span></span><br><span class="line"><span class="keyword">var</span> worldPosition = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>();</span><br><span class="line">mesh.<span class="title function_">getWorldPosition</span>(worldPosition)</span><br></pre></td></tr></table></figure><h3 id="七、纹理贴图"><a href="#七、纹理贴图" class="headerlink" title="七、纹理贴图"></a>七、纹理贴图</h3><h5 id="顶点UV映射数据"><a href="#顶点UV映射数据" class="headerlink" title="顶点UV映射数据"></a>顶点UV映射数据</h5><ul><li>3D模型除了有顶点坐标、颜色等属性外，还有一个顶点纹理UV数据，UV负责实现外部纹理与模型顶点之间的映射</li><li>对于常用的立方体、球体、平面等模型，内部已经具有了UV数据。</li><li>对于更复杂的3D模型，通过外部modle.json文件导入的方式导入模型，该json中会包括UV数据。</li></ul><h5 id="图片作为纹理"><a href="#图片作为纹理" class="headerlink" title="图片作为纹理"></a>图片作为纹理</h5><ul><li>通过TextureLoader加载一个图片，然后把图片数据作为纹理数据，传递给map属性即可。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> geometry = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">BoxGeometry</span>(<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>); <span class="comment">//立方体</span></span><br><span class="line"><span class="keyword">var</span> geometry = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">PlaneGeometry</span>(<span class="number">204</span>, <span class="number">102</span>); <span class="comment">//矩形平面</span></span><br><span class="line"><span class="keyword">var</span> geometry = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">SphereGeometry</span>(<span class="number">60</span>, <span class="number">25</span>, <span class="number">25</span>); <span class="comment">//球体</span></span><br><span class="line"><span class="comment">// TextureLoader创建一个纹理加载器对象，可以加载图片作为几何体纹理</span></span><br><span class="line"><span class="keyword">var</span> textureLoader = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">TextureLoader</span>();</span><br><span class="line"><span class="comment">// 执行load方法，加载纹理贴图成功后，返回一个纹理对象Texture</span></span><br><span class="line">textureLoader.<span class="title function_">load</span>(<span class="string">&#x27;Earth.png&#x27;</span>, <span class="keyword">function</span> (<span class="params">texture</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> material = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">MeshLambertMaterial</span>(&#123;</span><br><span class="line">    <span class="attr">map</span>: texture,        <span class="comment">// 设置纹理贴图：Texture对象作为材质map属性的属性值</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">var</span> mesh = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Mesh</span>(geometry, material); <span class="comment">//网格模型对象Mesh</span></span><br><span class="line">  scene.<span class="title function_">add</span>(mesh); <span class="comment">//网格模型添加到场景中</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="视频作为纹理"><a href="#视频作为纹理" class="headerlink" title="视频作为纹理"></a>视频作为纹理</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> geometry = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">PlaneGeometry</span>(<span class="number">108</span>, <span class="number">71</span>); <span class="comment">//矩形平面</span></span><br><span class="line"><span class="keyword">let</span> video = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;video&#x27;</span>);     <span class="comment">// 创建video对象</span></span><br><span class="line">video.<span class="property">src</span> = <span class="string">&quot;video.mp4&quot;</span>; <span class="comment">// 设置视频地址</span></span><br><span class="line">video.<span class="property">autoplay</span> = <span class="string">&quot;autoplay&quot;</span>; <span class="comment">//要设置播放</span></span><br><span class="line"><span class="comment">// video对象作为VideoTexture参数创建纹理对象</span></span><br><span class="line"><span class="keyword">var</span> texture = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">VideoTexture</span>(video)</span><br><span class="line"><span class="keyword">var</span> material = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">MeshPhongMaterial</span>(&#123;</span><br><span class="line">  <span class="attr">map</span>: texture, <span class="comment">// 设置纹理贴图</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> mesh = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Mesh</span>(geometry, material); <span class="comment">//网格模型对象Mesh</span></span><br><span class="line">scene.<span class="title function_">add</span>(mesh); <span class="comment">//网格模型添加到场景中</span></span><br></pre></td></tr></table></figure><h5 id="纹理整列"><a href="#纹理整列" class="headerlink" title="纹理整列"></a>纹理整列</h5><ul><li>加载纹理之后，不断重复该纹理，即贴图效果。</li><li>实现草地效果</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> geometry = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">PlaneGeometry</span>(<span class="number">1000</span>, <span class="number">1000</span>); <span class="comment">//矩形平面</span></span><br><span class="line"><span class="keyword">var</span> texture = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">TextureLoader</span>().<span class="title function_">load</span>(<span class="string">&quot;grass.jpg&quot;</span>);</span><br><span class="line">texture.<span class="property">wrapS</span> = <span class="variable constant_">THREE</span>.<span class="property">RepeatWrapping</span>;</span><br><span class="line">texture.<span class="property">wrapT</span> = <span class="variable constant_">THREE</span>.<span class="property">RepeatWrapping</span>;</span><br><span class="line">texture.<span class="property">repeat</span>.<span class="title function_">set</span>(<span class="number">10</span>, <span class="number">10</span>);     <span class="comment">// uv两个方向纹理重复数量</span></span><br><span class="line"><span class="keyword">var</span> material = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">MeshLambertMaterial</span>(&#123;</span><br><span class="line">  <span class="attr">map</span>: texture,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> mesh = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Mesh</span>(geometry, material); <span class="comment">//网格模型对象Mesh</span></span><br><span class="line">scene.<span class="title function_">add</span>(mesh); <span class="comment">//网格模型添加到场景中</span></span><br><span class="line">mesh.<span class="title function_">rotateX</span>(-<span class="title class_">Math</span>.<span class="property">PI</span> / <span class="number">2</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="八、相机"><a href="#八、相机" class="headerlink" title="八、相机"></a>八、相机</h3><ul><li>相机拍摄的过程其实就是进行投影计算的过程，我们看到的物体实际是一个三维物体在一个方向上的投影</li><li>分类<ul><li>正投影：没有近大远小效果，适用于小场景，一般用于三维设计或者零件展示。可视区域是一个立方体。</li><li>透视投影：近大远小效果，适用于大场景，比如游戏场景，可视区域是一个视锥体</li></ul></li></ul><h5 id="相机窗口自适应"><a href="#相机窗口自适应" class="headerlink" title="相机窗口自适应"></a>相机窗口自适应</h5><ul><li>透视相机自适应</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onresize</span>=<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="comment">// 重置渲染器输出画布canvas尺寸</span></span><br><span class="line">  renderer.<span class="title function_">setSize</span>(<span class="variable language_">window</span>.<span class="property">innerWidth</span>,<span class="variable language_">window</span>.<span class="property">innerHeight</span>);</span><br><span class="line">  <span class="comment">// 全屏情况下：设置观察范围长宽比aspect为窗口宽高比</span></span><br><span class="line">  camera.<span class="property">aspect</span> = <span class="variable language_">window</span>.<span class="property">innerWidth</span>/<span class="variable language_">window</span>.<span class="property">innerHeight</span>;</span><br><span class="line">  <span class="comment">// 渲染器执行render方法的时候会读取相机对象的投影矩阵属性projectionMatrix</span></span><br><span class="line">  <span class="comment">// 但是不会每渲染一帧，就通过相机的属性计算投影矩阵(节约计算资源)</span></span><br><span class="line">  <span class="comment">// 如果相机的一些属性发生了变化，需要执行updateProjectionMatrix ()方法更新相机的投影矩阵</span></span><br><span class="line">  camera.<span class="property">updateProjectionMatrix</span> ();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>正交相机自适应</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onresize</span>=<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="comment">// 重置渲染器输出画布canvas尺寸</span></span><br><span class="line">  renderer.<span class="title function_">setSize</span>(<span class="variable language_">window</span>.<span class="property">innerWidth</span>,<span class="variable language_">window</span>.<span class="property">innerHeight</span>);</span><br><span class="line">  <span class="comment">// 重置相机投影的相关参数</span></span><br><span class="line">  k = <span class="variable language_">window</span>.<span class="property">innerWidth</span>/<span class="variable language_">window</span>.<span class="property">innerHeight</span>;<span class="comment">//窗口宽高比</span></span><br><span class="line">  camera.<span class="property">left</span> = -s*k;</span><br><span class="line">  camera.<span class="property">right</span> = s*k;</span><br><span class="line">  camera.<span class="property">top</span> = s;</span><br><span class="line">  camera.<span class="property">bottom</span> = -s;</span><br><span class="line">  <span class="comment">// 渲染器执行render方法的时候会读取相机对象的投影矩阵属性projectionMatrix</span></span><br><span class="line">  <span class="comment">// 但是不会每渲染一帧，就通过相机的属性计算投影矩阵(节约计算资源)</span></span><br><span class="line">  <span class="comment">// 如果相机的一些属性发生了变化，需要执行updateProjectionMatrix ()方法更新相机的投影矩阵</span></span><br><span class="line">  camera.<span class="property">updateProjectionMatrix</span> ();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="九、精灵模型Sprite"><a href="#九、精灵模型Sprite" class="headerlink" title="九、精灵模型Sprite"></a>九、精灵模型Sprite</h3><h5 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h5><ul><li>应用：<ul><li>大数据可视化</li><li>下雨效果</li></ul></li><li>渲染效果:无论相机如何变化，始终平行于桌面矩形区域，等价于一个正面永远朝向屏幕的PlaneGeometry。</li><li>相比与网格模型等，精灵模型只需要材质属性，而不需要几何体参数。</li></ul><h5 id="精灵模型实现下雨"><a href="#精灵模型实现下雨" class="headerlink" title="精灵模型实现下雨"></a>精灵模型实现下雨</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加载雨滴纹理贴图</span></span><br><span class="line"><span class="keyword">var</span> textureTree = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">TextureLoader</span>().<span class="title function_">load</span>(<span class="string">&quot;rain.png&quot;</span>);</span><br><span class="line"><span class="comment">// 创建一个组表示所有的雨滴</span></span><br><span class="line"><span class="keyword">var</span> group = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Group</span>();</span><br><span class="line"><span class="comment">// 批量创建雨滴精灵模型</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">400</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> spriteMaterial = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">SpriteMaterial</span>(&#123;</span><br><span class="line">    <span class="attr">map</span>: textureTree, <span class="comment">//设置精灵纹理贴图</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 创建精灵模型对象</span></span><br><span class="line">  <span class="keyword">var</span> sprite = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Sprite</span>(spriteMaterial);</span><br><span class="line">  group.<span class="title function_">add</span>(sprite);</span><br><span class="line">  <span class="comment">// 控制精灵大小,</span></span><br><span class="line">  sprite.<span class="property">scale</span>.<span class="title function_">set</span>(<span class="number">8</span>, <span class="number">10</span>, <span class="number">1</span>); <span class="comment">//// 只需要设置x、y两个分量就可以</span></span><br><span class="line">  <span class="keyword">var</span> k1 = <span class="title class_">Math</span>.<span class="title function_">random</span>() - <span class="number">0.5</span>;</span><br><span class="line">  <span class="keyword">var</span> k2 = <span class="title class_">Math</span>.<span class="title function_">random</span>() - <span class="number">0.5</span>;</span><br><span class="line">  <span class="comment">// 设置精灵模型位置，在一个长方体空间中随机分布</span></span><br><span class="line">  sprite.<span class="property">position</span>.<span class="title function_">set</span>(<span class="number">200</span> * k1, <span class="number">200</span> * <span class="title class_">Math</span>.<span class="title function_">random</span>(), <span class="number">200</span> * k2)</span><br><span class="line">&#125;</span><br><span class="line">scene.<span class="title function_">add</span>(group);<span class="comment">//雨滴群组插入场景中</span></span><br></pre></td></tr></table></figure><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><p><a href="https://alligator.io/react/react-with-threejs">https://alligator.io/react/react-with-threejs</a><br><a href="https://github.com/react-spring/react-three-fiber">https://github.com/react-spring/react-three-fiber</a><br><a href="https://github.com/zrysmt/react-threejs-app">https://github.com/zrysmt/react-threejs-app</a><br><a href="https://github.com/chenjsh36/ThreeJSForFun">https://github.com/chenjsh36/ThreeJSForFun</a><br><a href="http://www.yanhuangxueyuan.com/Three.js/">http://www.yanhuangxueyuan.com/Three.js/</a><br><a href="https://wow.techbrood.com/fiddle/new">https://wow.techbrood.com/fiddle/new</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Three.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大脑Cache系列 -- Java快速梳理，方便随时load到大脑，减少低级bug（三）</title>
      <link href="/2022/01/27/%E5%A4%A7%E8%84%91Cache%E7%B3%BB%E5%88%97-Java%E5%BF%AB%E9%80%9F%E6%A2%B3%E7%90%86%EF%BC%8C%E6%96%B9%E4%BE%BF%E9%9A%8F%E6%97%B6load%E5%88%B0%E5%A4%A7%E8%84%91%EF%BC%8C%E5%87%8F%E5%B0%91%E4%BD%8E%E7%BA%A7bug%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2022/01/27/%E5%A4%A7%E8%84%91Cache%E7%B3%BB%E5%88%97-Java%E5%BF%AB%E9%80%9F%E6%A2%B3%E7%90%86%EF%BC%8C%E6%96%B9%E4%BE%BF%E9%9A%8F%E6%97%B6load%E5%88%B0%E5%A4%A7%E8%84%91%EF%BC%8C%E5%87%8F%E5%B0%91%E4%BD%8E%E7%BA%A7bug%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><blockquote><ul><li>Java程序常常会遇到一些蛋疼的bug，最后发现，都是在一些很基础的方面造成的。大量的时间花在调试代码找低级bug上是十分没有性价比的。所以，再系统梳理下Java，是十分必要的。</li><li>已经反复学习和使用Java多次了，但只要有段时间没用Java之后，每次使用前都想要重头再梳理一遍。本文章将更注重Java只是的系统性，而不是细节性。</li><li>本文是本人大脑的专属Cache，所以逻辑上可能只有我自己能够看懂，见谅。</li></ul></blockquote><h3 id="一、目录"><a href="#一、目录" class="headerlink" title="一、目录"></a>一、目录</h3><ul><li>Java泛型</li><li>Java集合</li><li>Java部署</li></ul><span id="more"></span><h3 id="Java泛型"><a href="#Java泛型" class="headerlink" title="Java泛型"></a>Java泛型</h3><ul><li>在不支持泛型之前，Java是通过继承实现对不同类型数据的支持，缺点是每次都需要进行格式转换</li><li>泛型：<strong>类型参数</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 泛型类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T, U&gt; &#123; <span class="comment">// 类型参数，支持多个</span></span><br><span class="line">  <span class="keyword">private</span> T first;</span><br><span class="line">  <span class="keyword">private</span> T second;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 泛型方法，</span></span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getFirst</span><span class="params">()</span> &#123; <span class="comment">// 类型参数放在修饰符后边，返回类型前边 </span></span><br><span class="line">    <span class="keyword">return</span> first;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>泛型方法可以定义在泛型类中，也可以定义在普通类中</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pair</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> first;</span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getFirst</span><span class="params">()</span>&#123; <span class="comment">// 泛型方法可以定义在普通类中</span></span><br><span class="line">    <span class="keyword">return</span> first;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>类型变量的限定</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pair</span> &lt;T <span class="keyword">extends</span> <span class="title class_">BindType1</span> &amp; BindType2&gt; <span class="comment">// T必须是绑定类型的子类，对类型变量做了限定</span></span><br></pre></td></tr></table></figure><h5 id="泛型的虚拟机实现——类型擦除"><a href="#泛型的虚拟机实现——类型擦除" class="headerlink" title="泛型的虚拟机实现——类型擦除"></a>泛型的虚拟机实现——类型擦除</h5><ul><li><strong>虚拟机中并没有泛型类的对象，所有的对象都属于普通类</strong></li><li><strong>类型擦除</strong><ul><li><strong>原始类型</strong>：每一个泛型类型，都提供一个相应的原始类型。</li><li>原始类型名为泛型类删除类型参数</li><li>擦除类中的类型变量，替换为限定类型(第一个限定类型)，没有限定则为Object类型</li><li>比如Pair<T>类的原始类型为<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pair</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> Object first;</span><br><span class="line">  <span class="keyword">private</span> Object <span class="title function_">getFirst</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> first;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li>程序调用泛型方法的时候，在虚拟机层面实际执行两条指令，多出来的一条为插入的类型转换指令，目的是回复擦除的类型。<ul><li>多出来的虚拟机指令是编译器添加的，在字节码中添加</li></ul></li></ul><h5 id="泛型的注意点"><a href="#泛型的注意点" class="headerlink" title="泛型的注意点"></a>泛型的注意点</h5><ul><li><strong>不能用基本类型作为类型参数</strong>，比如int,double，而要改用Integer，Double</li><li><strong>不对泛型类型对象做类型检查</strong><ul><li><strong>getClass返回的总是原始类型，而不是泛型类型</strong></li><li>同样的**a instanceof Pair<String>**，编译错误</li></ul></li><li><strong>不能实例化创建参数化类型的数组</strong><ul><li><code>Pair&lt;String&gt; [] table = new Pair&lt;String&gt;[10]; // error</code></li></ul></li></ul><h5 id="泛型类型的继承规则"><a href="#泛型类型的继承规则" class="headerlink" title="泛型类型的继承规则"></a>泛型类型的继承规则</h5><ul><li><code>Pair&lt;Employee&gt;</code>和<code>Pair&lt;Manager&gt;</code>之间没有继承关系。</li></ul><h3 id="Java集合框架"><a href="#Java集合框架" class="headerlink" title="Java集合框架"></a>Java集合框架</h3><ul><li>传统的支持：Vector,Stack,HashTable,BitSet,Enumeration接口等</li></ul><h5 id="Java集合框架将集合的接口与实现分离"><a href="#Java集合框架将集合的接口与实现分离" class="headerlink" title="Java集合框架将集合的接口与实现分离"></a>Java集合框架将集合的接口与实现分离</h5><ul><li>队列接口Queue(interface)<ul><li>队尾添加元素，队头删除元素，先进先出，且能够获得队列元素数目</li><li>接口方法：add(E element),remove(),size()</li><li>集合实现这个接口就可以实现一个队列</li></ul></li><li>Collection集合接口<ul><li>Java集合类的<strong>基本接口</strong>，主要有两个重要的方法</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Collection</span>&lt;E&gt; &#123;</span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E element)</span>; <span class="comment">// 添加元素，不允许重复</span></span><br><span class="line">  Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span>; <span class="comment">// 返回实现了迭代器接口的对象，通过该迭代器对象可以依次访问集合中的元素</span></span><br><span class="line">  <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>; <span class="comment">// 返回元素数目</span></span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>; </span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object obj)</span>; <span class="comment">// 集合中是否存在该元素</span></span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object obj)</span>; <span class="comment">// 如果存在obj，则删除</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>; <span class="comment">// 情况集合内容</span></span><br><span class="line">  Object[] toArray(); <span class="comment">// 将集合转化为数组</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>迭代器Iterator<ul><li>for each循环需要集合实现iterator接口</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">  <span class="comment">// 类比编辑软件的光标、插入以及删除效果</span></span><br><span class="line">  E <span class="title function_">next</span><span class="params">()</span>; <span class="comment">// 越过当前元素，迭代到下一个（光标后移），并返回越过元素的内容</span></span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span>; <span class="comment">// 判断是否能够越过当前元素</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span>; <span class="comment">// 删除光标之前的元素</span></span><br><span class="line">  <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> E&gt; action)</span>; <span class="comment">// Java8</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用,比如foreach的实际实现</span></span><br><span class="line">Collection&lt;String&gt; str = ...</span><br><span class="line">Iterator&lt;String&gt; iter = str.iterator();</span><br><span class="line"><span class="keyword">while</span>(iter.hasNext())&#123;</span><br><span class="line">  <span class="type">String</span> <span class="variable">element</span> <span class="operator">=</span> iter.next();</span><br><span class="line">  dosomething...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Java8中直接通过forEachRemaining和lamabda表达式实现</span></span><br><span class="line">itertor.forEachRemaining(element -&gt; &#123;</span><br><span class="line">  <span class="keyword">do</span> something with element</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li><p>元素的迭代顺序由具体的集合来决定</p></li><li><p>与C++中的迭代器不同（基于索引下标，不需要查找操作，直接通过索引i++），Java中的迭代器是<strong>查找操作与位置变更是紧密相连的，查找一个元素的唯一方法是调用next(),在执行查找操作的同时，迭代器已经就指向下一个元素了，返回上一个元素</strong></p></li><li><p><strong>next和remove方法的调用具有互相依赖性，在调用remove之前，如果没有调用next，将会抛出一个非法异常</strong></p></li><li><p><strong>删除两个相邻的元素的元素不能直接连续remove，必须调用next越到下一个元素</strong></p></li><li><p>Java集合框架中各种集合接口的关系</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- Iterable        可迭代接口</span><br><span class="line">  - Collection    集合类的基础类</span><br><span class="line">    - List        有序集合，能够有序访问和随机访问</span><br><span class="line">    - Set </span><br><span class="line">      - SortSet</span><br><span class="line">    - Queue</span><br><span class="line">      - Deque</span><br><span class="line">- Map             key value 映射</span><br><span class="line">  - SortedMap</span><br><span class="line">- Iterator</span><br><span class="line">  - ListIterator  针对于List的迭代器</span><br></pre></td></tr></table></figure><h5 id="Java中的具体集合类"><a href="#Java中的具体集合类" class="headerlink" title="Java中的具体集合类"></a>Java中的具体集合类</h5><ul><li>以Map结尾的都实现了Map接口，没有的都实现了Collection接口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- AbstractCollection</span><br><span class="line">  - AbstractList        有序集合</span><br><span class="line">    - ArrayList         支持动态增长和缩减的索引序列</span><br><span class="line">    - LinkedList        链表类，支持高效插入和删除</span><br><span class="line">  - AbstractSet         数学中的集合，没有重复元素</span><br><span class="line">    - HashSet           没有重复元素的无序集合</span><br><span class="line">      - LinkedHashSet   可以记住元素插入顺序的集合</span><br><span class="line">    - TreeSet           有序集合</span><br><span class="line">    - EnumSet           包含枚举类型值的集合</span><br><span class="line">  - AbstractQueue</span><br><span class="line">    - PriorityQueue     优先级队列，高效删除最小元素的集合</span><br><span class="line">    - ArrayDequeue      循环数组实现的双端队列</span><br><span class="line">- AbstractMap           映射表</span><br><span class="line">  - HashMap             普通常用的键值对</span><br><span class="line">    - LinkedHashMap     在能记录键值对的添加次序</span><br><span class="line">  - TreeMap             键值有序排列</span><br><span class="line">  - EnumMap             键值为枚举类型的映射表</span><br><span class="line">  - WeakHashMap         一种当其值无用武之地的时候，可以被垃圾回收器回收的引射表</span><br><span class="line">  - IdentityHashMap     一种用===而不是queals比较键值的映射表</span><br></pre></td></tr></table></figure><h5 id="链表LinkedList"><a href="#链表LinkedList" class="headerlink" title="链表LinkedList"></a>链表LinkedList</h5><ul><li>数组Array和数组列表类对象ArrayList有个缺陷，在数组中间位置添加和删除的代价很大</li><li>Java的链表实际上是<strong>双向链表</strong>，有找到前向和后继的引用</li><li>链表实现了Collection接口，但Collection接口的add()方法只支持向链表最后添加元素，不支持链表的任意位置添加元素</li><li>在中间位置插入元素，通过ListIterator接口提供的方法实现。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 面向LinkedList链表的迭代器</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ListIterator</span> <span class="keyword">extends</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E element)</span>; <span class="comment">// 链表的插入方式，在当前迭代位置后加入一个元素</span></span><br><span class="line">  ...</span><br><span class="line">  E <span class="title function_">previous</span><span class="params">()</span>; <span class="comment">// 反向遍历链表，访问上一个元素</span></span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">hasPrevious</span><span class="params">()</span>; <span class="comment">// 与hasNext()类似</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用链表，并从中间加入元素</span></span><br><span class="line">List&lt;String&gt; staff = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">staff.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">staff.add(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">staff.add(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">ListIterator&lt;String&gt; iter = staff.listIterator();</span><br><span class="line">iter.next(); <span class="comment">// 跳过第一个元素，没有next的话，就是作为链表头</span></span><br><span class="line">iter.add(<span class="string">&quot;2&quot;</span>); <span class="comment">// 最终的结果，1234</span></span><br><span class="line"><span class="comment">// n长度的链表，有n+1个插入位置</span></span><br><span class="line">|ABC</span><br><span class="line">A|BC</span><br><span class="line">AB|C</span><br><span class="line">ABC|</span><br><span class="line"><span class="comment">// 链表提供了一个set()方法来替换值，不用先删除再添加了</span></span><br><span class="line">ListIteartor&lt;String&gt; iter = <span class="keyword">new</span> <span class="title class_">ListIteartor</span>&lt;&gt;();</span><br><span class="line"><span class="type">String</span> <span class="variable">oldValue</span> <span class="operator">=</span> iter.next(); <span class="comment">// 得到第一个元素</span></span><br><span class="line">iter.set(newvalue); <span class="comment">// 将第一个元素赋予新值</span></span><br></pre></td></tr></table></figure><ul><li>可以创建多个链表迭代器，比如用于并发，但是同时只能有一个迭代器用来修改链表集合，其他迭代器只能读取，多个迭代器同时修改会抛出异常。</li><li>链表作为一个List，也是支持有序访问和通过索引访问的的，但对于链表不推荐使用get(i)和set(i,value)</li></ul><h5 id="数组列表ArrayList"><a href="#数组列表ArrayList" class="headerlink" title="数组列表ArrayList"></a>数组列表ArrayList</h5><ul><li>有序列表，动态扩展和收缩</li><li>ArrayList不是同步的，是线程不安全的，适合在非并发的时候使用</li><li>Vector是同步的，线程安全的，但是同步操作上会耗费大量的时间，只在并发的时候使用</li></ul><h5 id="散列集HashSet"><a href="#散列集HashSet" class="headerlink" title="散列集HashSet"></a>散列集HashSet</h5><ul><li>不关注元素的顺序，只想要能够快速查找到元素，且无重复元素的集合Set</li><li>通过散列表来实现，散列表为每个对象计算一个散列码HashCode，对象的hashCode()方法在这个时候使用</li><li>装填因子，散列函数，桶，散列冲突等概念</li><li>对散列集的遍历顺序是随机的</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; words = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();</span><br><span class="line">words.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">Iterator&lt;String&gt; iter = words.iterator();</span><br><span class="line">iter.hasNext();</span><br><span class="line"><span class="type">String</span> <span class="variable">word</span> <span class="operator">=</span> iter.next();</span><br></pre></td></tr></table></figure><h5 id="树集TreeSet"><a href="#树集TreeSet" class="headerlink" title="树集TreeSet"></a>树集TreeSet</h5><ul><li>有序集合，内部是树结构，按照树的顺序进行遍历（红黑树）</li><li>每次添加元素，都将元素添加到树中的正确位置。</li></ul><h5 id="队列Queue与双端队列ArrayDeque"><a href="#队列Queue与双端队列ArrayDeque" class="headerlink" title="队列Queue与双端队列ArrayDeque"></a>队列Queue与双端队列ArrayDeque</h5><ul><li>Queue</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 队尾添加</span></span><br><span class="line">- <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E element)</span> </span><br><span class="line">- <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E element)</span> </span><br><span class="line"><span class="comment">// 对首删除并返回</span></span><br><span class="line">- E <span class="title function_">remove</span><span class="params">()</span></span><br><span class="line">- E <span class="title function_">poll</span><span class="params">()</span></span><br><span class="line"><span class="comment">// 只返回对首元素，不删除</span></span><br><span class="line">- E <span class="title function_">element</span><span class="params">()</span></span><br><span class="line">- E <span class="title function_">peek</span><span class="params">()</span></span><br></pre></td></tr></table></figure><ul><li>Deque</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(E element)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(E element)</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">offerFirst</span><span class="params">(E element)</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">offerLast</span><span class="params">(E element)</span></span><br><span class="line">E <span class="title function_">removeFirst</span><span class="params">()</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><h5 id="优先级队列PriorityQueue"><a href="#优先级队列PriorityQueue" class="headerlink" title="优先级队列PriorityQueue"></a>优先级队列PriorityQueue</h5><ul><li>支持任意顺序的插入，而每次remove，返回的都是队列中的最小值</li><li>内部通过堆来实现，是一个能够自我调整的二叉树，在对树进行add和remove操作中，能始终保证最小的元素移动到根</li><li>优先级队列用于任务调度</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// E 必须是支持比较的元素类型</span></span><br><span class="line">PriorityQueue&lt;E&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">queue.add(element1); <span class="comment">// 按照随机顺序加入，自动调整排序</span></span><br><span class="line">queue.add(element2);</span><br><span class="line">queue.add(element3);</span><br><span class="line"><span class="type">E</span> <span class="variable">min</span> <span class="operator">=</span> queue.remove(); <span class="comment">// 返回最小值</span></span><br></pre></td></tr></table></figure><h5 id="映射Map"><a href="#映射Map" class="headerlink" title="映射Map"></a>映射Map</h5><ul><li>HashSet是以对象副本来查找元素，不好用</li><li>映射通过键值对来查找元素</li><li>有<code>HashMap</code>和<code>TreeMap</code>两种<ul><li><code>HashMap</code>，通过对键进行散列，进而访问值</li><li><code>TreeMap</code>，利用键的顺序，对元素进行排序</li></ul></li><li>和集合一样，散列稍微快一些，如果不需要按照排列顺序访问键，推荐使用散列映射</li><li>Map的键使用的是字符串</li><li>添加键值对：<code>V put(K key,V value)</code><ul><li>重复用同一个key添加，会覆盖之前添加的值,返回之前的值</li><li>添加一个新的键，返回的值为null</li></ul></li><li>查找键值对:<code>V get(Object key)</code><ul><li>如果不存在该key，则返回null</li><li><code>V getOrDefault(Object key, V defaultValue)</code></li></ul></li><li>删除键值对：<code>remove(Object key)</code></li><li>判断是否有键：<code>boolean containsKey(Object key)</code></li><li>判断是否有值：<code>boolean containerValue(Object value)</code></li><li>遍历键值对：<code>hashMap.forEach((k,v)=&#123;do...&#125;)</code></li><li>三个视图View: keySet,valueSet,entrySet</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;String,E&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,E&gt;();</span><br><span class="line">hashMap.put(<span class="string">&quot;first&quot;</span>,element1);</span><br><span class="line">hashMap.put(<span class="string">&quot;second&quot;</span>,element2);</span><br><span class="line">hashMap.get(<span class="string">&quot;first&quot;</span>);</span><br><span class="line">Set&lt;String&gt; keySet = hashMap.keySet();<span class="comment">// &#123;first,second&#125;</span></span><br><span class="line">Set&lt;E&gt; valueSet = hashMap.valueSet();</span><br><span class="line">Set&lt;Map.Entry&lt;String,E&gt;&gt; entrySet = hashMap.entrySet();</span><br></pre></td></tr></table></figure><h5 id="弱散列集合WeakHashMap"><a href="#弱散列集合WeakHashMap" class="headerlink" title="弱散列集合WeakHashMap"></a>弱散列集合WeakHashMap</h5><ul><li>能够自动回收那些无用的键值对</li><li>如果有一个值，对应的键已经不再使用了，那么该键值对将无法从Map中删除</li><li>对于长期存活的Map，需要手动删除，或者直接使用WeakHashMap</li><li>内部实现中，WeakHashMap使用的弱引用(wek references)来保存键。<ul><li>弱引用对象将引用保存到另外一个对象中，在这里，就是散列键</li><li>如果某个对象，只有WeakReference引用，那么垃圾回收器可以回收它。</li></ul></li></ul><h5 id="链接散列集与映射LinkedHashSet与LinkedHashMap"><a href="#链接散列集与映射LinkedHashSet与LinkedHashMap" class="headerlink" title="链接散列集与映射LinkedHashSet与LinkedHashMap"></a>链接散列集与映射LinkedHashSet与LinkedHashMap</h5><ul><li>在实现HashSet与HashMap的基础上，还能够记录元素的添加顺序，即迭代遍历顺序</li><li>实现方式是在Hash表的基础上，再通过链表的方式将添加的元素顺序链接起来。</li></ul><h5 id="枚举集与映射EnumSet"><a href="#枚举集与映射EnumSet" class="headerlink" title="枚举集与映射EnumSet"></a>枚举集与映射EnumSet</h5><ul><li>如果key的类型为枚举，那么可以使用EnumSet</li><li>使用位序列进行了优化</li></ul><h5 id="表示散列映射IdentityHashMap"><a href="#表示散列映射IdentityHashMap" class="headerlink" title="表示散列映射IdentityHashMap"></a>表示散列映射IdentityHashMap</h5><ul><li>特殊用途：<strong>对象遍历算法</strong></li><li>hash计算不再通过对象的hashCode计算，而是通过System.identityHashCode计算，返回的是根据对象的内存地址计算的Hash值</li><li>所以不能用equal()来判断相等了，而是用&#x3D;&#x3D;号来判断</li><li><strong>不同的键值对，即便内容一样，也被视为不一样的对象</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 大脑Cache </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[bug] Build React 项目中出现的Failed to minify the code from this file错误</title>
      <link href="/2022/01/14/bug-Build-React-%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84Failed-to-minify-the-code-from-this-file%E9%94%99%E8%AF%AF/"/>
      <url>/2022/01/14/bug-Build-React-%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84Failed-to-minify-the-code-from-this-file%E9%94%99%E8%AF%AF/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在React项目中运用到了flv.js以及three.js，通过yarn安装依赖，在开发环境下一切正常，但当执行yarn build打生产环境包时，出现了如下错误。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Failed</span> to minify the code <span class="keyword">from</span> <span class="variable language_">this</span> <span class="attr">file</span>:</span><br><span class="line">./node_modules/flv.<span class="property">js</span>/src/utils/logger.<span class="property">js</span>:<span class="number">21</span></span><br></pre></td></tr></table></figure><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>问题出在了库的引入上，原本代码为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> flv.<span class="property">js</span> <span class="keyword">from</span> <span class="string">&#x27;flv.js&#x27;</span>;</span><br></pre></td></tr></table></figure><p>更改为</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> flv.<span class="property">js</span> <span class="keyword">from</span> <span class="string">&#x27;flv.js/dist/flv.min.js&#x27;</span>;</span><br></pre></td></tr></table></figure><p>然后build就可以通过</p><span id="more"></span><h3 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h3><p>用到的第三方软件包没有被正确编译成ES5<br>解决方法</p><ul><li>去项目站点提issue，让第三方软件包开发人员提供pre-compiled</li><li>自己编译，然后上传</li><li>将第三方库code直接复制到项目中使用（如果代码比较少的话）</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>解这个bug花了不小的时间，主要还是对React的打包过程和机制还不是很了解，有时间进一步了解一下。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUG </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大脑Cache系列 -- Java快速梳理，方便随时load到大脑，减少低级bug（二） </title>
      <link href="/2022/01/06/%E5%A4%A7%E8%84%91Cache%E7%B3%BB%E5%88%97-Java%E5%BF%AB%E9%80%9F%E6%A2%B3%E7%90%86%EF%BC%8C%E6%96%B9%E4%BE%BF%E9%9A%8F%E6%97%B6load%E5%88%B0%E5%A4%A7%E8%84%91%EF%BC%8C%E5%87%8F%E5%B0%91%E4%BD%8E%E7%BA%A7bug%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2022/01/06/%E5%A4%A7%E8%84%91Cache%E7%B3%BB%E5%88%97-Java%E5%BF%AB%E9%80%9F%E6%A2%B3%E7%90%86%EF%BC%8C%E6%96%B9%E4%BE%BF%E9%9A%8F%E6%97%B6load%E5%88%B0%E5%A4%A7%E8%84%91%EF%BC%8C%E5%87%8F%E5%B0%91%E4%BD%8E%E7%BA%A7bug%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><blockquote><ul><li>Java程序常常会遇到一些蛋疼的bug，最后发现，都是在一些很基础的方面造成的。大量的时间花在调试代码找低级bug上是十分没有性价比的。所以，再系统梳理下Java，是十分必要的。</li><li>已经反复学习和使用Java多次了，但只要有段时间没用Java之后，每次使用前都想要重头再梳理一遍。本文章将更注重Java只是的系统性，而不是细节性。</li><li>本文是本人大脑的专属Cache，所以逻辑上可能只有我自己能够看懂，见谅。</li></ul></blockquote><h3 id="一、目录"><a href="#一、目录" class="headerlink" title="一、目录"></a>一、目录</h3><ul><li>Java继承</li><li>Java反射</li><li>Java接口</li><li>Lambda表达式</li><li>Java异常</li></ul><span id="more"></span><h3 id="二、Java继承"><a href="#二、Java继承" class="headerlink" title="二、Java继承"></a>二、Java继承</h3><h5 id="Java与C-继承"><a href="#Java与C-继承" class="headerlink" title="Java与C++继承"></a>Java与C++继承</h5><ul><li>子类 extends 父类，而C++是：符号</li><li>Java只有公有继承，C++有公有继承和私有继承</li><li>Java只支持单继承，多继承通过接口实现</li><li>子类从父类继承所有的数据域和方法，但有一些不一定能够访问到。</li><li>此外，子类只能通过覆盖来修改，以及增加方法，但绝对无法删除父类的任何方法和数据域。</li></ul><h5 id="覆盖方法"><a href="#覆盖方法" class="headerlink" title="覆盖方法"></a>覆盖方法</h5><ul><li>覆盖：子类方法重写父类的方法，父类方法将会被覆盖，区别重载（本类方法之间）</li><li>覆盖时，子类和父类要严格一致（访问类型，返回值，方法名，参数列表）<ul><li>可以通过@Override来对子类的覆盖方法进行标记，来保障子类该方法成功覆盖了一个父类的方法，而不是定义了一个毫无相关的方法（没有匹配父类方法的时候，会编译报错）</li></ul></li><li>被覆盖的父类方法依然可以通过super方法调用。</li><li>super并不是像this那样是一个对象引用，<strong>super只是一个指示编译器调用父类方法的特殊关键字，所以不能将super赋值给另一个变量。</strong></li><li>super()调用父类的构造器</li></ul><h5 id="多态与动态绑定"><a href="#多态与动态绑定" class="headerlink" title="多态与动态绑定"></a>多态与动态绑定</h5><ul><li>多态：父类对象变量可以引用子类对象，且能够通过父类对象正确调用该对象的方法。</li><li>动态绑定：在运行时，能够自动选择调用哪个方法。</li><li>用途：有一组不同类型的对象数据，可以直接通过他们父类类型的数组来统一组织</li><li>不能将父类引用赋值给子类变量，但是可以将子类引用赋值给父类对象，且不需要强制类型转换。</li></ul><h5 id="方法调用的过程"><a href="#方法调用的过程" class="headerlink" title="方法调用的过程"></a>方法调用的过程</h5><ul><li><strong>对象在调用方法的时候，除了方法显式的参数之外，还有一个隐式参数，那便是对象本身，隐式参数不属于函数签名</strong></li><li>1.根据方法名，选出本类和父类中所有候选方法（父类中的方法需要是public的）</li><li>2.根据参数列表，进行重载解析，获得调用方法名字和参数类型，即函数签名（考虑子类覆盖父类）</li><li>3.如果该方法是private、static、final、或者构造器，那么编辑器就可以确定调用哪个方法了，这个称为静态绑定</li><li>4.可能存在多态的情况时，虚拟机会考虑到隐式参数对象的实际类型，选择调用对应类中的方法。依次实现运行时的动态绑定。</li></ul><h5 id="阻止继承-final类和方法"><a href="#阻止继承-final类和方法" class="headerlink" title="阻止继承 final类和方法"></a>阻止继承 final类和方法</h5><ul><li>final类，不允许被继承</li><li>final方法，子类不允许覆盖这个方法，final类中的所有方法都是final的。</li></ul><h5 id="对象强制类型转换"><a href="#对象强制类型转换" class="headerlink" title="对象强制类型转换"></a>对象强制类型转换</h5><ul><li>只能在继承链上进行类型转换</li><li>在将父类转成子类之前，最好使用instanceof检查是否转换错误</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(child <span class="keyword">instanceof</span> Manager)&#123; <span class="comment">// 不需要判null</span></span><br><span class="line">  manager = child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在一些参数传递的时候可能会使用</li></ul><h5 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h5><ul><li>为了进一步提升父类的通用能力</li><li>抽象类：含有一个或者多个抽象方法的类，就是抽象类<ul><li>抽象类和抽象方法需要使用abstract来修饰</li><li>抽象类中是可以存在具体数据和具体方法的，可以存在一个抽象方法</li></ul></li><li>抽象类是可以不包含抽象方法的</li><li><strong>抽象类不能被实例化</strong>，必须通过子类实现所有的抽象方法才可以。</li><li>虽然抽象类不能实例化，但可以通过抽象类变量引用子类对象（这是正常的父类子类特点）。</li></ul><h5 id="受保护的访问"><a href="#受保护的访问" class="headerlink" title="受保护的访问"></a>受保护的访问</h5><ul><li>private：仅对本类可见</li><li>public：对所有类可见，无限制</li><li>protected：对本类和子类，以及本包类可见<ul><li><strong>如果想一个方法或者数据能够被子类访问，需要设置protected修饰符</strong></li></ul></li><li>默认情况：对本包类可见，<strong>对子类不可见</strong></li></ul><table><thead><tr><th align="center">修饰符</th><th align="center">本类</th><th align="center">本包</th><th align="center">子类</th><th align="center">其他包</th></tr></thead><tbody><tr><td align="center">public</td><td align="center">yes</td><td align="center">yes</td><td align="center">yes</td><td align="center">yes</td></tr><tr><td align="center">private</td><td align="center">yes</td><td align="center">no</td><td align="center">no</td><td align="center">no</td></tr><tr><td align="center">protected</td><td align="center">yes</td><td align="center">yes</td><td align="center">yes</td><td align="center">no</td></tr><tr><td align="center">default</td><td align="center">yes</td><td align="center">yes</td><td align="center"><strong>no</strong></td><td align="center">no</td></tr></tbody></table><h5 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h5><ul><li>所有类的超类</li><li>Java中只有基本类型不是对象，其他都是对象，都具有Object的方法和数据</li><li>equals():<ul><li><strong>在没重写的情况下，与&#x3D;&#x3D;的效果是一致的，判断的是地址而不是实际的内容。</strong></li><li>String，Integer等类已经对equals()进行重写了。</li><li>我们在实现自己类的时候，需要自己来实现equals。（在实现自己实现equals后，还需要实现hashcode）（很套路，很多IDE是支持一键自动生成的）</li></ul></li><li>Class getClass()：获得该对象所属于的类<ul><li>class.getName获得类名</li></ul></li><li>hashcode(): 返回对象的散列值<ul><li>规定：<strong>两个对象，如果equals为true，那么hashcode一定要保证相同</strong>，即相等的对象有相同的hashcode。</li><li>默认的的hashcode都是参考了存储地址的，所以两个对象，默认的hashcode一定不一样，即便他们值可能是一样的。</li><li>因此<strong>当自己实现equals的时候，对应的也要实现hashcode，来保证重要规则</strong></li><li><strong>两个相等的对象必须要返回相同的hashcode码，但是相等的hashcode不一定是相等的变量</strong>，（hashcode的计算方式）</li><li>java对象的hashcode设计是为了配合基于散列的集合,添加元素的时候，通过hashcode和equals来快速判断对象是否已经存在（大大减少了equals次数，比纯equals循环要好多了）</li></ul></li><li>toString():将对象以字符串形式输出，常用于日志之类。Object中默认的为类名+Hash值</li></ul><h5 id="重写equals-Object-obj-方法（了解即可，可以IDE自动生成的，hh）"><a href="#重写equals-Object-obj-方法（了解即可，可以IDE自动生成的，hh）" class="headerlink" title="重写equals(Object obj)方法（了解即可，可以IDE自动生成的，hh）"></a>重写equals(Object obj)方法（了解即可，可以IDE自动生成的，hh）</h5><ul><li>1.引用的是同一个对象吗</li><li>2.obj为null吗？</li><li>3.两个是同一个类吗</li><li>4.obj强制转化成本类</li><li>5.一次判断各个数据域是否相等</li><li><strong>记得还要检查下hashcode是否要也要重写哦</strong></li></ul><h5 id="泛型数组-ArrayList"><a href="#泛型数组-ArrayList" class="headerlink" title="泛型数组 ArrayList"></a>泛型数组 ArrayList<Type></h5><ul><li>普通数组无法再运行时更改数组的大小，可以使用泛型数组库，ArrayList</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;MyClass&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br></pre></td></tr></table></figure><ul><li>Java老版本中的Vector也可以实现动态数组，但没ArrayList有效。</li><li>add(),向数组中添加一个元素，如果容量不够，会自动扩展</li><li>ArrayList不支持数组的[]访问方式</li><li>get(index),获取数组中index位置的元素</li><li>set(index,item),替换数组中的某个元素</li><li>size()，类似数组的length</li><li>arrayList.ensureCapacity(100),预分配100大小的数组</li><li>trimToSize(),当保证不再向数组中添加元素了，调用将释放多余分配的空间</li><li>arrayList.toArray(array),为了方便数组的访问，可以通过ArrayList构造，然后转换成普通数组并处理</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一种很好的实践</span></span><br><span class="line">ArrayList&lt;X&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// add item to list</span></span><br><span class="line">X[] a = <span class="keyword">new</span> <span class="title class_">X</span>[list.size()];</span><br><span class="line">list.toArray(a);</span><br></pre></td></tr></table></figure><h5 id="对象包装器与自动装箱"><a href="#对象包装器与自动装箱" class="headerlink" title="对象包装器与自动装箱"></a>对象包装器与自动装箱</h5><ul><li>基本类型都有对应的类，Integer, Double,Boolean,Character，Void等</li><li>他们的超类为Number</li><li><strong>一旦包装器创建了，就不允许更改包装在其中的值了</strong></li><li>自动装箱和自动拆箱：能在基础类型和对应的类之间自动转换，这是由Java编译器实现的，添加了装箱拆箱语句</li><li><strong>Java的&#x3D;&#x3D;号检测的是两个变量指向的地址是否相同</strong>，所以不同于基础类型，装箱后要用equals方法来判断值是否相等（他们重写了equals方法）</li><li>字符串Int转换：<code>int x = Integer.paseInt(&quot;1&quot;)</code>或者<code>Integer.valueOf(&quot;100&quot;)</code></li></ul><h5 id="参数可变的方法"><a href="#参数可变的方法" class="headerlink" title="参数可变的方法"></a>参数可变的方法</h5><ul><li>Java方法的参数数目可以是可变的</li><li>省略号<code>...</code>,可以出现在参数列表的最后，<strong>其实和数组的效果的类似的</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(String fmt, Object...args);</span><br></pre></td></tr></table></figure><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><blockquote><p>Java反射机制能够在程序运行时，对于任意一个类，都能够知道这个类的所有属性和方法。对于任意一个对象，在有权限的情况下，能够调用方法和属性。即，动态获取信息以及动态调用对象方法的机制。</p></blockquote><ul><li>反射，能够分析类能力，能够动态操纵Java代码</li><li>主要用户工具构造，在实际的应用中使用不多(也不建议在应用应用开发中过多使用)</li><li>Class类，Java运行时系统为每个类维护一个Class类</li><li>getClass(),Name.class</li></ul><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><ul><li>抽象类是对类的抽象，而接口是对行为的抽象。</li><li><strong>接口中所有方法都自动是public，不需要额外加public修饰符（但在实现接口的类中，方法前必须加public）</strong></li><li>接口中<strong>不能含有实例域（接口没有实例）</strong>，但可以含有<strong>常量和静态常量</strong></li><li>对于方法，<strong>接口中不能提供实现</strong>（Java8后支持默认实现）</li><li>接口不是类，不能通过new被实例化成对象。</li><li>不存在接口实例化的对象，但是存在<strong>接口变量，且接口变量可以引用实现了它的类的对象</strong>。</li><li>接口支持继承另一个接口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparable</span> &#123; <span class="comment">// java.lang.Comparable</span></span><br><span class="line">  <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object obj)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Test <span class="keyword">implements</span> <span class="title class_">Comparable</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object obj)</span> &#123; <span class="comment">// 实现类时候，需要public</span></span><br><span class="line">    <span class="keyword">return</span> Double.compare(salary,obj.salary); <span class="comment">// 相减比较不适合浮点数</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>Java常用的内置接口</p><ul><li>Compalrable</li><li>Cloneable</li></ul></li><li><p>接口的意义在于统一服务的对外接口：Java是一种强类型语言，使用接口来解决类型的问题，编译器不需要再执行的时候进行类型检查（因为编译器认为只要这个类实现了这个接口，就一定能处理）</p></li><li><p>接口与继承（抽象类）</p><ul><li>Java不支持多继承，因为多继承会使语言更复杂</li><li>Java通过接口来实现多继承，一个类可以实现多个接口</li></ul></li><li><p>Java8之后，接口中可以存在静态方法并实现之了，目的是，这样就可以避免某些工具类必须要提供伴随类了。</p></li><li><p>默认方法：</p><ul><li>在我们实现接口的时候，很多时候只需要实现部分方法，默认方法为接口中的方法提供一个默认的实现。</li><li>用default修饰符，然后就可以在接口中简单实现这些方法了。</li></ul></li></ul><h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><ul><li>将一个代码块像参数一样传递到另一个对象中（定时器，响应等），这个代码块会在未来的某个时刻会被调用。</li><li>对比通过传入对象来实现，Lambda表达式更优雅，使得Java支持函数式编程。</li><li><code>(参数列表) -&gt; &#123;代码块&#125;</code>，Lambda没有返回类型</li><li><strong>函数式接口</strong>：只含有一个抽象方法的接口，可以把Lambda赋值给一个函数式接口变量</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface // 可选，用于编译检查是否只有一个抽象方法，类似Override</span><br><span class="line">public interface FunctionalInterface&lt;T&gt;&#123;</span><br><span class="line">void accept(T t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Lambda表达式可以转化为对应的接口形式</li><li>Lambda表达式实际上是一个<strong>函数</strong>，传入之后会在某处会被执行，而不是一个对象。</li><li>所以不能将一个Lambda表达式赋值给一个Object变量，因为Object不是一个函数式接口</li><li>当我们想使用Lambda的时候，需要为其提供一个函数式接口</li><li>方法引用:<code>rrays.sort(strings,String::compareToIgnoreCase)</code>,其实也很好理解，因为Lambda是函数</li><li>Comparator函数式接口</li></ul><h5 id="Lambda表达式的变量作用域"><a href="#Lambda表达式的变量作用域" class="headerlink" title="Lambda表达式的变量作用域"></a>Lambda表达式的变量作用域</h5><ul><li>Lambda中的变量<ul><li>代码块中声明的，自己的</li><li>参数传入的</li><li><strong>自由变量</strong>，如何保证Lambda执行的时候，这些外部的变量还存在，没有被销毁？</li></ul></li><li>捕获，闭包：Lambda会存储自由变量的值，称为捕获。Lambda的代码块以及自由变量组成一个<strong>闭包</strong></li><li><strong>Lambda中只能引用值不会改变的变量&#x2F;常量</strong></li><li><strong>Lambda的体和块有相同的作用域</strong>，所以块中不能定义与Lambda同一块中的已有变量。</li></ul><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><blockquote><p><a href="https://www.cnblogs.com/dolphin0520/p/3811445.html">博客</a></p></blockquote><h5 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h5><ul><li>定义在另一个类中的类。</li><li><strong>并不是每个外部类的对象实例都有一个内部类实例</strong>，内部类实例对象是由外部类的方法来触发创建的。</li><li>特点：<ul><li><strong>内部类可以访问外部类的实例域</strong>，因为内部类具有外部类的引用。<ul><li>访问的外部实例域必须是final，这个和Lambda类似。</li><li>内部类对象中有一个隐式引用，它指向创建它的外部类对象（在内部类的构造函数中记录）。</li></ul></li><li>局部内部类对同一个包中的其他类不可见</li><li>创建内部类的前提是必须先创建外部类</li></ul></li></ul><h5 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h5><ul><li>定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内。</li><li>和局部变量一样，不能有public、protected、private以及static修饰符的。</li></ul><h5 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h5><ul><li>只创建这个类的对象，但并没有为该类提供名字。</li><li>使用的最多，在编写事件监听的代码时使用匿名内部类不但方便，而且使代码更加容易维护。</li><li>一般只用在事件监听，接口回调等</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ActionListener</span> <span class="variable">listener</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AcitonListener</span>() &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actionPerformed</span><span class="params">(ActionEvent event)</span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>类似的，在安卓SDK，Swing中用的很多，能够简化代码。但有了Lambda，还能够更简化。</li></ul><h5 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h5><ul><li>多一个static关键字，不需要依附外部类而存在。</li></ul><h5 id="对比Lambda表达式和匿名内部类"><a href="#对比Lambda表达式和匿名内部类" class="headerlink" title="对比Lambda表达式和匿名内部类"></a>对比Lambda表达式和匿名内部类</h5><ul><li>匿名内部类仍然是类，编译会生成.class文件，Lambda通过invokedynamic指令插入到主类对应的位置执行</li><li>对于匿名类，关键词 this 解读为匿名类，而对于 Lambda 表达式，关键词 this 解读为写就 Lambda 的外部类。</li><li>Java 编译器编译 Lambda 表达式并将他们转化为类里面的私有函数</li></ul><h3 id="Java异常"><a href="#Java异常" class="headerlink" title="Java异常"></a>Java异常</h3><h5 id="异常层次结构"><a href="#异常层次结构" class="headerlink" title="异常层次结构"></a>异常层次结构</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- Throwable</span><br><span class="line">  - Error</span><br><span class="line">    - Java运行时系统内部错误，以及资源耗尽错误</span><br><span class="line">    - 应用程序无法抛出，由系统自动抛出，必然导致程序终止</span><br><span class="line">  - Exception</span><br><span class="line">    - IOExpection</span><br><span class="line">      - 与程序无关，而与IO等有关的错误</span><br><span class="line">    - RuntimeException</span><br><span class="line">      - 由程序本身错误导致的异常（数组越界，<span class="literal">null</span>指针，错误类型转换）</span><br></pre></td></tr></table></figure><h5 id="受查与非受查异常"><a href="#受查与非受查异常" class="headerlink" title="受查与非受查异常"></a>受查与非受查异常</h5><ul><li><strong>非受查异常</strong>：Error以及RuntimeException，不需要显示声明，因为这些异常是可以努力避免的，处理它们比消除它们要好多了。</li><li><strong>受查异常</strong>：IOException，<strong>编译器会检查程序是否为这类异常提供了异常处理器</strong>，需要在程序中显示声明</li><li>声明受查异常<ul><li>一个方法不仅可以告诉编译器参数和返回值，还可以告诉编译器可能存在的异常</li><li>什么时候需要给方法声明受查异常<ul><li>1.方法的内部调用了某个抛出受查异常的方法</li><li>2.方法内部通过throw抛出了一个受查异常</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明受查异常，是throws不是throw，因为可以是一个异常列表</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readFileFunc</span><span class="params">(File file)</span> <span class="keyword">throws</span> FileNotFoundException &#123; &#125;</span><br><span class="line"><span class="comment">// 抛出一个异常</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>();</span><br></pre></td></tr></table></figure><h5 id="异常捕获"><a href="#异常捕获" class="headerlink" title="异常捕获"></a>异常捕获</h5><ul><li>try-catch语句<ul><li>若try子句中没有异常则跳过catch子句，程序正常返回。</li><li>try子句中发生错误，终止try子句执行，<strong>程序无返回值</strong>。<ul><li>若catch子句能够捕获异常，则直接执行catch子句中的处理语句。</li><li>若catch子句无法捕获，则将该异常传递到上级调用方法来处理。</li></ul></li></ul></li><li>处理策略<ul><li>对于知道如何处理的受检异常，则直接捕获处理</li><li>对于不知道如何处理的受检异常，则传递到调用方进行处理</li><li>传递一个异常，需要在方法后添加<code>throws</code>关键字，告知调用方，提供需要的对应的异常处理器</li></ul></li><li>捕获多个异常</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125; <span class="keyword">catch</span>(FileNotFoundException e)&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125; <span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>再此抛出异常链，<code>e.initCause(pre_e)</code></li></ul><h5 id="finally子句"><a href="#finally子句" class="headerlink" title="finally子句"></a>finally子句</h5><ul><li>无论是否抛出异常，都会执行</li><li>finally子句中也可能抛出异常，最好将try-catch和try-finally解耦</li><li>当try和finally中都有return的时候，finally中的return先执行，且最终的返回值会被finally覆盖。即，如果finally中有return，try中的return无意义</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">try</span>&#123;  <span class="comment">// 内部try用于释放资源</span></span><br><span class="line">    ...</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    io.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOExpection)&#123;</span><br><span class="line">  <span class="comment">// error message</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>带资源的try，自动解决资源释放处理问题</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">Resource</span> <span class="variable">res</span> <span class="operator">=</span> ...)&#123;</span><br><span class="line">  res...</span><br><span class="line">&#125;<span class="comment">// 执行完毕之后，会自动调用res.close()</span></span><br></pre></td></tr></table></figure><h5 id="使用异常须知"><a href="#使用异常须知" class="headerlink" title="使用异常须知"></a>使用异常须知</h5><ul><li>异常的开销比较大，不要使用异常来实现正常的业务。只在异常情况下使用异常</li><li>不要过于细分异常</li><li>不要压制异常，便于分析程序错误</li></ul><h3 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h3><ul><li>断言机制允许在测试期间向代码中插入一些检查语句，代码发布之后，会自动移除</li><li>关键字，assert</li><li>一般用不到</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 大脑Cache </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大脑Cache系列--Java快速梳理，方便随时load到大脑，减少低级bug (一)</title>
      <link href="/2022/01/02/%E5%A4%A7%E8%84%91Cache%E7%B3%BB%E5%88%97--Java%E5%BF%AB%E9%80%9F%E6%A2%B3%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2022/01/02/%E5%A4%A7%E8%84%91Cache%E7%B3%BB%E5%88%97--Java%E5%BF%AB%E9%80%9F%E6%A2%B3%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><blockquote><ul><li>Java程序常常会遇到一些蛋疼的bug，最后发现，都是在一些很基础的方面造成的。大量的时间花在调试代码找低级bug上是十分没有性价比的。所以，再系统梳理下Java，是十分必要的。</li><li>已经反复学习和使用Java多次了，但只要有段时间没用Java之后，每次使用前都想要重头再梳理一遍。本文章将更注重Java知识的系统性，而不是细节性。</li><li>本文是本人大脑的专属Cache，所以逻辑上可能只有我自己能够看懂，见谅。</li></ul></blockquote><h3 id="一、目录"><a href="#一、目录" class="headerlink" title="一、目录"></a>一、目录</h3><ul><li>数据类型，字符串，数组</li><li>基础语句语法</li><li>类与对象</li></ul><span id="more"></span><h3 id="二、基础语法"><a href="#二、基础语法" class="headerlink" title="二、基础语法"></a>二、基础语法</h3><blockquote><ul><li>其实还是有很多基础知识，是自己平时写代码的时候没有注意到的，而这很容易导致一些低级bug，耗费大量的调试时间。</li></ul></blockquote><h5 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h5><ul><li>编译命令: javac Main.java，.java代码成为.class字节码。<ul><li>JIT编译器：编译与解释共存，JIT能够将热点代码直接编译成机器码，直接再JVM上执行。</li></ul></li><li>运行:java Main， JVM加载字节码，解释成机器码执行。</li><li>版本：java -version</li></ul><h5 id="8种基本类型"><a href="#8种基本类型" class="headerlink" title="8种基本类型"></a>8种基本类型</h5><ul><li>整数：byte(8)，short(16)，int(32)，long(64)</li><li>浮点：float(32)，double(64)</li><li>Unicode编码的char（16位，两个字节），相当于一个整型值（ASCII）</li><li>boolean（1）</li><li>因为JVM的存在，各数据类型的取值范围与具体的机器是无关的。</li><li>基础数据类型存储在栈中，不存储在堆上。</li></ul><h5 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h5><ul><li>java的整形均是有<strong>符号的</strong>，计算整型的数据范围</li><li>注意：在java中，为了保障移植性，<strong>整型的范围与实际的机器无关（C和C++中整型范围和目标平台是相关的）</strong>，JVM解决了不同机器整型之间的差别。</li><li>byte：1字节，一般很少用，用在底层文件处理，或者占用存储空间的大数组</li><li>short：2字节，和byte用处类似</li><li>int：4字节，最常用</li><li>long：8字节，比如需要表示星球上的居住人数，可以使用long，后缀可以加一个L或者l标识</li><li>更易读的整数方式：1_000_000, java编译器会自动去除这些下划线。</li></ul><h5 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h5><ul><li>float 4字节，有效位6-7位 </li><li>double 8字节，有效位15位</li><li><strong>默认为double，一般也很少用float（float的精度一般很难满足需求），除非在需要处理或者存储大量数据</strong></li><li>double后缀D或d，float后缀F或者f</li><li>特殊浮点数值（一般用不到）<ul><li>正无穷大：Double.POSITIVE_INFINITY</li><li>负无穷大: Double.NEGATIVE_INFINITY</li><li>非数字: Double.NaN, 判断用Double.isNaN(n),不能用 &#x3D;&#x3D; 号</li></ul></li></ul><h5 id="字符类型char"><a href="#字符类型char" class="headerlink" title="字符类型char"></a>字符类型char</h5><ul><li>Java的char采用Unicode编码</li><li>占用两个字节</li><li>‘A’,”A”的区别：前者是字符类型常量，占两个字节，后者是字符串常量，存储在堆上。</li></ul><h5 id="boolean"><a href="#boolean" class="headerlink" title="boolean"></a>boolean</h5><ul><li><strong>和C++不一样，整型和boolean之间不能相互转换</strong></li></ul><h5 id="大数值-BigInteger-BigDecimal"><a href="#大数值-BigInteger-BigDecimal" class="headerlink" title="大数值 BigInteger BigDecimal"></a>大数值 BigInteger BigDecimal</h5><ul><li>不是一个java基础类型，而是一个java对象，可以表示任意精度的整型和浮点数。</li><li><strong>无法通过运算符计算，需要通过对应的方法进行运算。</strong></li><li>一般可以用在金额的计算。</li></ul><h5 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h5><ul><li>声明-&gt;初始化-&gt;使用</li><li>Java变量在使用之前必须要进行初始化，否则会编译报错。</li></ul><h5 id="常量与类常量（静态常量）"><a href="#常量与类常量（静态常量）" class="headerlink" title="常量与类常量（静态常量）"></a>常量与类常量（静态常量）</h5><ul><li>final表示常量，只能被赋值一次，且声明的时候必须初始化</li><li>常量名推荐使用全大写,<code>final int NUMBER = 10;</code></li><li>static final，类常量，可以在类中多个方法中使用</li><li>注意：与C++不同，常量不是通过const声明的，Java中const是保留字，但没有实际作用。</li></ul><h5 id="常用的Math静态方法"><a href="#常用的Math静态方法" class="headerlink" title="常用的Math静态方法"></a>常用的Math静态方法</h5><ul><li>平方根：<code>double result = Math.sqrt(double x);</code></li><li>幂运算：<code>double result = Math.pow(x,a);</code></li><li>四舍五入：<code>long n = Math.round(double x);</code></li><li>随机数: <code>Math.random()</code>,返回0-1之间的随机浮点数，比如要取0 - n-1之间的随机数，<code>int result = (int)(Math.random() * n)</code>.</li></ul><h5 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h5><ul><li>强制类型转换会导致结果被截断成一个完全不同的值，比如(byte)300 的值为 44</li><li>不要将boolean与任何类型之间做类型转换。</li></ul><h5 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h5><ul><li>自定义枚举类型</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">enum Size &#123;</span><br><span class="line">  SMALL, LARGE, EXTRA_LARGE</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>使用</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Size size = Size.SMALL;</span><br></pre></td></tr></table></figure><h5 id="字符串String类型"><a href="#字符串String类型" class="headerlink" title="字符串String类型"></a>字符串String类型</h5><ul><li>不是Java的基础类型，而是一个预定义类。</li><li><strong>和C++不同，Java中的String不是字符数组，而是一个对象，可以理解为char*指针</strong></li><li>Java 的字符串是<strong>不可变的</strong>，对字符串的修改，实际上是创建了一个新的String对象，目的是为了复用和共享存在堆上的字符串**<ul><li>源码中字符串内容有final修饰。</li></ul></li><li>对字符串修改的需求没有对字符串进行比较的需求大。<ul><li>比较：equals</li><li>修改：StringBuffer，StringBuilder</li></ul></li><li>字符串比较：要使用equal(str)方法，而不能使用 &#x3D;&#x3D; 来判断<ul><li>因Java没有像C++那样，重载了&#x3D;&#x3D;运算符。</li><li>&#x3D;&#x3D;实际判断的是两个字符串变量是否引用的是同一个存储位置，而不是内容。</li><li>所以 &#x3D;&#x3D; 判断的结果是未知的，常常会导致隐藏bug。</li></ul></li><li>字符串判空,<strong>区分空串和Null串</strong><ul><li>if(str !&#x3D; null &amp;&amp; str.length()!&#x3D;0)</li></ul></li><li>当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 String 对象。</li><li>码点与代码单元<ul><li><strong>最好避免直接操作char，这太底层了</strong></li><li>str.length()返回的是代码单元个数</li><li>str.codePointCount(0,str.length()),统计的是码点数量</li><li>str.charAt(n),获取n位置的代码单元</li><li>关于代码单元与码点：</li></ul></li></ul><h5 id="常用的String-API"><a href="#常用的String-API" class="headerlink" title="常用的String API"></a>常用的String API</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> <span class="title function_">charAt</span><span class="params">(<span class="type">int</span> index)</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">equalsIgnoreCase</span><span class="params">(String str)</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">startsWith</span><span class="params">(String prefix)</span>，判断是否是以prefix为前缀</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">endsWith</span><span class="params">(String suffix)</span>，判断是否以suffix为后缀</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">indexof</span><span class="params">(String str)</span>, 找到字串str第一次出现的位置，没有则返回-<span class="number">1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">length</span><span class="params">()</span>,字符串长度</span><br><span class="line"><span class="type">int</span> <span class="title function_">codePointCount</span><span class="params">(<span class="type">int</span> startIndex, <span class="type">int</span> endIndex)</span>,统计代码点数目</span><br><span class="line">String <span class="title function_">substring</span><span class="params">(<span class="type">int</span> begin , <span class="type">int</span> end)</span>;</span><br><span class="line">String <span class="title function_">toLowerCase</span><span class="params">()</span>, toUpperCase()</span><br><span class="line">Stirng <span class="title function_">trim</span><span class="params">()</span>, 删除字符串开始和结尾的空格</span><br><span class="line">String <span class="title function_">join</span><span class="params">(<span class="string">&#x27;divider&#x27;</span>,CharSequence...emements)</span></span><br></pre></td></tr></table></figure><h5 id="StringBuilder，StringBuffer字符串构造"><a href="#StringBuilder，StringBuffer字符串构造" class="headerlink" title="StringBuilder，StringBuffer字符串构造"></a>StringBuilder，StringBuffer字符串构造</h5><ul><li>在有构造字符串或者修改字符串的情况下，不适合使用String，因为是不可变的。</li><li>推荐使用StringBuilder（单线程）或者StringBuffer（多线程）。</li><li>使用方式</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String builder = new StringBuilder(); // 创建一个构造器</span><br><span class="line">builder.append(&quot;hello&quot;);</span><br><span class="line">builder.append(&quot;world&quot;); // 追加字符或者字符串</span><br><span class="line">String str = builder.toString(); // 构造String对象</span><br><span class="line">// 其他api</span><br><span class="line">builder.setCharAt(index,char)</span><br><span class="line">builder.delete(start,end)</span><br><span class="line">builder.insert(offset,string)</span><br></pre></td></tr></table></figure><ul><li>StringBuilder的前身是StringBuffer，但是StringBuffer的效率要低一些，因为它是线程安全的，允许多线程操作</li><li>而StringBuilder是非线程安全的，一般在单线程的应用。而在并发中使用StringBuffer</li><li>他们的API是一样的</li></ul><h5 id="读取输入"><a href="#读取输入" class="headerlink" title="读取输入"></a>读取输入</h5><ul><li>从控制台读取基础数据类型</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Scanner scan = new Scanner(System.in); //创建scanner，并与标准输入关联,System.in的类型为InputStream</span><br><span class="line">scan.nextLine();</span><br><span class="line">scan.next();</span><br><span class="line">scan.nextInt();</span><br><span class="line">scan.nextDouble();</span><br><span class="line">scan.hasNext();</span><br><span class="line">scan.hasNextInt();</span><br></pre></td></tr></table></figure><ul><li>从控制台读取密码</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// java se 6 提供了Console类实现读取密码</span><br><span class="line">Console console = System.console();</span><br><span class="line">Stirng userName = console.readLine(&quot;UserName:&quot;);</span><br><span class="line">char [] psd = console.readPassword(&quot;Password:&quot;);</span><br></pre></td></tr></table></figure><h5 id="字符文件输入输出"><a href="#字符文件输入输出" class="headerlink" title="字符文件输入输出"></a>字符文件输入输出</h5><ul><li>读取字符文件</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Scanner scan = new Scanner(Path.get(&quot;pathstring&quot;),&quot;UTF-8&quot;); // 路径是相对于Java虚拟机启动路径的相对位置</span><br><span class="line">scan.readLine()....等一系列方法</span><br></pre></td></tr></table></figure><ul><li>写字符文件</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PrintWriter out = new PrintWriter(&quot;filename.txt&quot;,&quot;UTF-8&quot;);</span><br><span class="line">out.println(&quot;hhh&quot;);</span><br></pre></td></tr></table></figure><ul><li>对于处理文件的Scanner以及PrintWriter，需要在方法中处理异常</li></ul><h5 id="Java的块作用域"><a href="#Java的块作用域" class="headerlink" title="Java的块作用域"></a>Java的块作用域</h5><ul><li><strong>和C++不一样，Java不允许在嵌套块中重复定义一个变量，会编译错误</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  int n;</span><br><span class="line">  &#123;</span><br><span class="line">    int n; // 这种写法在java中是编译不过的</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="switch-case-break"><a href="#switch-case-break" class="headerlink" title="switch case break"></a>switch case break</h5><ul><li>虽然很简单，但周围很多人都会用错</li><li>break的意思是，本case如果命中了，在执行结束之后，中断之后的case检查，直接返回。</li><li>多个case可以公用同一个处理函数</li><li>case标签的类型可以是char，4种整型，枚举常量，以及字符串常量（Java7开始支持）</li></ul><h5 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h5><ul><li><p>数组声明：int [] array;</p></li><li><p>数组初始化： array &#x3D; new int [100];</p><ul><li>需要指定数组初始大小，可以是整型n变量，数组创建之后大小无法更改。（如果需要，使用数组列表）</li><li>整型数组所有元素初始化为0，boolean初始化为false，对象类型初始化为null</li></ul></li><li><p>数组元素个数：array.length</p></li><li><p>数组for循环：for(int item : array)</p></li><li><p>数组拷贝</p><ul><li>浅拷贝：直接将一个数据变量的值赋值给另一个数组变量，两个数组变量引用的是堆中的同一个数组，对一个的修改会影响到另一个</li><li>深拷贝：在原来的基础上，新创建一个一模一样的数组，或者更长的数组。Array提供了copyOf方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> [] newArray = Array.copyOf(array,array.length+<span class="number">10</span>); <span class="comment">// 拷贝array数组，长度加10</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>Java中的数据是在堆上创建的，相当于C++中的<code>int * a = new int[30];</code>,而不是<code>int a[10];</code>,这是在栈中的数组。</p></li><li><p>多维数组：数组的元素还是数组而已，且Java还支持不规则的数组（行列不一定要求是整齐的），C++是不支持的</p></li></ul><h3 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h3><ul><li>类与对象的关系：模板，实例</li><li>类之间的三种关系</li><li>对象与对象变量（对象引用）<ul><li>对象实例存储在堆上，对象引用存储在栈中。</li><li>一个对象实例可以被多个变量引用，一个变量可以引用0或1个对象实例。</li></ul></li><li>预定义类（String，Date，LocalDate）与自定义类</li><li>Java多源文件的使用：Java编译器内置了类似UNIX的make功能，在编译的时候，能够自动查找需要依赖的其他类，有class文件就直接使用，没有则查找java文件并编译。</li><li>Java中，所有的方法都必须包含在类中</li><li>private私有域，只有属于同一个类的对象（本身，其他同类对象）才可以访问。</li><li>final常量、final方法：</li><li>静态变量、静态常量、静态方法</li><li>静态方法中不能访问非静态实例域，但可以访问静态域。</li><li>main()方法是一个静态方法，它不对任何对象进行操作，负责在程序启动的时候创建对象。</li><li>每个类都可以实现一个main方法，用来进行单元测试，在执行完整Application时候，每个单元中的main并不会执行。</li></ul><h5 id="对象构造与构造函数"><a href="#对象构造与构造函数" class="headerlink" title="对象构造与构造函数"></a>对象构造与构造函数</h5><ul><li>构造函数：Java的对象都是在堆上构造的，通过new操作符在堆上创建新对象。构造函数在new对象的时候被调用。<ul><li>与C++中对象的构造做区分，C++中支持在栈和堆上创建对象，Java对象与后者类似。</li></ul></li><li>构造函数不允许被重写Override</li><li>推荐在自定义多参数构造函数的时候，提供一个空参数的构造函数<ul><li>因为若子类在构造函数中没有通过super方式调用父类构造函数，Java会默认调用父类的无参数构造函数。若父类没有空构造函数，则会编译错误。</li></ul></li></ul><h5 id="对象域的初始化"><a href="#对象域的初始化" class="headerlink" title="对象域的初始化"></a>对象域的初始化</h5><ul><li>三种域初始化方式：在构造器中初始化，声明中初始化，在初始化块</li><li>在用户没给构造函数的时候，系统会自动提供一个无参构造函数，一旦用户提供了，系统就不再提供无参构造函数。</li><li>对象中的域，默认被初始化为0，false，以及null</li><li>域的初始化也可以直接在声明时进行，好习惯是在声明变量域的时候，就给个安全的初始值。（C++中是不允许的，只能通过构造函数初始化域）</li><li>初始化块：一个或多个代码块，只要构造类对象，这些初始化块就一定会执行，一般用于初始化比较复杂的情况。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化块</span></span><br><span class="line">  <span class="keyword">static</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">Random</span> <span class="variable">generator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>(); </span><br><span class="line">    id = generator.nextInt(<span class="number">1000</span>); <span class="comment">// 生成0-999的随机数</span></span><br><span class="line">    System.out.println(<span class="string">&quot;hello&quot;</span>); <span class="comment">//也可以执行非初始化语句的</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>具体的域初始化步骤</li><li>1.所有数据域被初始化为0，false、null</li><li>2.按照类中各个数据域声明出现的前后顺序，执行各自的初始化语句以及初始化块。</li><li>3.执行构造器内容</li></ul><h5 id="对象析构-finalize方法"><a href="#对象析构-finalize方法" class="headerlink" title="对象析构 finalize方法"></a>对象析构 finalize方法</h5><ul><li>Java有自动的垃圾回收器，所以不像C++，没有显式的析构器。</li><li>可以为类添加一个finalize方法，该方法在对象被清楚之前调用。</li><li><strong>实际应用中，避免在finalize中去释放资源，因为finalize什么时候被执行是无法确定的</strong></li><li>对于一些资源的使用，要提供一个close方法，在使用完毕后调用。</li><li>可以通过Runtime.addShutdownHook 方法来添加关闭钩子的方式更好的实现。</li></ul><h5 id="方法参数传递"><a href="#方法参数传递" class="headerlink" title="方法参数传递"></a>方法参数传递</h5><ul><li>Java的参数传递是<strong>传值调用</strong>的，方法得到的是参数的拷贝，且<strong>方法内无法修改传递进来的参数</strong>。</li><li>对于基本数据类型，直接传入的是数据拷贝，而对于对象，传入的是对象引用的拷贝（<strong>容易理解为传引用调用，但实际是通过传值调用实现的，只是这里的值是对象引用</strong>）。</li><li>对于基本数据类型参数，参数传递不会改变参数变量的值。</li><li>对于对象引用参数，方法内可以通过对象应用去修改对象内容。</li><li>对于对象引用参数，无法将对象引用参数指向另一个新对象。</li></ul><h5 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h5><ul><li>重载：overloading，多个方法，有相同的名字，但有不同的参数列表。</li><li>重载解析：编译器负责根据参数列表，匹配正确的函数。</li><li>函数签名：函数名+参数列表，<strong>注意，返回类型不属于函数签名，不能通过不同的返回类型来重载</strong></li></ul><h5 id="包-package"><a href="#包-package" class="headerlink" title="包 package"></a>包 package</h5><ul><li>通过包来组织类，文件目录方式，避免重名</li><li>import导入类、静态导入</li><li>将类放入包中：<ul><li>1.类源代码开头添加 package path; （没有该行，则该类属于默认包）</li><li>2.将类源文件放在package对应的问价夹中</li></ul></li><li><strong>编译器在编译文件的时候是不关注目录结构的，但定位一个类的时候，通过包名和类名来定位。所以，必须将类源代码放在package对应的文件夹下，否则虚拟机找不到类</strong></li><li>包作用域：不添加public和private时，默认的作用域。同一个包中都可以访问。</li></ul><h5 id="类路径"><a href="#类路径" class="headerlink" title="类路径"></a>类路径</h5><ul><li>从三个地方加载类<ul><li>1.JRE中的JAR文件</li><li>2.第三方JAR文件</li><li>3.用户源程序目录</li></ul></li><li>通过<code>java -classpath </code>或者设置<code>CLASSPATH</code>环境变量来设置类路径。</li></ul><h5 id="类注释"><a href="#类注释" class="headerlink" title="类注释"></a>类注释</h5><ul><li>javadoc，由源文件生成html</li><li>类注释</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  类注释</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">hhh</span>&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>方法注释</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* desc hh</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">hh</span><span class="params">(<span class="type">int</span> id)</span>&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>域注释</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* desc</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> id;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>欲知后事如何，且听下回，太长了，逃。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 大脑Cache </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>update-alternatives 让多个版本库共存</title>
      <link href="/2021/12/16/update-alternatives-%E8%AE%A9%E5%A4%9A%E4%B8%AA%E7%89%88%E6%9C%AC%E5%BA%93%E5%85%B1%E5%AD%98/"/>
      <url>/2021/12/16/update-alternatives-%E8%AE%A9%E5%A4%9A%E4%B8%AA%E7%89%88%E6%9C%AC%E5%BA%93%E5%85%B1%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<blockquote><p>记录在解决Ubuntu系统python2.7与python3.4共存的问题，使用update-alternatives在两个版本之间进行切换</p></blockquote><h3 id="update-alternatives"><a href="#update-alternatives" class="headerlink" title="update-alternatives"></a>update-alternatives</h3><h5 id="检查update-alternatives是否已经检测到两个版本的python"><a href="#检查update-alternatives是否已经检测到两个版本的python" class="headerlink" title="检查update-alternatives是否已经检测到两个版本的python"></a>检查update-alternatives是否已经检测到两个版本的python</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update-alternatives --list python</span><br></pre></td></tr></table></figure><p>如果出现以下错误，则说明未添加</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update-alternatives: error: no alternatives for python</span><br></pre></td></tr></table></figure><span id="more"></span><h5 id="更新替代列表，将两个版本的python放入其中"><a href="#更新替代列表，将两个版本的python放入其中" class="headerlink" title="更新替代列表，将两个版本的python放入其中"></a>更新替代列表，将两个版本的python放入其中</h5><p>update-alternatives –install [link] [name] [path] [priority]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">update-alternatives --install /usr/bin/python python /usr/bin/python2.7 1</span><br><span class="line">update-alternatives --install /usr/bin/python python /usr/bin/python3.4 2</span><br></pre></td></tr></table></figure><h5 id="再此检查是否添加成功"><a href="#再此检查是否添加成功" class="headerlink" title="再此检查是否添加成功"></a>再此检查是否添加成功</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update-alternatives --list python</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/python2.7</span><br><span class="line">/usr/bin/python3.4</span><br></pre></td></tr></table></figure><h5 id="切换配置"><a href="#切换配置" class="headerlink" title="切换配置"></a>切换配置</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update-alternatives --config python</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  Selection    Path                Priority   Status</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">* 0            /usr/bin/python3.4   2         auto mode</span><br><span class="line">  1            /usr/bin/python2.7   1         manual mode</span><br><span class="line">  2            /usr/bin/python3.4   2         manual mode</span><br><span class="line"></span><br><span class="line">Press enter to keep the current choice[*], or type selection number:</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>使用update-alternatives工具之后，在不同版本之间穿梭将变得十分方便，是个值得掌握的工具</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx日常使用中的配置积累</title>
      <link href="/2021/11/25/nginx-%E9%85%8D%E7%BD%AE%E5%85%81%E8%AE%B8%E8%B7%A8%E5%9F%9F/"/>
      <url>/2021/11/25/nginx-%E9%85%8D%E7%BD%AE%E5%85%81%E8%AE%B8%E8%B7%A8%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<h3 id="配置https"><a href="#配置https" class="headerlink" title="配置https"></a>配置https</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen        443;</span><br><span class="line">  server_name   zwboy.cn;</span><br><span class="line"></span><br><span class="line">  ssl           on;</span><br><span class="line">  ssl_certificate_key   ./cert/zwboy.cn.prikey.key</span><br><span class="line">  ssl_certificate       ./cert/zwboy.cn.pem;</span><br><span class="line"></span><br><span class="line">  location / &#123;</span><br><span class="line">    proxy_pass http://localhost:8080;</span><br><span class="line">    proxy_set_header HOST $host;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># http跳转到https</span><br><span class="line">server &#123;</span><br><span class="line">  listen 80 default_server;</span><br><span class="line">  listen [::]:80 default_server; # ip访问</span><br><span class="line">  server_name zwboy.cn;</span><br><span class="line"></span><br><span class="line">  return 302 https://$server_name$request_uri; # 302跳转到https</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h3 id="配置支持http2"><a href="#配置支持http2" class="headerlink" title="配置支持http2"></a>配置支持http2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen       443 http2; # 加上一个http2就可以了</span><br><span class="line">  server_name  zwboy.cn;</span><br><span class="line"></span><br><span class="line">  http2_push_preload  on; # 开启支持http2的推送特性</span><br><span class="line"></span><br><span class="line">  ssl           on;</span><br><span class="line">  ssl_certificate_key   ./cert/zwboy.cn.prikey.key</span><br><span class="line">  ssl_certificate       ./cert/zwboy.cn.pem;</span><br><span class="line"></span><br><span class="line">  location / &#123;</span><br><span class="line">    proxy_pass http://127.0.0.1:8888;</span><br><span class="line">    proxy_set_header Host $host;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置nginx缓存"><a href="#配置nginx缓存" class="headerlink" title="配置nginx缓存"></a>配置nginx缓存</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">proxy_cache_path cache levels=1:2 keys_zone=my_cache:10m;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">  listen       80;</span><br><span class="line">  # listen       [::]:80 default_server;</span><br><span class="line">  server_name  zwboy.cn;</span><br><span class="line"></span><br><span class="line">  # return 302 https://$server_name$request_uri;</span><br><span class="line"></span><br><span class="line">  location / &#123;</span><br><span class="line">    proxy_cache my_cache;</span><br><span class="line">    proxy_pass http://127.0.0.1:8888;</span><br><span class="line">    proxy_set_header Host $host;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="配置跨域"><a href="#配置跨域" class="headerlink" title="配置跨域"></a>配置跨域</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">    location / &#123;  </span><br><span class="line">      add_header Access-Control-Allow-Origin *;</span><br><span class="line">      add_header Access-Control-Allow-Methods &#x27;GET, POST, OPTIONS&#x27;;</span><br><span class="line">      add_header Access-Control-Allow-Headers &#x27;DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization&#x27;;</span><br><span class="line">      if ($request_method = &#x27;OPTIONS&#x27;) &#123;</span><br><span class="line">          return 204;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置多个host的代理"><a href="#配置多个host的代理" class="headerlink" title="配置多个host的代理"></a>配置多个host的代理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen 80;  # 设置Nginx对外监听80端口</span><br><span class="line">        server_name *.domain.cn;  # 绑定到该服务器的域名</span><br><span class="line">        if ( $http_host ~* &quot;^(.*?)\.domain\.cn&quot; ) &#123;  # 对http_host进行正则匹配，解析domain</span><br><span class="line">                set $domain $1;</span><br><span class="line">        &#125;</span><br><span class="line">        location / &#123;</span><br><span class="line">                proxy_set_header        X-Real-IP       $remote_addr;</span><br><span class="line">                proxy_set_header        Host            $http_host;</span><br><span class="line">                # 分别处理各个domain</span><br><span class="line">                if ( $domain ~* &quot;www&quot; ) &#123;</span><br><span class="line">                        proxy_pass http://localhost:82;  # 通过proxy_pass 进行代理转发</span><br><span class="line">                &#125;</span><br><span class="line">                if ( $domain ~* &quot;gitlab&quot; ) &#123;</span><br><span class="line">                        proxy_pass http://localhost:82;</span><br><span class="line">                &#125;</span><br><span class="line">                if ( $domain ~* &quot;jenkins&quot; ) &#123;</span><br><span class="line">                        proxy_pass http://localhost:9090;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="部署React前端单页应用"><a href="#部署React前端单页应用" class="headerlink" title="部署React前端单页应用"></a>部署React前端单页应用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 8083;</span><br><span class="line">    root /home/name/..../build; # 前端build完成之后的静态资源路径</span><br><span class="line">    index index.html index.htm;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        try_file $uri $uri/ /index.html;  # url 切换时始终返回index.html</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # 其他配置</span><br><span class="line">    # 图片样式缓存1年</span><br><span class="line">    location ~* /app.*\.(js|css|png|jpg)$ &#123;</span><br><span class="line">       access_log off;</span><br><span class="line">        expires    365d;</span><br><span class="line">    &#125;</span><br><span class="line">    # html/xml/json 文件不缓存</span><br><span class="line">    location ~* /app.*\.(?:manifest|appcache|html?|xml|json)$ &#123;</span><br><span class="line">        expires    -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="server-name"><a href="#server-name" class="headerlink" title="server_name"></a>server_name</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">  server_name primary.zwboy.cn blog.zwboy.cn;</span><br><span class="line">  server_name_in_redirect off;</span><br><span class="line">  return 302 /redirect;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="nginx-http模块的11个阶段"><a href="#nginx-http模块的11个阶段" class="headerlink" title="nginx http模块的11个阶段"></a>nginx http模块的11个阶段</h3><blockquote><p>简化的阶段：1.读取request头，2.检查配置块，3.流量控制（是否超出连接限制，速率控制），4.鉴权（是否盗链），5.生成内容（5.1作为代理服务器，去上有请求数据，5.2，内部生成数据），6.Response 过滤（压缩，SSL等），7.日志处理</p></blockquote><ul><li>实际是按照以下11个阶段顺序进行的</li></ul><h5 id="POST-READ"><a href="#POST-READ" class="headerlink" title="POST_READ"></a>POST_READ</h5><ul><li>读取request headers之后</li><li>realip，拿到用户的真实ip，可以用于限流等</li></ul><h5 id="SERVER-REWRITE"><a href="#SERVER-REWRITE" class="headerlink" title="SERVER_REWRITE"></a>SERVER_REWRITE</h5><ul><li>rewite模块</li></ul><h5 id="FIND-CONFIG"><a href="#FIND-CONFIG" class="headerlink" title="FIND_CONFIG"></a>FIND_CONFIG</h5><ul><li>nginx模块本身</li></ul><h5 id="REWRITE"><a href="#REWRITE" class="headerlink" title="REWRITE"></a>REWRITE</h5><h5 id="POST-REWRITE"><a href="#POST-REWRITE" class="headerlink" title="POST_REWRITE"></a>POST_REWRITE</h5><ul><li>rewrite之后的阶段</li></ul><h5 id="PREACCESS"><a href="#PREACCESS" class="headerlink" title="PREACCESS"></a>PREACCESS</h5><ul><li>确认访问权限前的阶段</li><li>limt_conn，并发连接限制</li><li>limt_req，每秒请求数限制</li></ul><h5 id="ACCESS"><a href="#ACCESS" class="headerlink" title="ACCESS"></a>ACCESS</h5><ul><li>判断能不能访问</li><li>auth_basic，用户名，密码</li><li>access，根据ip</li><li>auth_request，根据第三方服义判断</li></ul><h5 id="POST-ACCESS"><a href="#POST-ACCESS" class="headerlink" title="POST_ACCESS"></a>POST_ACCESS</h5><ul><li>访问之后阶段</li></ul><h5 id="PRECONTENT"><a href="#PRECONTENT" class="headerlink" title="PRECONTENT"></a>PRECONTENT</h5><ul><li>连接前阶段</li><li>try_files</li></ul><h5 id="CONTENT"><a href="#CONTENT" class="headerlink" title="CONTENT"></a>CONTENT</h5><ul><li>index</li><li>autoindex</li><li>concat</li></ul><h5 id="LOG"><a href="#LOG" class="headerlink" title="LOG"></a>LOG</h5><ul><li>access_log</li></ul><h3 id="realip"><a href="#realip" class="headerlink" title="realip"></a>realip</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">  server_name domain.cn;</span><br><span class="line"></span><br><span class="line">  set_real_ip_from 111.111.112.1;</span><br><span class="line">  real_ip_recursive on;</span><br><span class="line">  real_ip_header X-Forwardwd-For;  <span class="comment"># realip可以来自Http的头，X-Forwardwd-For和Real-IP</span></span><br><span class="line"></span><br><span class="line">  location / &#123;</span><br><span class="line">    <span class="built_in">return</span> 200 <span class="string">&quot;Client real ip: <span class="variable">$remote_addr</span>\n&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="rewrite"><a href="#rewrite" class="headerlink" title="rewrite"></a>rewrite</h3>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高性能服务器：实现简单的TCP/UDP server，以及对应的Client</title>
      <link href="/2021/11/20/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%9A%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84TCP-UDP-server%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%AF%B9%E5%BA%94%E7%9A%84Client/"/>
      <url>/2021/11/20/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%9A%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84TCP-UDP-server%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%AF%B9%E5%BA%94%E7%9A%84Client/</url>
      
        <content type="html"><![CDATA[<blockquote><p>有兴趣搞一搞高性能流媒体服务器，这些得了解，学习过程中记录一下，方便未来回顾。</p></blockquote><h3 id="一、实现一个TCP-Server"><a href="#一、实现一个TCP-Server" class="headerlink" title="一、实现一个TCP Server"></a>一、实现一个TCP Server</h3><h5 id="Server端步骤"><a href="#Server端步骤" class="headerlink" title="Server端步骤"></a>Server端步骤</h5><ul><li>socker():创建socket，指定使用TCP协议</li><li>bind():将socket与地址和端口进行绑定</li><li>listen():侦听端口</li><li>accept():创建新的socket</li><li>recv():使用recv接收数据</li><li>send():使用send发送数据</li><li>close():使用close关闭连接</li></ul><span id="more"></span><h5 id="TCP常见套接字选项"><a href="#TCP常见套接字选项" class="headerlink" title="TCP常见套接字选项"></a>TCP常见套接字选项</h5><ul><li>SO_REUSEADDR: 地址重用<ul><li>之前程序结束，端口处于WAIT_TIME状态下，新启动的程序仍然可以启动</li></ul></li><li>SO——RCVBUF：设置接收缓冲区大小</li><li>SO_SNDBUF: 设置发送缓冲区大小</li></ul><h5 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span> <span class="comment">// for socket(),setsockopt</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span> <span class="comment">// for struct sockaddr_in</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>     <span class="comment">// for exit()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>     <span class="comment">// for close()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span>     <span class="comment">// for bzero()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 8881</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MESSAGE_LEN 1024</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> on = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> socket_fd, accept_fd;</span><br><span class="line">    <span class="type">int</span> backlog = <span class="number">10</span>; <span class="comment">//缓冲长度，与并发量相关</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> localaddr, remoteaddr;</span><br><span class="line">    <span class="type">char</span> in_buff[MESSAGE_LEN] = &#123;</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">    &#125;; <span class="comment">// 接收缓冲区</span></span><br><span class="line">    socket_fd = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (socket_fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;failed to create socket!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ret = <span class="built_in">setsockopt</span>(socket_fd, SOL_SOCKET, SO_REUSEADDR,</span><br><span class="line">                     &amp;on, <span class="built_in">sizeof</span>(on));</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;failed to set socket options!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    localaddr.sin_family = AF_INET;</span><br><span class="line">    localaddr.sin_port = PORT;</span><br><span class="line">    localaddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    <span class="built_in">bzero</span>(&amp;(localaddr.sin_zero), <span class="number">8</span>);</span><br><span class="line">    ret = <span class="built_in">bind</span>(socket_fd, (<span class="keyword">struct</span> sockaddr *)&amp;localaddr, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> sockaddr));</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;failed to bind &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ret = <span class="built_in">listen</span>(socket_fd, backlog);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;failed to listen &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">socklen_t</span> addr_len = <span class="built_in">sizeof</span>(<span class="keyword">struct</span> sockaddr);</span><br><span class="line">        accept_fd = <span class="built_in">accept</span>(socket_fd,</span><br><span class="line">                           (<span class="keyword">struct</span> sockaddr *)&amp;remoteaddr,</span><br><span class="line">                           &amp;addr_len);</span><br><span class="line">        <span class="type">int</span> pid = fork();</span><br><span class="line">        <span class="keyword">for</span> (;;)</span><br><span class="line">        &#123;</span><br><span class="line">            ret = <span class="built_in">recv</span>(accept_fd, (<span class="type">void</span> *)in_buff, MESSAGE_LEN, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (ret == <span class="number">0</span>) <span class="comment">// 说明没数据了</span></span><br><span class="line">            &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;recv finish，end！ &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;receive:&quot;</span> &lt;&lt; in_buff &lt;&lt; std::endl;</span><br><span class="line">            <span class="comment">// 返回客户端</span></span><br><span class="line">            <span class="built_in">send</span>(accept_fd, (<span class="type">void</span> *)in_buff, MESSAGE_LEN, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">close</span>(accept_fd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(socket_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二、实现一个TCP-Client"><a href="#二、实现一个TCP-Client" class="headerlink" title="二、实现一个TCP Client"></a>二、实现一个TCP Client</h3><h5 id="Client端步骤"><a href="#Client端步骤" class="headerlink" title="Client端步骤"></a>Client端步骤</h5><ul><li>socket():创建socket，指定使用TCP协议</li><li>connect():操作系统随机分配一个随机的端口和IP地址</li><li>send():发送</li><li>recv():接收</li><li>close():关闭</li></ul><h5 id="Demo-1"><a href="#Demo-1" class="headerlink" title="Demo"></a>Demo</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span>  <span class="comment">//for socket()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>   <span class="comment">// for connect()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span>  <span class="comment">// for struct sockaddr_in</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span>   <span class="comment">// for inet_addr()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>       <span class="comment">// for gets()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span>      <span class="comment">// for strlen()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>      <span class="comment">// for exit()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 8881        <span class="comment">// tcp server port</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MESSAGE_LEN 1024 <span class="comment">// buffer size</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> socket_fd; <span class="comment">// file descriptor</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// step1:create socket</span></span><br><span class="line">    socket_fd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (socket_fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;failed to create socket&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// step2: connect</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serveraddr;</span><br><span class="line">    serveraddr.sin_family = AF_INET;</span><br><span class="line">    serveraddr.sin_port = PORT;</span><br><span class="line">    serveraddr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    ret = <span class="built_in">connect</span>(socket_fd, (<span class="keyword">struct</span> sockaddr *)&amp;serveraddr, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> sockaddr));</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;failed to connect server&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// step3: send()</span></span><br><span class="line">    <span class="type">char</span> sendbuf[MESSAGE_LEN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">char</span> recvbuf[MESSAGE_LEN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(sendbuf, <span class="number">0</span>, MESSAGE_LEN); <span class="comment">// 清空buf</span></span><br><span class="line">        <span class="built_in">gets</span>(sendbuf);                   <span class="comment">// input from console</span></span><br><span class="line">        ret = <span class="built_in">send</span>(socket_fd, sendbuf, <span class="built_in">strlen</span>(sendbuf), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt;= <span class="number">0</span>) <span class="comment">// 无发送数据</span></span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;failed to send data!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(sendbuf, <span class="string">&quot;q&quot;</span>) == <span class="number">0</span>) <span class="comment">// input q, quit</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ret = <span class="built_in">recv</span>(socket_fd, recvbuf, MESSAGE_LEN, <span class="number">0</span>);</span><br><span class="line">        recvbuf[ret] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">//末尾加\0转化为字符串</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;receive:&quot;</span> &lt;&lt; recvbuf &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、-实现UDPServer"><a href="#三、-实现UDPServer" class="headerlink" title="三、 实现UDPServer"></a>三、 实现UDPServer</h3><h5 id="Server-流程"><a href="#Server-流程" class="headerlink" title="Server 流程"></a>Server 流程</h5><ul><li>Socket():创建Socket，指定为UDP协议</li><li>bind():将socket与地址和端口绑定</li><li>不需要listen，因为udp是无连接的</li><li>recvfrom():使用recv&#x2F;send </li><li>sendto(): 发送</li><li>close(): 关闭连接</li></ul><h5 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span> <span class="comment">// for struct sockaddr_in</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span>  <span class="comment">// for inet_addr()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Welcome! This is a UDP server.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> socket_fd;</span><br><span class="line">    <span class="comment">// step1: create socket</span></span><br><span class="line">    socket_fd = <span class="built_in">socket</span>(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (socket_fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;create udp socket failed!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// step: bind</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> addr;</span><br><span class="line">    addr.sin_family = AF_INET; <span class="comment">// IPV4</span></span><br><span class="line">    addr.sin_port = <span class="number">9876</span>;</span><br><span class="line">    addr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    ret = <span class="built_in">bind</span>(socket_fd, (sockaddr *)&amp;addr, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> sockaddr));</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;bind addr and port failed!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// step3: recvfrom</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> clientAddr;</span><br><span class="line">    <span class="type">socklen_t</span> len = <span class="built_in">sizeof</span>(clientAddr);</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">char</span> recv_buf[BUFFER_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">char</span> send_buf[BUFFER_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// receive data to recv_buf</span></span><br><span class="line">        n = <span class="built_in">recvfrom</span>(socket_fd, recv_buf, BUFFER_SIZE, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr *)&amp;clientAddr, &amp;len);</span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            recv_buf[n] = <span class="number">0</span>; <span class="comment">//转为字符串</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;receive data:&quot;</span> &lt;&lt; recv_buf &lt;&lt; std::endl;</span><br><span class="line">            n = <span class="built_in">sendto</span>(socket_fd, send_buf, BUFFER_SIZE, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr *)&amp;clientAddr, <span class="built_in">sizeof</span>(clientAddr));</span><br><span class="line">            <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;send error!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;receive error!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四、-实现UDP-Client"><a href="#四、-实现UDP-Client" class="headerlink" title="四、 实现UDP Client"></a>四、 实现UDP Client</h3><h5 id="Client-流程"><a href="#Client-流程" class="headerlink" title="Client 流程"></a>Client 流程</h5><ul><li>Socket():创建Socket，指定为UDP协议</li><li>sendto(): 发送</li><li>recvfrom():使用recv&#x2F;send </li><li>close(): 关闭连接</li></ul><h5 id="demo-1"><a href="#demo-1" class="headerlink" title="demo"></a>demo</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span> <span class="comment">// for socket()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>     <span class="comment">// for exit()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span> <span class="comment">// for struct sockaddr_in</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span>  <span class="comment">// for inet_addr()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span>     <span class="comment">// for strlen</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>     <span class="comment">// for close()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// step1: socket</span></span><br><span class="line">    <span class="type">int</span> socket_fq;</span><br><span class="line">    socket_fq = <span class="built_in">socket</span>(AF_INET, SOCK_DGRAM, <span class="number">0</span>); <span class="comment">// UDP是基于报文的</span></span><br><span class="line">    <span class="keyword">if</span> (socket_fq &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;create socket failed!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// step2:</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serverAddr;</span><br><span class="line">    serverAddr.sin_family = AF_INET;</span><br><span class="line">    serverAddr.sin_port = <span class="number">9876</span>;</span><br><span class="line">    serverAddr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    <span class="type">char</span> send_buf[BUFFER_SIZE] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="type">char</span> recv_buf[BUFFER_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">socklen_t</span> len = <span class="built_in">sizeof</span>(serverAddr);</span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (serverAddr.sin_addr.s_addr == INADDR_NONE)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Incorrect ip address!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">close</span>(socket_fq);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    n = <span class="built_in">sendto</span>(socket_fq, send_buf, <span class="built_in">strlen</span>(send_buf), <span class="number">0</span>, (sockaddr *)&amp;serverAddr, <span class="built_in">sizeof</span>(serverAddr));</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;send error!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">close</span>(socket_fq);</span><br><span class="line">    &#125;</span><br><span class="line">    n = <span class="built_in">recvfrom</span>(socket_fq, recv_buf, BUFFER_SIZE, <span class="number">0</span>, (sockaddr *)&amp;serverAddr, &amp;len);</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        recv_buf[n] = <span class="number">0</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;receive:&quot;</span> &lt;&lt; recv_buf &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;server closed.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;recvfrom error.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(socket_fq);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>哎呦，不错哦；</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 高性能服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高性能服务器：Linux下的信号与后台守护进程</title>
      <link href="/2021/11/20/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%9Alinux%E4%B8%8B%E7%9A%84%E4%BF%A1%E5%8F%B7%E4%B8%8E%E5%90%8E%E5%8F%B0%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/"/>
      <url>/2021/11/20/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%9Alinux%E4%B8%8B%E7%9A%84%E4%BF%A1%E5%8F%B7%E4%B8%8E%E5%90%8E%E5%8F%B0%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>有兴趣搞一搞高性能流媒体服务器了，这些得了解，学习过程中记录一下，方便未来回顾。</p></blockquote><h3 id="一、Linux-下的几个重要信号"><a href="#一、Linux-下的几个重要信号" class="headerlink" title="一、Linux 下的几个重要信号"></a>一、Linux 下的几个重要信号</h3><ul><li>SIGPIPE：管道终止信号，当写入无人读取的管道时产生该信号，默认终止进程，需要我们去处理<ul><li>网络程序必须要处理，否则Client端断开连接之后，会导致Server Crash</li></ul></li><li>SIGCHLD：子进程结束或者停止发送时候<ul><li>容易产生僵尸进程（一个早已死亡的进程，但是在进程表中还存在）</li><li>子进程结束的时候，他并没有完全销毁，因为父进程还需要使用它的消息。</li><li>父进程没有处理SIGCHLD信号，或者没有调用wait&#x2F;waitpid等待子进程结束，就会出现僵尸进程。</li></ul></li><li>SIGALRM: 定时信号，秒为单位，默认会终止进程，所以需要我们去处理（捕获，然后忽略）</li><li>SIGINT: 键盘输入的退出信号</li><li>SIGQUIT： 键盘输入的退出信号</li><li>SIGHUP：控制终端挂起信号</li></ul><span id="more"></span><h3 id="二、信号的发送和处理"><a href="#二、信号的发送和处理" class="headerlink" title="二、信号的发送和处理"></a>二、信号的发送和处理</h3><ul><li>硬件方式<ul><li>ctrl+c，ctrl+\</li></ul></li></ul><h3 id="三、安装信号"><a href="#三、安装信号" class="headerlink" title="三、安装信号"></a>三、安装信号</h3><h5 id="signal-int-sig-void-func-int"><a href="#signal-int-sig-void-func-int" class="headerlink" title="signal(int sig, void (*func)(int));"></a>signal(int sig, void (*func)(int));</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sighandle</span><span class="params">(<span class="type">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;receive signal:&quot;</span> &lt;&lt; sig &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">signal</span>(SIGINT, sighandle); <span class="comment">// 捕获SIGINT信号</span></span><br><span class="line">    <span class="built_in">signal</span>(SIGQUIT, sighandle);</span><br><span class="line">    <span class="built_in">signal</span>(SIGHUP, sighandle);</span><br><span class="line">    <span class="built_in">pause</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="通过-sigaction方法"><a href="#通过-sigaction方法" class="headerlink" title="通过 sigaction方法"></a>通过 sigaction方法</h5><ul><li>sigaction<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sigaction</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">void</span> (*sa_handler)(<span class="type">int</span> sig); <span class="comment">// 捕获到sign的处理函数，需要设置</span></span><br><span class="line">    <span class="built_in">void</span> (*sa_sigaction)(<span class="type">int</span>, <span class="type">siginfo_t</span> *, <span class="type">void</span> *); <span class="comment">// 与上类似，一般不用</span></span><br><span class="line">    sigset_tsa_mask; <span class="comment">// 掩码，需要设置</span></span><br><span class="line">    <span class="type">int</span> sa_flags; <span class="comment">//根据SA_SIGINFO标记是选择sa_handler还是sigaction进行处理，需要设置</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>Demo</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sig_handler</span><span class="params">(<span class="type">int</span> sig)</span>   <span class="comment">// 处理函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;receive signal:&quot;</span> &lt;&lt; sig &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argcs[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sigaction</span> act, oact;</span><br><span class="line">    act.sa_handler = sig_handler;</span><br><span class="line">    <span class="built_in">sigfillset</span>(&amp;act.sa_mask); <span class="comment">// 设置掩码</span></span><br><span class="line">    act.sa_flags = <span class="number">0</span>;   <span class="comment">// 选择使用sighandler来处理</span></span><br><span class="line">    <span class="built_in">sigaction</span>(SIGINT, &amp;act, &amp;oact);</span><br><span class="line">    <span class="built_in">sigaction</span>(SIGQUIT, &amp;act, &amp;oact);</span><br><span class="line">    <span class="built_in">pause</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四、后台进程"><a href="#四、后台进程" class="headerlink" title="四、后台进程"></a>四、后台进程</h3><h5 id="fork方式"><a href="#fork方式" class="headerlink" title="fork方式"></a>fork方式</h5><ul><li>四个步骤<ul><li>fork 一个子进程，父进程退出了，那么子进程将成为孤儿进程，被init进程接管</li><li>调用setsid建立新的进程会话</li><li>将当前工作目录切换到更目录（因为父亲进程已经没了，init进程的工作目录在根目录）</li><li>将标准输出，输入，出错重定向到 &#x2F;dev&#x2F;null</li></ul></li><li>Demo 代码</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> <span class="comment">// fork</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> <span class="comment">// for session</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span>  <span class="comment">// for open</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">daemonize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*step1: fork一个子进程*/</span></span><br><span class="line">    <span class="type">int</span> fd;       <span class="comment">// file descriptionor</span></span><br><span class="line">    <span class="type">pid_t</span> pid;    <span class="comment">// 进程id</span></span><br><span class="line">    pid = fork(); <span class="comment">// 当前进程创建一个子进程，pid为子进程的id</span></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;can&#x27;t create suprocess!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pid != <span class="number">0</span>) <span class="comment">// 判断子进程是否创建成功，为0则创建成功，非0则为父进程</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">// 父进程退出，子进程成为孤儿进程，被init进程接管</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*strp2: 建立新的进程会话*/</span></span><br><span class="line">    <span class="built_in">setsid</span>(); <span class="comment">//调用setsid来创建新的进程会话。这使得daemon进程成为会话首进程，脱离和terminal的关联。</span></span><br><span class="line">    <span class="comment">/*step3： 切换工作目录到根目录*/</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">chdir</span>(<span class="string">&quot;/&quot;</span>) &lt; <span class="number">0</span>) <span class="comment">// 将当前工作目录切换到根目录。父进程继承过来的当前目录可能mount在一个文件系统上</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;can&#x27;t change dir!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将标准输入、输出、错位重定向到根目录</span></span><br><span class="line">    fd = <span class="built_in">open</span>(<span class="string">&quot;/dev/null&quot;</span>, O_RDWR); <span class="comment">// O_WRWR，可读可写</span></span><br><span class="line">    <span class="built_in">dup2</span>(fd, STDIN_FILENO);         <span class="comment">// 重定向方法，dup2()</span></span><br><span class="line">    <span class="built_in">dup2</span>(fd, STDOUT_FILENO);</span><br><span class="line">    <span class="built_in">dup2</span>(fd, STDERR_FILENO);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argcs[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">daemonize</span>(); <span class="comment">// 调取这个程序之后，就将程序切换到后台</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="调用系统的daemon-API"><a href="#调用系统的daemon-API" class="headerlink" title="调用系统的daemon API"></a>调用系统的daemon API</h5><ul><li>linux的系统函数，其实实际上也是走上边的四个步骤,推荐优先使用<ul><li>unistd.h中的daemon() api<br>-demo</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argcs[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* Put the program in the background, and dissociate from the controlling</span></span><br><span class="line"><span class="comment">    terminal.  If NOCHDIR is zero, do `chdir (&quot;/&quot;)&#x27;.  If NOCLOSE is zero,</span></span><br><span class="line"><span class="comment">    redirects stdin, stdout, and stderr to /dev/null.  */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">daemon</span>(<span class="number">0</span>, <span class="number">0</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;error&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 以上代码便可以实现将进程切换到后台运行，之后再执行其他语句</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>似乎对linux又友好一点了</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 高性能服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一次基于OAuth 2.0的第三方登录实践总结</title>
      <link href="/2021/11/01/%E4%B8%80%E6%AC%A1%E5%9F%BA%E4%BA%8EOAuth-2-0%E7%9A%84%E7%AC%AC%E4%B8%89%E6%96%B9%E7%99%BB%E5%BD%95%E5%AE%9E%E8%B7%B5/"/>
      <url>/2021/11/01/%E4%B8%80%E6%AC%A1%E5%9F%BA%E4%BA%8EOAuth-2-0%E7%9A%84%E7%AC%AC%E4%B8%89%E6%96%B9%E7%99%BB%E5%BD%95%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<blockquote><p>OAuth 2.0 是目前最流行的授权机制，用来授权第三方应用，获取用户数据。</p></blockquote><h3 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h3><ul><li>最近在视频云项目的ToC观看端想引入用户登录功能。从用户需求的角度考虑，用户不喜欢仅为了发送一个弹幕或者评论而需要进行复杂的注册流程。目前很多网站都引入了第三方登录的方式，这样即解决了用户会忘记密码的问题，也简化了用户的登录流程，提高参与度。</li><li>OAuth是目前主流的授权方式，值得系统学习下。</li></ul><h3 id="二、OAuth-2-0"><a href="#二、OAuth-2-0" class="headerlink" title="二、OAuth 2.0"></a>二、OAuth 2.0</h3><h5 id="1-令牌"><a href="#1-令牌" class="headerlink" title="1. 令牌"></a>1. 令牌</h5><ul><li>OAuth中授权使用的是token，而不是密码。<ul><li>token具有时效性，可以随时被撤销，且权限范围受限</li><li>相比于密码的方式，在实现授权给第三方的同时，具有较好的可控性。</li></ul></li></ul><h5 id="2-角色"><a href="#2-角色" class="headerlink" title="2. 角色"></a>2. 角色</h5><ul><li>客户端：想要通过第三方登录的软件系统</li><li>资源所有者：授权方</li></ul><h5 id="3-授权层"><a href="#3-授权层" class="headerlink" title="3. 授权层"></a>3. 授权层</h5><ul><li>OAuth引入了授权层，来隔离这两个用户</li></ul><span id="more"></span><h3 id="三、OAuth的四种授权方式"><a href="#三、OAuth的四种授权方式" class="headerlink" title="三、OAuth的四种授权方式"></a>三、OAuth的四种授权方式</h3><ul><li>为了适应互联网各种不同的场景，OAuth提供了四种授权方式。</li><li>在授权之前，第三方系统需要到授权系统注册，说明自己的身份<ul><li>然后获得应用ID（app_id）以及应用密钥（app_secret)</li></ul></li><li>下文中A系统为授权系统，比如微信、微博，B系统为第三方应用，比如我们的视频云系统。</li></ul><h5 id="1-授权码式（authorization-code）"><a href="#1-授权码式（authorization-code）" class="headerlink" title="1. 授权码式（authorization-code）"></a>1. 授权码式（authorization-code）</h5><ul><li>最常用的方式，安全性也最高</li><li>需要应用后端支持，授权码由前端获取，令牌以及资源请求由后端进行，安全性高，能防止令牌泄露。</li><li>标志：response_type&#x3D;code</li><li>主要流程：<ul><li><p>1、注册与登记</p><ul><li>B系统到A系统的OAuth开放平台注册，获得app_id以及app_secret，A授权系统会提供一个用户授权的网页链接。</li><li>注册时需要在开放平台配置redirect_uri等授权回调页以及取消授权回调页参数</li></ul></li><li><p>2、前端跳转到授权界面</p><ul><li>B系统将A系统提供的授权链接放在前端登录位置，用户点击后，将带上app_id等参数跳转到A系统的授权界面。</li><li>state参数可以用来保持B系统当前的应用状态，在授权成功之后，会原封不动的返回。state需要存多个参数的时候，可以使用urlencode编码一下。</li></ul></li><li><p>3、用户登录A系统并授权</p><ul><li>用户通过密码登录A系统，如果A系统已经是登录状态，则直接进入授权界面。授权界面会展示B系统所请求的权限以及资源，用户检查后点击授权。</li></ul></li><li><p>4、B系统前端获取授权码</p><ul><li>授权成功，前端自动跳转到redirect_uri指定的网页，同时带上code以及state等query参数。</li><li>其中code便是授权码，而state是之前传入的应用状态参数，用户恢复跳转前的应用状态。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a系统提供的跳转授权链接例子</span></span><br><span class="line"><span class="attr">https</span>:<span class="comment">//a.com/oauth/authrize?response_type=code&amp;client_id=CLIENT_ID&amp;redirect_uri=CALLBACK_RUL&amp;scope=read</span></span><br><span class="line"><span class="comment">// 参数</span></span><br><span class="line">response_type   <span class="comment">// 对于授权码方式为code，指定为授权码方式</span></span><br><span class="line">redirect_uri    <span class="comment">// 授权成功之后，将跳转到该页面</span></span><br><span class="line">scope           <span class="comment">// 指定授权的方位，这里为只读权限</span></span><br><span class="line">state           <span class="comment">// 可以传入随意的字符串参数，可用户保持B应用当前状态</span></span><br></pre></td></tr></table></figure></li><li><p>5、B后端向A系统请求令牌token</p><ul><li>B前端从url中解析出code，将该code提交给B后端</li><li>B后端根据拿到的code、app_id以及app_secret向A系统提供的接口请求令牌token。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// B后端请求Token例子  </span></span><br><span class="line"><span class="attr">https</span>:<span class="comment">//b.com/oauth/token?client_id=CLIENT_ID&amp;client_secret=CLIENT_SECRET</span></span><br><span class="line">&amp;grant_type=authorization_code&amp;code=<span class="variable constant_">AUTHORIZATION_CODE</span>&amp;redirect_uri=<span class="variable constant_">CALLBACK_URL</span></span><br></pre></td></tr></table></figure></li><li><p>6、B后端向A系统请求资源</p><ul><li>B后端获取到token后，使用该token获取用户在A系统中的资源，比如用户名，头像等。</li></ul></li><li><p>7、B后端将结果返回给B前端,前端恢复应用状态。</p></li></ul></li></ul><h5 id="2-隐藏式（implicit）"><a href="#2-隐藏式（implicit）" class="headerlink" title="2. 隐藏式（implicit）"></a>2. 隐藏式（implicit）</h5><ul><li>不需要应用后端支持，前端直接请求令牌token，token存储在前端</li><li>适用于那些没有后端的纯前端应用，对安全性要求不高的场景，比如本博客。</li><li>token的有效期不能太长。</li><li>标志：response_type&#x3D;token</li><li>主要流程<ul><li>1、注册与登记，与授权码方式相同</li><li>2、B前端跳转到A提供的授权界面<ul><li>与授权码方式不同的是，参数response_type为token，A系统将直接返回token令牌</li></ul></li><li>3、B前端获取令牌token<ul><li>授权成功之后，跳转到redirect_uri指定的网站，同时带上token</li><li>与授权码式通过query参数返回不同，token以URL锚点（fragement）的方式返回给B前端</li><li>以锚点方式返回能够避免中间人攻击问题，因为浏览器跳转时，锚点部分不会提交到服务器。</li><li><code>https://a.com/callback#token=ACCESS_TOKEN</code></li></ul></li><li>4、B前端拿到token后，向A后端请求资源。</li></ul></li></ul><h5 id="3-密码式（password）"><a href="#3-密码式（password）" class="headerlink" title="3. 密码式（password）"></a>3. 密码式（password）</h5><ul><li>B网站直接在前端要求用户输入其在A系统的用户名和密码，然后直接通过用户名和密码获取A系统颁发的token</li><li>只适用于那些你高度信任的网站，或者其他方式没法使用的情况下，比如内部系统。</li><li>标志：grant_type&#x3D;password</li><li>授权链接：<code>https://oauth.b.com/token?grant_type=password&amp;username=USERNAME&amp;password=PASSWORD&amp;client_id=CLIENT_ID</code></li></ul><h5 id="4-客户端凭证式（client-credentials）"><a href="#4-客户端凭证式（client-credentials）" class="headerlink" title="4. 客户端凭证式（client credentials）"></a>4. 客户端凭证式（client credentials）</h5><ul><li>适用于没有前端的命令行应用，即在命令行下请求令牌</li><li>标志：grant_type&#x3D;client_credentials</li></ul><h3 id="三、使用与更新"><a href="#三、使用与更新" class="headerlink" title="三、使用与更新"></a>三、使用与更新</h3><h5 id="1-令牌的使用"><a href="#1-令牌的使用" class="headerlink" title="1. 令牌的使用"></a>1. 令牌的使用</h5><ul><li>每个发到 API 的请求，都必须带有令牌。具体做法是在请求的头信息，加上一个Authorization字段，令牌就放在这个字段里面</li></ul><h5 id="2-令牌的更新"><a href="#2-令牌的更新" class="headerlink" title="2. 令牌的更新"></a>2. 令牌的更新</h5><ul><li>令牌有效期到期后，再来一次完整流程比较麻烦，OAuth提供了令牌更新的机制。</li><li>标志：grant_type&#x3D;refresh_token</li></ul><h3 id="四、在使用OAuth时候需要注意的安全问题"><a href="#四、在使用OAuth时候需要注意的安全问题" class="headerlink" title="四、在使用OAuth时候需要注意的安全问题"></a>四、在使用OAuth时候需要注意的安全问题</h3><h5 id="1-CSRF劫持第三方账号"><a href="#1-CSRF劫持第三方账号" class="headerlink" title="1. CSRF劫持第三方账号"></a>1. CSRF劫持第三方账号</h5><ul><li>跨站请求伪造攻击<ul><li>攻击者利用自己获取到的授权码，在钓鱼网站上使用，该钓鱼网站会伪造用户请求，自动触发第三方授权过程。</li><li>使用钓鱼网站的用户，自动触发第三方授权过程，若该用户当前登录了正常系统，且未与该第三方登录绑定。</li><li>最终，正常网站将把该用户账号与攻击者第三方系统登录账号绑定，这样攻击者就可以通过第三方系统登录被攻击者的账号了。</li></ul></li><li>根本原因：redirect_uri中的code参数没有和当前客户端的状态绑定，攻击者可以通过发送预先获取好的code参数到受害者电脑，导致导致受害者当前登录的应用方账号被绑定到攻击者指定的平台方（如微博）帐号上。</li></ul><h5 id="2-预防措施"><a href="#2-预防措施" class="headerlink" title="2. 预防措施"></a>2. 预防措施</h5><ul><li>引入第三方登陆的开发者，在OAuth认证过程中，加入state参数，验证它的参数便可以。</li><li>使用state参数的流程<ul><li>在将用户重定向到资源认证服务器授权界面的时候，为当前用户生成一个随机的字符串，并作为state参数加入到URL中，同时存储一份到 session 中。</li><li>当第三方应用收到资源服务提供者返回的Authorization Code请求的时候，验证接收到的state参数值。</li></ul></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>OAuth 在目前的互联网应用中使用的太多了，系统性了解它的原理很有用。有空可以给本博客集成下登录和评论系统了。</li><li>再一个体会，对于一些使用了OAuth第三方登陆的不是特别出名的小网站，真不敢再随便用自己的第三方账号随便登录了。</li></ul><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><ul><li><a href="http://www.ruanyifeng.com/blog/2019/04/oauth_design.html">[1]大神学长阮一峰的理解OAuth2.0</a></li><li><a href="https://juejin.im/post/5cc81d5451882524f72cd32c">[2]掘金上的一个博客</a></li><li>微博、微信、QQ、github的授权认证接入文档</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OAuth </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux的一些进阶技能</title>
      <link href="/2021/11/01/Linux%E7%9A%84%E4%B8%80%E4%BA%9B%E8%BF%9B%E9%98%B6%E6%8A%80%E8%83%BD/"/>
      <url>/2021/11/01/Linux%E7%9A%84%E4%B8%80%E4%BA%9B%E8%BF%9B%E9%98%B6%E6%8A%80%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<blockquote><p>好好学学Linux，以后用得到 </p></blockquote><h3 id="一些关于Linxu想知道的疑问解决"><a href="#一些关于Linxu想知道的疑问解决" class="headerlink" title="一些关于Linxu想知道的疑问解决"></a>一些关于Linxu想知道的疑问解决</h3><h5 id="1-服务Service与Demand的区别"><a href="#1-服务Service与Demand的区别" class="headerlink" title="1. 服务Service与Demand的区别"></a>1. 服务Service与Demand的区别</h5><p>我的理解，服务是能够常驻在系统后台并提供一些系统的或者网络功能。服务其实是能够提供某个功能的意思，但是既然是一个功能，那一定需要有个程序去执行吧。Demand意思是守护的意思，它便是达成这个service的程序，Demand其实和Service也不需要完全区分。</p><span id="more"></span><h5 id="2-进程、线程以及协程的区别"><a href="#2-进程、线程以及协程的区别" class="headerlink" title="2. 进程、线程以及协程的区别"></a>2. 进程、线程以及协程的区别</h5><ul><li>进程<ul><li>是系统资源分配的最小单位, 系统由一个个进程(程序)组成。</li><li>进程的创建和销毁都是相对于系统资源,所以是一种比较昂贵的操作。</li><li>进程是抢占式的争夺CPU运行自身,而CPU单核的情况下同一时间只能执行一个进程的代码,但是多进程的实现则是通过CPU飞快的切换不同进程,因此使得看上去就像是多个进程在同时进行.</li><li>进程间的通信：不同进程之间的通信主要通过进程间调用IPC来实</li><li>进程是系统分配资源的最小单位</li></ul></li><li>线程<ul><li>线程属于进程，一个进程可以创建多个线程。</li><li>线程共享进程的内存地址空间，多个线程之间也可共享内存。</li><li>线程间的通信：进程相当于一个容器，其中的线程都可以访问容器中的东西。所以线程间的通信可以直接通过全局变量来通信。</li><li>引入锁机制：解决多个线程同时读写一个地址变量带来的不可预期的后果。</li><li>线程是CPU调度的最小单位。</li></ul></li><li>协程<ul><li>协程是属于线程的，协程程序在线程中运行，也叫微线程。</li><li>协程没有线程的上下文切换消耗。协程的调度切换是用户(程序员)手动切换的,因此更加灵活,因此又叫用户空间线程.</li><li>原子操作性。由于协程是用户调度的，所以不会出现执行一半的代码片段被强制中断了，因此无需原子操作锁。</li><li>线程进程都是同步机制，而协程则是异步</li></ul></li></ul><h3 id="Linux服务"><a href="#Linux服务" class="headerlink" title="Linux服务"></a>Linux服务</h3><h5 id="1-定时任务服务-crontab"><a href="#1-定时任务服务-crontab" class="headerlink" title="1. 定时任务服务 crontab"></a>1. 定时任务服务 crontab</h5><ul><li>比如在下订单之后，会有30分钟的支付时间，过期之后，取消订单。</li></ul><h5 id="2-日期同步服务-Ntpdate"><a href="#2-日期同步服务-Ntpdate" class="headerlink" title="2. 日期同步服务 Ntpdate"></a>2. 日期同步服务 Ntpdate</h5><ul><li></li></ul><h5 id="3-日志切割服务-Logrotate"><a href="#3-日志切割服务-Logrotate" class="headerlink" title="3. 日志切割服务 Logrotate"></a>3. 日志切割服务 Logrotate</h5><ul><li></li></ul><h5 id="4-进程管理-supervisor"><a href="#4-进程管理-supervisor" class="headerlink" title="4. 进程管理 supervisor"></a>4. 进程管理 supervisor</h5><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>好好学学Linux，以后用得到</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux 解压命令汇总</title>
      <link href="/2021/11/01/linux-%E8%A7%A3%E5%8E%8B%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB/"/>
      <url>/2021/11/01/linux-%E8%A7%A3%E5%8E%8B%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<blockquote><p>搞定Linux文件打包、解压、压缩</p></blockquote><h3 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h3><ul><li>解包：tar xvf FileName.tar</li><li>打包：tar cvf FileName.tar DirName</li><li>（注：tar是打包，不是压缩！）</li></ul><span id="more"></span><h3 id="gz"><a href="#gz" class="headerlink" title=".gz"></a>.gz</h3><ul><li>解压1：gunzip FileName.gz</li><li>解压2：gzip -d FileName.gz</li><li>压缩：gzip FileName</li></ul><h3 id="tar-gz-和-tgz"><a href="#tar-gz-和-tgz" class="headerlink" title=".tar.gz 和 .tgz"></a>.tar.gz 和 .tgz</h3><ul><li>解压：tar zxvf FileName.tar.gz</li><li>压缩：tar zcvf FileName.tar.gz DirName</li></ul><h3 id="bz2"><a href="#bz2" class="headerlink" title=".bz2"></a>.bz2</h3><ul><li>解压1：bzip2 -d FileName.bz2</li><li>解压2：bunzip2 FileName.bz2</li><li>压缩： bzip2 -z FileName</li></ul><h3 id="tar-bz2"><a href="#tar-bz2" class="headerlink" title=".tar.bz2"></a>.tar.bz2</h3><ul><li>解压：tar jxvf FileName.tar.bz2</li><li>压缩：tar jcvf FileName.tar.bz2 DirName</li></ul><h3 id="bz"><a href="#bz" class="headerlink" title=".bz"></a>.bz</h3><ul><li>解压1：bzip2 -d FileName.bz</li><li>解压2：bunzip2 FileName.bz</li><li>压缩：未知</li></ul><h3 id="tar-bz"><a href="#tar-bz" class="headerlink" title=".tar.bz"></a>.tar.bz</h3><ul><li>解压：tar jxvf FileName.tar.bz</li><li>压缩：未知</li></ul><h3 id="Z"><a href="#Z" class="headerlink" title=".Z"></a>.Z</h3><ul><li>解压：uncompress FileName.Z</li><li>压缩：compress FileName</li></ul><h3 id="tar-Z"><a href="#tar-Z" class="headerlink" title=".tar.Z"></a>.tar.Z</h3><ul><li>解压：tar Zxvf FileName.tar.Z</li><li>压缩：tar Zcvf FileName.tar.Z DirName</li></ul><h3 id="zip"><a href="#zip" class="headerlink" title=".zip"></a>.zip</h3><ul><li>解压：unzip FileName.zip</li><li>压缩：zip FileName.zip DirName</li></ul><h3 id="rar"><a href="#rar" class="headerlink" title=".rar"></a>.rar</h3><ul><li>解压：rar x FileName.rar</li><li>压缩：rar a FileName.rar DirName</li></ul><h3 id="lha"><a href="#lha" class="headerlink" title=".lha"></a>.lha</h3><ul><li>解压：lha -e FileName.lha</li><li>压缩：lha -a FileName.lha FileName</li></ul><h3 id="rpm"><a href="#rpm" class="headerlink" title=".rpm"></a>.rpm</h3><ul><li>解包：rpm2cpio FileName.rpm | cpio -div</li></ul><h3 id="deb"><a href="#deb" class="headerlink" title=".deb"></a>.deb</h3><ul><li>解包：ar p FileName.deb data.tar.gz | tar zxf -</li></ul><h3 id="gzip-命令"><a href="#gzip-命令" class="headerlink" title="gzip 命令"></a>gzip 命令</h3><ul><li><p>减少文件大小有两个明显的好处，一是可以减少存储空间，二是通过网络传输文件时，可以减少传输的时间。gzip 是在 Linux 系统中经常使用的一个对文件进行压缩和解压缩的命令，既方便又好用。</p></li><li><p>语法：gzip [选项] 压缩（解压缩）的文件名该命令的各选项含义如下：</p></li><li><p>-c 将输出写到标准输出上，并保留原有文件。-d 将压缩文件解压。-l 对每个压缩文件，显示下列字段：     压缩文件的大小；未压缩文件的大小；压缩比；未压缩文件的名字-r 递归式地查找指定目录并压缩其中的所有文件或者是解压缩。-t 测试，检查压缩文件是否完整。-v 对每一个压缩和解压的文件，显示文件名和压缩比。-num 用指定的数字 num 调整压缩的速度，-1 或 –fast 表示最快压缩方法（低压缩比），-9 或–best表示最慢压缩方法（高压缩比）。系统缺省值为 6。指令实例：</p></li><li><p>gzip *% 把当前目录下的每个文件压缩成 .gz 文件。gzip -dv *% 把当前目录下每个压缩的文件解压，并列出详细的信息。gzip -l *% 详细显示例1中每个压缩的文件的信息，并不解压。gzip usr.tar% 压缩 tar 备份文件 usr.tar，此时压缩文件的扩展名为.tar.gz。</p></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>其实都可以直接查到，争取早日孰能生巧吧。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web-rtc技术基础</title>
      <link href="/2021/10/30/web-rtc%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/"/>
      <url>/2021/10/30/web-rtc%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<blockquote><p>背景<br>5G时代，是时候玩玩WebRTC了吧</p></blockquote><h3 id="一、-WebRTC基础"><a href="#一、-WebRTC基础" class="headerlink" title="一、 WebRTC基础"></a>一、 WebRTC基础</h3><h5 id="1-关于WebRTC的关键词"><a href="#1-关于WebRTC的关键词" class="headerlink" title="1. 关于WebRTC的关键词"></a>1. 关于WebRTC的关键词</h5><ul><li>Google开源，跨平台，多媒体框架</li><li>音视频处理+即时通讯的开源库</li><li>浏览器之间端到端之间实时数据传输</li><li>音视频引擎：编码、采集等</li></ul><span id="more"></span><h5 id="2-应用场景"><a href="#2-应用场景" class="headerlink" title="2. 应用场景"></a>2. 应用场景</h5><ul><li>实时视频会议，在线教育，共享远程桌面，录制，即时通讯，P2P网络加速，实时人脸识别，游戏</li><li>浏览器+WebRTC是未来</li></ul><h5 id="3-浏览器支持情况"><a href="#3-浏览器支持情况" class="headerlink" title="3. 浏览器支持情况"></a>3. 浏览器支持情况</h5><ul><li>Chrome，Safari，Firefox，Edge</li></ul><h5 id="4-WebRTC的能力和优势"><a href="#4-WebRTC的能力和优势" class="headerlink" title="4. WebRTC的能力和优势"></a>4. WebRTC的能力和优势</h5><ul><li>能力<ul><li>音视频设备管理</li><li>音视频数据采集</li><li>数据传输与实时互动</li></ul></li><li>优势  <ul><li>音视频实时传输</li><li>游戏、即时通讯、文件传输（P2P传输）</li><li>回音消除，降噪</li></ul></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>内容</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 音视频 </tag>
            
            <tag> WebRTC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FFmpeg 二次开发</title>
      <link href="/2021/10/30/FFmpeg-%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91/"/>
      <url>/2021/10/30/FFmpeg-%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h3 id="一、FFmpeg"><a href="#一、FFmpeg" class="headerlink" title="一、FFmpeg"></a>一、FFmpeg</h3><h5 id="1-代码结构"><a href="#1-代码结构" class="headerlink" title="1. 代码结构"></a>1. 代码结构</h5><ul><li>libacvdec<ul><li>提供了一系列编码器的实现</li><li>如果需要提供自己的编码，在此基础上进行二次开发</li></ul></li><li>libavformat<ul><li>实现在流协议、容器格式以及基本的IO访问</li></ul></li><li>libavutil<ul><li>提供了Hash器，解码器和各种工具函数</li></ul></li><li>libavfilter<ul><li>提供各种音视频过滤器</li></ul></li><li>libavdevice<ul><li>提供捕获设别的接口</li></ul></li><li>libswresample<ul><li>实现混音和重采样</li></ul></li><li>libswscale<ul><li>实现了色彩转换和缩放功能</li></ul></li></ul><span id="more"></span><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>内容</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 音视频 </tag>
            
            <tag> FFmpeg </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vim 编辑器</title>
      <link href="/2021/10/30/vim-%E7%BC%96%E8%BE%91%E5%99%A8/"/>
      <url>/2021/10/30/vim-%E7%BC%96%E8%BE%91%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>背景知识</p></blockquote><ul><li>手不需要移开键盘的编程方法</li></ul><h3 id="Vim基础"><a href="#Vim基础" class="headerlink" title="Vim基础"></a>Vim基础</h3><h5 id="1-两种模式"><a href="#1-两种模式" class="headerlink" title="1. 两种模式"></a>1. 两种模式</h5><ul><li>命令模式<ul><li>拷贝、删除、粘贴</li><li>通过 i（insert） 或者 a（append） 进行切换,一般都是用i</li></ul></li><li>编辑模式<ul><li>编辑字符，</li><li>通过Esc进行切换</li></ul></li></ul><span id="more"></span><h3 id="二、常用命令"><a href="#二、常用命令" class="headerlink" title="二、常用命令"></a>二、常用命令</h3><h5 id="1-基础命令"><a href="#1-基础命令" class="headerlink" title="1. 基础命令"></a>1. 基础命令</h5><ul><li>创建文件<ul><li>vim filename</li></ul></li><li>保存文件<ul><li>:w</li></ul></li><li>关闭文件<ul><li>:q</li></ul></li><li>拷贝<ul><li>命令模式下</li><li>yy  拷贝当前光标所在的一行</li><li>yw  拷贝当前光标所在的一个单词,需要位于单词的第一个字母</li></ul></li><li>粘贴<ul><li>p</li></ul></li><li>删除<ul><li>dd 删除当前光标所在的一行</li><li>dw 删除当前光标所在的单词</li></ul></li><li>撤销更改<ul><li>小写u</li></ul></li><li>反撤销<ul><li>Ctrl + r</li></ul></li></ul><h3 id="2-移动光标"><a href="#2-移动光标" class="headerlink" title="2. 移动光标"></a>2. 移动光标</h3><ul><li>上下左右移动，命令模式下<ul><li>h 左移</li><li>j 上</li><li>k 右</li><li>l 下</li></ul></li><li>跳到文件头<ul><li>gg</li></ul></li><li>跳到文件尾巴<ul><li>GG</li></ul></li><li>移动到行首<ul><li>^</li></ul></li><li>移动到行尾<ul><li>$</li></ul></li><li>按单词移动<ul><li>w 向前</li><li>b 向后</li></ul></li></ul><h5 id="3-查找与替换"><a href="#3-查找与替换" class="headerlink" title="3. 查找与替换"></a>3. 查找与替换</h5><ul><li>查找关键词，命令模式<ul><li>&#x2F;key</li></ul></li><li>查找并替换<ul><li>%s&#x2F;查找key&#x2F;替换key&#x2F;gc</li><li>gc用户决定每次匹配是否需要替换（y替换，n不替换）</li></ul></li></ul><h5 id="4-Vim-多窗口"><a href="#4-Vim-多窗口" class="headerlink" title="4. Vim 多窗口"></a>4. Vim 多窗口</h5><ul><li>分窗口命令<ul><li>split</li><li>vsplit</li></ul></li><li>窗口间切换<ul><li>ctrl + w</li></ul></li></ul><h5 id="5-其他操作"><a href="#5-其他操作" class="headerlink" title="5. 其他操作"></a>5. 其他操作</h5><ul><li>展示行号<ul><li>set number</li></ul></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>对于Vim编辑器的学习和使用，没有什么诀窍，就是多积累，多用</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 效率工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FFmpeg 技术基础</title>
      <link href="/2021/10/27/FFmpeg-%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/"/>
      <url>/2021/10/27/FFmpeg-%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h3 id="番外"><a href="#番外" class="headerlink" title="番外"></a>番外</h3><p>格式工厂居然被FFmpeg拉黑名单了，因为没有遵守开源协议，转身就把它卸载了。</p><h3 id="一、FFmpeg基础"><a href="#一、FFmpeg基础" class="headerlink" title="一、FFmpeg基础"></a>一、FFmpeg基础</h3><h5 id="1-FFmpeg处理音视频的流程"><a href="#1-FFmpeg处理音视频的流程" class="headerlink" title="1. FFmpeg处理音视频的流程"></a>1. FFmpeg处理音视频的流程</h5><ul><li>解复用(demuxer)：带封装格式的输入文件-&gt;编码数据包（音频，视频，字幕等）</li><li>解码(decoder)：编码数据包-&gt;解码后的数据帧</li><li>处理（processer）：对数据帧进行处理，比如转码、转分辨率、转帧率、加滤镜等</li><li>编码（encoder）：解码数据帧-&gt;编码数据包</li><li>复用（muxer）：编码数据包-&gt;输出带封装格式的文件</li><li>注意：<ul><li>对于转封装这样的操作，不需要进行处理操作，所以不需要进行解码和编码操作，demuxer之后直接muxer就可以。</li></ul></li></ul><span id="more"></span><h3 id="常用FFmpeg命令"><a href="#常用FFmpeg命令" class="headerlink" title="常用FFmpeg命令"></a>常用FFmpeg命令</h3><h5 id="1-基本信息查询类"><a href="#1-基本信息查询类" class="headerlink" title="1. 基本信息查询类"></a>1. 基本信息查询类</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-version</span><br><span class="line">-devices:显示可用设备</span><br><span class="line">-formats：支持的文件</span><br><span class="line">-muxer -demuxer：支持的封装和解封装</span><br><span class="line">-codecs -decoders：编解码器</span><br><span class="line">-filters：支持的所有过滤器</span><br></pre></td></tr></table></figure><h5 id="2-FFmpeg录制命令"><a href="#2-FFmpeg录制命令" class="headerlink" title="2. FFmpeg录制命令"></a>2. FFmpeg录制命令</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// MAC 平台录制视频</span><br><span class="line">ffmpeg -f avfoundation -i 1 -r 30 out.yuv</span><br><span class="line">// 参数用法</span><br><span class="line">-f // 格式，采用mac提供的avfoundation库来采集视频</span><br><span class="line">-i // 指定从哪里采集数据，1为屏幕设备的索引值，屏幕为1，摄像头为0</span><br><span class="line">-r // 指定帧率，这里为30帧</span><br><span class="line">// 播放录制的视频</span><br><span class="line">ffplay -video_size 2560x1600 -pix_fmt yuv420p out.yuv</span><br><span class="line">// 录制声音</span><br><span class="line">ffmpeg -f avfoundation -i :1 out.wav</span><br><span class="line">// 播放录制的声音</span><br><span class="line">ffplay out.wav</span><br></pre></td></tr></table></figure><h5 id="3-FFmpeg-分解与复用处理（媒体格式转换）"><a href="#3-FFmpeg-分解与复用处理（媒体格式转换）" class="headerlink" title="3. FFmpeg 分解与复用处理（媒体格式转换）"></a>3. FFmpeg 分解与复用处理（媒体格式转换）</h5><ul><li>一般的封装格式转换转换，比如.mp4转.flv</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// mp4转flv,这个的处理速度会非常的快</span><br><span class="line">ffmpeg -i input.mp4 -vcodec copy -acodec copy out.flv</span><br><span class="line">//参数介绍</span><br><span class="line">-vcodec copy // 视频编解码直接拷贝，不做更改</span><br><span class="line">-acodec copy // 音频编解码也不做更改</span><br></pre></td></tr></table></figure><ul><li>从视频中仅抽取视频或者音频</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 抽取已有视频流和音频流</span><br><span class="line">ffmpeg -i input.mp4 -an -vcodec copy out.h254</span><br><span class="line">ffmpeg -i input.mp4 -vn -acodec copy out.aac // 格式需要和视频中音频流的格式相同</span><br><span class="line">// 参数介绍</span><br><span class="line">-an: audio no,不要音频</span><br><span class="line">-vn: video no,不要视频</span><br></pre></td></tr></table></figure><h5 id="4-FFmpeg处理原始数据命令"><a href="#4-FFmpeg处理原始数据命令" class="headerlink" title="4. FFmpeg处理原始数据命令"></a>4. FFmpeg处理原始数据命令</h5><ul><li>原始数据<ul><li>视频原始数据：YUV数据</li><li>音频原视数据：PCM数据</li></ul></li><li>原始数据的提取是之后对音视频进行进一步处理的基础</li><li>提取YUV数据<ul><li>这个过程会有些长，因为涉及到编解码了</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 提取YUV数据</span><br><span class="line">ffmpeg -i input.mp4 -an -c:v rawvideo -pix_fmt yuv420p out.yuv</span><br><span class="line">// 参数意义</span><br><span class="line">-c:v rawvideo     // 指定视频的编码器，选择rawvideo编解码器，得到YUV</span><br><span class="line">-pix_fmt yuv420p  // 指定像素格式，这里一般指定为yuv420p （YUV4：2：0格式）</span><br><span class="line">// 播放YUV数据</span><br><span class="line">ffplay -video_size 2560x1600 -pix_fmt yuv420p out.yuv</span><br></pre></td></tr></table></figure><ul><li>提取PCM音频原视数据</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 提取PCM</span><br><span class="line">ffmpeg -i input.mp4 -vn -ar 44100 -ac 2 -f s16le out.pcm</span><br><span class="line">// 参数意义</span><br><span class="line">-ar 44100   // 设置音频采样率，常用的采样率，44.1kHZ，48kHZ，32kHZ，16kHZ</span><br><span class="line">-ac 2       // 设置声道</span><br><span class="line">-f s16le    // 指定pcm数据的存储格式</span><br><span class="line">// 播放PCM</span><br><span class="line">ffplay -ar 44100 -ac 2 -f s16le out.pcm </span><br></pre></td></tr></table></figure><h5 id="5-FFmpeg滤镜命令"><a href="#5-FFmpeg滤镜命令" class="headerlink" title="5. FFmpeg滤镜命令"></a>5. FFmpeg滤镜命令</h5><ul><li>基于avfilter组件，多用于多媒体的处理与编辑</li><li>可以实现加水印，去水印，画中画，裁剪，倍速播放</li><li>滤镜的工作原理<ul><li>对解码后的数据帧再进行过滤（处理）</li><li>对过滤后的帧再进行编码</li></ul></li><li>视频裁剪命令</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i input.mp4 -vf crop=in_w-200:in_h-200 -c:v libx264 -c:a copy out</span><br><span class="line">// 参数使用</span><br><span class="line">-vf crop=in_w-200:in_h-200  // 指定滤镜名字为裁剪，之后为该滤镜的参数，宽高为200</span><br><span class="line">-c:v libx264                // 指定视频处理的编码器</span><br><span class="line">-c:a copy                   // 音频不做处理</span><br></pre></td></tr></table></figure><ul><li>视频加水印命令</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// movie滤镜，添加水印</span><br><span class="line">ffmpeg -i input.flv -preset veryslow -c:v libx264 -c:a copy -vf &quot;movie=pic.png[wm];[in][wm] overlay=100:100[out]&quot; overlay.flv</span><br><span class="line">// 参数使用</span><br><span class="line">-preset veryslow  // 慢模式，最终视频质量损失较低</span><br></pre></td></tr></table></figure><h5 id="6-FFmpeg裁剪与合并命令"><a href="#6-FFmpeg裁剪与合并命令" class="headerlink" title="6. FFmpeg裁剪与合并命令"></a>6. FFmpeg裁剪与合并命令</h5><ul><li>视频裁剪命令</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 基于开始时间和时长进行裁剪</span><br><span class="line">ffmpeg -i input.flv -ss 00:00:00 -t 10 out.ts</span><br><span class="line">// 参数使用</span><br><span class="line">-ss 00:00:00  // 指定开始裁剪的时间，时：分：秒</span><br><span class="line">-t  10        // 裁剪的时长，以秒为单位</span><br></pre></td></tr></table></figure><ul><li>视频拼接命令</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 视频拼接命令</span><br><span class="line">ffmpeg -f concat -i input.txt out.flv</span><br><span class="line">// 参数</span><br><span class="line">-f concat       // 指定为拼接</span><br><span class="line">-i inputs.txt   //指定视频列表的文件</span><br><span class="line">// input.txt文件内容</span><br><span class="line">file &#x27;1.ts&#x27;</span><br><span class="line">file &#x27;2.ts&#x27;</span><br></pre></td></tr></table></figure><h5 id="7-图片-视频互转"><a href="#7-图片-视频互转" class="headerlink" title="7. 图片&#x2F;视频互转"></a>7. 图片&#x2F;视频互转</h5><ul><li>视频转图片</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 视频转多张图片序列</span><br><span class="line">ffmpeg -i input.flv -r 1 -f image2 image-%3d.jpeg</span><br><span class="line">// 参数使用</span><br><span class="line">-r 1    // 指定转换图片的频率，每秒转出一张</span><br><span class="line">-f image2 //  指定图片的输出格式</span><br><span class="line">image-%3d.jepg  // 文件名以image-加三个动态数字</span><br></pre></td></tr></table></figure><ul><li>多张图片序列转视频</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 图片转视频</span><br><span class="line">ffmpeg -i image-%3d.jpeg -r 1 out.mp4</span><br></pre></td></tr></table></figure><h5 id="8-直播相关的命令"><a href="#8-直播相关的命令" class="headerlink" title="8. 直播相关的命令"></a>8. 直播相关的命令</h5><ul><li>直播推流</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -re -i input.mp4 -c copy -f flv rtmp://ip:1935/live/stream_name</span><br><span class="line">//参数</span><br><span class="line">-re   // 减慢推流帧率速度, 如果不加的话，ffmpeg会把所有数据一股脑的把所有的数据推出去。本来一个2分钟的视频 他可能几秒钟就推完了</span><br><span class="line">-f flv 需要指定输出的格式为rtmp</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i rtmp://ip:1935/live/stream_name -c copy video.flv</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>内容</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 音视频 </tag>
            
            <tag> FFmpeg </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React前端项目的Docker化</title>
      <link href="/2021/10/26/React%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E7%9A%84Docker%E5%8C%96/"/>
      <url>/2021/10/26/React%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E7%9A%84Docker%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>之前的整个视频云项目都是直接部署在实验室的服务器上，前端直接通过Nginx进行部署（运用反向代理）。现在需要将开发完成的项目整体迁移到阿里云上进行部署，能够通过外网IP和域名进行访问。</p><h3 id="为什么要前端Docker化"><a href="#为什么要前端Docker化" class="headerlink" title="为什么要前端Docker化"></a>为什么要前端Docker化</h3><p>在进行选型的时候，选择了阿里云提供的Kubernetes容器计算服务，因为相比直接购买ECS云主机或者轻量云服务器，更适合我们项目前期的低使用率以及后期的可扩展性需求，不必花费几千元仅购买了个性能较强的云主机。并且将服务拆分为一个个小小的Docker中也更便于项目的运维和部署。</p><span id="more"></span><h3 id="前端Docker化思路"><a href="#前端Docker化思路" class="headerlink" title="前端Docker化思路"></a>前端Docker化思路</h3><h5 id="1-前端镜像形式"><a href="#1-前端镜像形式" class="headerlink" title="1. 前端镜像形式"></a>1. 前端镜像形式</h5><ul><li>以Nginx为基础镜像</li><li>将前端打包完成后的build内容copy到镜像中</li><li>将Nginx的配置文件Copy到镜像中的对应位置</li><li>启动nginx服务，对外暴露80端口</li></ul><h5 id="2-前端打包过程也要在构建中进行"><a href="#2-前端打包过程也要在构建中进行" class="headerlink" title="2. 前端打包过程也要在构建中进行"></a>2. 前端打包过程也要在构建中进行</h5><ul><li>直接将打包完成的build文件Copy进镜像是可行的，但是如果想使用阿里云提供的容器镜像仓库的自动构建服务，需要将前端的打包过程也在镜像构建的过程中进行。</li><li>我们知道，最终的前端镜像中不需要那些用于打包的各种依赖，并且实际上我们的代码仓库中，node_modules等依赖并没有添加到git仓库中。</li><li>Docker构建可以分阶段进行：也就是构建过程分为build环境和最终的production环境。</li><li>而通过Dockerfile正好支持这样的构建方式</li></ul><h3 id="所使用的Dockerfile文件"><a href="#所使用的Dockerfile文件" class="headerlink" title="所使用的Dockerfile文件"></a>所使用的Dockerfile文件</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># build environment</span></span><br><span class="line"><span class="keyword">FROM</span>   node as build</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash">/app</span></span><br><span class="line"><span class="keyword">ENV</span>    PATH /app/node_modules/.bin:$PATH</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash">   . /app</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash">    yarn</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash">   yarn build</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># production environment</span></span><br><span class="line"><span class="keyword">FROM</span>   nginx</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash">  --from=build /app/build /usr/share/nginx/html</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash">   <span class="built_in">rm</span> /etc/nginx/conf.d/default.conf</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash">   deploy/nginx.conf /etc/nginx/conf.d</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash">   [<span class="string">&quot;nginx&quot;</span>, <span class="string">&quot;-g&quot;</span>, <span class="string">&quot;daemon off;&quot;</span> ]</span></span><br></pre></td></tr></table></figure><h3 id="所使用的Nginx配置文件"><a href="#所使用的Nginx配置文件" class="headerlink" title="所使用的Nginx配置文件"></a>所使用的Nginx配置文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># deploy/nginx.conf</span><br><span class="line">server &#123;</span><br><span class="line">listen 80;</span><br><span class="line"></span><br><span class="line">location / &#123;</span><br><span class="line">root/usr/share/nginx/html;</span><br><span class="line">index index.htmlindex.htm;</span><br><span class="line">try_files $uri $uri//index.html;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">error_page 500 502 503 504/50x.html;</span><br><span class="line"></span><br><span class="line">location = /50x.html &#123;</span><br><span class="line">root/usr/share/nginx/html;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="问题与思考"><a href="#问题与思考" class="headerlink" title="问题与思考"></a>问题与思考</h3><h5 id="1-镜像的构建过程太漫长了"><a href="#1-镜像的构建过程太漫长了" class="headerlink" title="1. 镜像的构建过程太漫长了"></a>1. 镜像的构建过程太漫长了</h5><ul><li>主要时间大部分都用在了build环节，并且是依赖安装环节</li><li>缩减构建时间很重要</li><li>优化思路<ul><li>项目中有很多多余的依赖，去除这些未使用的依赖</li><li>更换yarn依赖安装的源（阿里似乎已经帮我们更换了）</li><li>区分依赖区分开发环境和生产环境，比如类似eslint这样的依赖，在生产打包中就不需要了。</li></ul></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>最后，由衷感受，Docker真是个好东西，搞技术的都应该学一下。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> React </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大脑Cahce系列--前端JavaScript系统梳理</title>
      <link href="/2021/10/14/%E5%89%8D%E7%AB%AFJavaScript%E7%B3%BB%E7%BB%9F%E6%A2%B3%E7%90%86/"/>
      <url>/2021/10/14/%E5%89%8D%E7%AB%AFJavaScript%E7%B3%BB%E7%BB%9F%E6%A2%B3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p>背景知识</p><ul><li>本文依然按照以往的风格，更注重JavaScript技术的系统性梳理，不赘述技术细节，因为Google一下就好。</li></ul></blockquote><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><h5 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1. 基础知识"></a>1. 基础知识</h5><ul><li>JavaScript：ES5&#x2F;6 + DOM + BOM<ul><li>ECMAScript 5 2015（ES6）</li><li>DOM: 针对HTML的编程接口</li><li>BOM：对浏览器进行操作的编程接口</li></ul></li><li>浏览器内核<ul><li>渲染引擎：Blink、Webkit（用于浏览器）</li><li>JS引擎：V8引擎</li></ul></li><li>标识符</li><li>strict mode<ul><li>严格模式：添加“use strict”</li><li>让代码变得更可靠</li><li>使用方式：全局使用，局部使用（在方法中使用）</li><li>推荐编写代码的时候使用严格模式</li></ul></li></ul><span id="more"></span><ul><li>语句<ul><li>表达式语句：习惯—最好以分号结尾</li><li>流控制语句：for-in, with</li><li>异常处理语句：</li><li>返回值：</li></ul></li><li>变量<ul><li>局部变量：需要添加var，没有的话会升级为全局变量</li><li>全局变量：</li></ul></li><li>数据类型：<ul><li>5种基础数据类型（undifend、null、Boolean、Number、String），以及Object。只限制这6种形式，不存在其他类型的类型</li><li>typeof运算符：不是函数，返回值为字符串（undefined, boolean, string, number, object, function）</li><li>undefined: 变量被声明但是未初始化</li><li>null: 空对象指针。当我们声明一个变量是为了保存一个对象时，但是没法立即给他初始化时候，最好把它设置为null，这样就知道未来这个变量是变量。</li><li>Number与String数据类型转换</li><li>Object类型：创建</li></ul></li><li>运算符<ul><li>JS种的奇技淫巧都来自于对运算符的使用</li><li>基础的运算符，和其他语言一样</li><li>布尔运算（!!取bool值,&amp;&amp;短路操作,||默认值）</li><li>相等运算符：相等（&#x3D;&#x3D;，!&#x3D;）,全等（&#x3D;&#x3D;&#x3D;，!&#x3D;&#x3D;）,他们的不同。</li><li>条件运算符</li></ul></li><li>函数<ul><li>function 声明</li><li>参数：arguments，参数都是值传递的（copy简单值，copy对象和函数指针），其实就是局部变量</li><li>没有函数重载，（不过可以通过模拟函数实现：通过对arguments进行解析判断）</li></ul></li></ul><h5 id="2-引用类型"><a href="#2-引用类型" class="headerlink" title="2.引用类型"></a>2.引用类型</h5><ul><li>Object</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#125; 等价于 new Object()</span><br><span class="line">a.b 等价于 a[b]</span><br></pre></td></tr></table></figure><ul><li>Array</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[] 等价于 new Array()</span><br><span class="line">array.length</span><br></pre></td></tr></table></figure><ul><li>判断是否是Array的两种方法：instanceof，isArray</li><li>typeof VS instanceof</li><li>Date：+ new Date() 得到时间戳</li><li>RegExp: 正则表达式</li><li>Function</li><li>单例内置对象<ul><li>window</li><li>Math</li></ul></li></ul><h5 id="3-作用域"><a href="#3-作用域" class="headerlink" title="3. 作用域"></a>3. 作用域</h5><ul><li>作用域链<ul><li>从外向内部的链条，内部可以访问外部，外部无法访问内部。内部没查找到，则向上外层继续查找</li></ul></li><li>this作用域：永远指向最后调用它的对象，具有一定的作用域。</li><li>bind():可以为函数调用绑定一个作用域（实际是一个对象）</li><li>没有块级作用域！！！，花括号无法延长作用域，只可以通过函数的方式来增加作用域</li><li>闭包：有权访问另一个函数作用域中的变量的函数</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">applyArr</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> arr = [];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;  <span class="comment">// 不存在块作用域，不会新增作用域</span></span><br><span class="line">    <span class="comment">// 不使用闭包</span></span><br><span class="line">    arr.<span class="title function_">push</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;  <span class="comment">//使用的i是applyArr的作用域，</span></span><br><span class="line">      <span class="keyword">return</span> i;           <span class="comment">// 最终在外部执行的时候，i取值一直都是10</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 使用闭包</span></span><br><span class="line">    (<span class="keyword">function</span>(<span class="params">index</span>)&#123;     <span class="comment">// 通过函数构造一个新的作用域,并将i作为参数传入</span></span><br><span class="line">      arr.<span class="title function_">push</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> index;     <span class="comment">// 这样return返回的时候，取得是新创建作用域中的值</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = <span class="title function_">applyArr</span>();</span><br><span class="line"><span class="keyword">var</span> b = arr[<span class="number">1</span>]();</span><br><span class="line"><span class="comment">// 如果不使用闭包，那么b最终的值为10</span></span><br><span class="line"><span class="comment">// 使用闭包后，b的值为1</span></span><br></pre></td></tr></table></figure><h5 id="4-面向对象的JavaScript"><a href="#4-面向对象的JavaScript" class="headerlink" title="4. 面向对象的JavaScript"></a>4. 面向对象的JavaScript</h5><ul><li>对象属性<ul><li>一般方法：直接赋值新增属性</li><li>数据属性：Object.defineProperty(obj,”name”,{configurable,enumerable,writable,value});</li><li>访问器属性：get，set</li></ul></li><li>创建对象<ul><li>工厂模式</li><li>构造函数模式</li><li>原型模式：prototype</li><li>构造函数与原型组合构造：属性放在构造函数中，方法放在原型中</li></ul></li><li>实例属性和原型属性<ul><li>in：“name” in obj， 用来判断实例obj是否有name属性</li><li>obj.hasOwnProperty(“name”): 用来判断在实例化之后的对象上，目标的属性是否是实例属性or实例方法。</li></ul></li><li>对象继承<ul><li>基于原型链的继承：缺点，属性也被继承了，继承的属性在子类中是原型属性</li><li>基于构造函数的继承：父类方法在子类中拷贝，资源浪费。</li><li>组合继承：</li></ul></li></ul><h5 id="5-DOM编程"><a href="#5-DOM编程" class="headerlink" title="5. DOM编程"></a>5. DOM编程</h5><ul><li>DOM节点<ul><li>节点间的关系：父子，兄弟</li><li>节点特征：nodeType,nodeName,nodeValue,parentNode…</li></ul></li><li>document节点的属性<ul><li>document.title：页面标题</li><li>document.referrer：来自于那个页面，用于安全性判断，防盗链</li><li>document.domain：解决域不同的问题</li></ul></li><li>DOM元素节点的默认属性<ul><li>.id</li><li>.className</li><li>.title</li><li>.lang：文本</li><li>.dir</li><li>.getAttribute(‘id’)</li></ul></li><li>DOM操作<ul><li>创建：document.createElement(“div”);</li><li>添加：someNode.appendChild(newNode);</li><li>插入：someNode.insertBefore(newNode,beforeChildNode);</li><li>替换：someNode.replaceChild(newNode,firstChild)</li><li>删除：someNode.remove(someNode.firstNode);</li><li>查找：document.getElementById(‘id’); document.getElementsByTagName()</li></ul></li></ul><h5 id="6-事件"><a href="#6-事件" class="headerlink" title="6. 事件"></a>6. 事件</h5><ul><li>事件流<ul><li>用来判断页面的哪一个部分会拥有某个特定的事件，即事件的定位</li><li>事件流：冒泡<ul><li>逐级向上级传递，接收和处理</li></ul></li><li>事件流：捕获<ul><li>从顶层节点向下传递，接收和处理</li></ul></li><li>DOM事件流：组合了冒泡<ul><li>先是捕获阶段，然后冒泡阶段，每个几点有两次处理事件的机会。</li></ul></li></ul></li><li>事件处理<ul><li>HTML标签中：比如onclick</li><li>DOM0事件处理：domElement.onclick &#x3D; function…</li><li>DOM2事件处理：element.addEventListener(“click”,function()…, true&#x2F;false),第三个参数指明是在捕获阶段true还是冒泡阶段处理事件。先绑定的事件先处理。</li></ul></li><li>事件处理跨浏览器<ul><li>封装跨浏览器的事件处理方法，比如安卓控制网页中的事件。</li></ul></li><li>event属性方法<ul><li>e.stopPropagation()：阻止事件冒泡</li><li>e.preventDefault(); 阻止一些默认事件</li></ul></li><li>事件类型<ul><li>各种事件，用的时候查</li><li>PC事件和移动端事件</li></ul></li></ul><h5 id="7-JSON数据通信"><a href="#7-JSON数据通信" class="headerlink" title="7. JSON数据通信"></a>7. JSON数据通信</h5><ul><li><p>JSON</p><ul><li>JSON是一种数据格式，和XML是编程语言</li><li>JSON更高效</li><li>JSON无法表示undifend类型</li><li>JSON字符串是双引号</li><li>JSON中的对象的属性也必须是字符串</li><li>JSON.stringify(obj)：将js对象序列化成json字符串</li><li>JSON.parse(jsonText,function(key,value))：解析JSON，第二个参数为解析函数</li></ul></li><li><p>AJAX</p><ul><li>异步加载</li><li>无需前端界面刷新</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&quot;get&quot;</span>,<span class="string">&quot;url&quot;</span>,<span class="literal">false</span>); <span class="comment">// 请求是否异步【异步：请求期间可以执行后续js，同步：不允许请求期间执行后续js】</span></span><br><span class="line">xhr.<span class="title function_">send</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="comment">// 同步的话</span></span><br><span class="line">xhr.<span class="property">status</span></span><br><span class="line">xhr.<span class="property">responseText</span></span><br><span class="line"><span class="comment">// 异步的话</span></span><br><span class="line">xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;  <span class="comment">//在执行的过程中会不断执行onreadystatechange</span></span><br><span class="line">  <span class="keyword">if</span>(xhr.<span class="property">readyState</span> === <span class="number">4</span>)&#123; <span class="comment">//0.未初始化，1.启动，2.发送，3.接收，4.完成</span></span><br><span class="line">    xhr.<span class="property">status</span></span><br><span class="line">    xhr.<span class="property">responseText</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="三、ES6"><a href="#三、ES6" class="headerlink" title="三、ES6"></a>三、ES6</h3><h5 id="1-历史"><a href="#1-历史" class="headerlink" title="1. 历史"></a>1. 历史</h5><ul><li>ES发展<ul><li>ES5</li><li>ES6 &#x3D; ES2015</li><li>ES2015… 一年一更</li></ul></li><li>Evergreen浏览器<ul><li>IE，chrome，firefox，opera…</li></ul></li><li>环境<ul><li>Node：执行环境</li><li>NPM： 依赖以及包管理工具</li><li>Babel：ECMASCRIPT的转译器，将先进的标准转化为已经支持的标准</li></ul></li><li>如何支持新标准<ul><li>原生支持：开发者查看浏览器的支持情况</li><li>Polyfill：以贴近新标准的方式封装API的效果</li><li>转译器：babel</li></ul></li></ul><h5 id="2-ES6的模块"><a href="#2-ES6的模块" class="headerlink" title="2. ES6的模块"></a>2. ES6的模块</h5><ul><li>模块<ul><li>易于拆分，模块加载</li><li>模块化</li></ul></li><li>模块加载规范<ul><li>UMD <ul><li>CommonJS</li><li>AMD</li></ul></li><li>CMD</li></ul></li><li>ES6中的模块加载</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// module1.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">methodA</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">methodB</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">methodC</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="comment">// module2.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; methodA &#125;<span class="keyword">from</span> <span class="string">&#x27;./module1.js&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li>打包工具<ul><li>browserify、webpack等：</li><li>将多个js模块进行整体打包成一个js文件</li><li>在打包之前需要先使用babel将ES6转化为ES5</li></ul></li></ul><h5 id="3-ES6的Class"><a href="#3-ES6的Class" class="headerlink" title="3. ES6的Class"></a>3. ES6的Class</h5><ul><li>不需要像ES5那样用原型取声明各种方法</li><li>class的typeof值其实也为function</li><li>class内部声明的是实例属性</li><li>ES6实际上是提供了一些语法糖</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">  <span class="title function_">getName</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> hh = <span class="keyword">new</span> <span class="title class_">ClassName</span>();</span><br></pre></td></tr></table></figure><ul><li>继承<ul><li>ES5特别麻烦，ES6就一个extends就可以了</li></ul></li></ul><h5 id="4-ES6常用特性"><a href="#4-ES6常用特性" class="headerlink" title="4. ES6常用特性"></a>4. ES6常用特性</h5><ul><li>解构赋值</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从data</span></span><br><span class="line"><span class="keyword">const</span> &#123;id = <span class="number">1</span>&#125; = data;</span><br></pre></td></tr></table></figure><ul><li>展开操作符</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组展开</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,...x]</span><br><span class="line"><span class="comment">//属性展开</span></span><br><span class="line">&#123;<span class="attr">a</span>:<span class="number">3</span>,<span class="attr">b</span>:<span class="number">4</span>,...c&#125;</span><br></pre></td></tr></table></figure><ul><li>取余</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[a,b,...rest] = [1,2,3,4,5,6]</span><br><span class="line">// a = 1</span><br><span class="line">// b = 2</span><br><span class="line">// rest = [3,4,5,6]</span><br></pre></td></tr></table></figure><ul><li>模板</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">`my name is <span class="subst">$&#123;name&#125;</span>`</span></span><br></pre></td></tr></table></figure><ul><li>Set 和 Map</li><li>类似ES5中的数组和对象</li><li>但是不允许出现元素的重复</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>]);</span><br><span class="line">set.<span class="title function_">add</span>(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>([</span><br><span class="line">  [<span class="string">&#x27;a&#x27;</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="string">&#x27;b&#x27;</span>,<span class="number">2</span>]]);</span><br><span class="line">map.<span class="title function_">put</span>(<span class="string">&#x27;c&#x27;</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure><ul><li>Generator函数和Iterator函数<ul><li>Generator用来实现状态机</li><li>Iterator用来实现迭代和遍历</li></ul></li></ul><h5 id="5-ES6的异步编程"><a href="#5-ES6的异步编程" class="headerlink" title="5.ES6的异步编程"></a>5.ES6的异步编程</h5><ul><li><p>回调函数&#x2F;事件</p><ul><li>遇到多种回调嵌套的时候写起来会很不友好</li></ul></li><li><p>Promise</p><ul><li>是异步编程的一种解决方案，比传统的基于回调函数和事件的方式更合理和强大</li><li>Promise对象代表一个异步操作，有三种状态<ul><li>Pending：进行中</li><li>Resolved：已完成</li><li>Rejected：已失效</li></ul></li><li>Promise.then()<ul><li>可以接受两个回调函数为参数: then（（resolved, rejected）&#x3D;&gt;{}）</li><li>then的返回值可以还是一个Promise对象，即仍是一个异步操作。<ul><li>可以采用链式写法，即then方法后再调用另一个then</li><li>后续的回调函数会等到该Promise对象处理完成之后才会被调用</li></ul></li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一个异步操作</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">p1</span> (value)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="title function_">someoperation</span>(value,...)=&gt;&#123;</span><br><span class="line">      <span class="keyword">if</span>(...)&#123;</span><br><span class="line">        <span class="title function_">reject</span>();</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="title function_">resolve</span>(value)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第二个异步操作</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">p2</span> (value)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="title function_">someoperation</span>(value,...)=&gt;&#123;</span><br><span class="line">      <span class="keyword">if</span>(...)&#123;</span><br><span class="line">        <span class="title function_">reject</span>();</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="title function_">resolve</span>(value)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 按照先1-&gt;2-&gt;1的顺序执行</span></span><br><span class="line"><span class="title function_">p1</span>(<span class="number">10</span>)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">p2</span>(value)</span><br><span class="line">&#125;, <span class="function"><span class="params">rej</span> =&gt;</span> &#123;&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">p1</span>(value)</span><br><span class="line">&#125;, <span class="function"><span class="params">rej</span> =&gt;</span> &#123;&#125;);</span><br></pre></td></tr></table></figure></li><li><p>asyncy异步编程</p></li></ul><h3 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h3>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 大脑Cache </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大脑Cache系列--系统地梳理下CSS3技术吧</title>
      <link href="/2021/10/10/CSS%E6%8A%80%E6%9C%AF%E7%B3%BB%E7%BB%9F%E6%A2%B3%E7%90%86/"/>
      <url>/2021/10/10/CSS%E6%8A%80%E6%9C%AF%E7%B3%BB%E7%BB%9F%E6%A2%B3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><blockquote><ul><li>视频云的开发已经进入正常的开发流程了，对前端框架层面已经有了一定的了解，需要返回补充前端核心接触知识了。</li><li>在实际的开发中，调整样式总是花了我前端开发的一大半时间，主要还是对CSS不太熟悉，有必要系统学习一下。</li><li>本文依然按照以往的风格，更注重CSS技术的系统性梳理，不赘述技术细节，因为Google一下就好。</li></ul></blockquote><h3 id="CSS基础"><a href="#CSS基础" class="headerlink" title="CSS基础"></a>CSS基础</h3><h5 id="1-CSS的几种引入方式"><a href="#1-CSS的几种引入方式" class="headerlink" title="1.  CSS的几种引入方式"></a>1.  CSS的几种引入方式</h5><ul><li>head中直接添加文档内样式代码</li></ul><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">&#123;</span><br><span class="line">    body&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><ul><li>head中引入外部样式</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;common.css&quot;&gt;</span><br></pre></td></tr></table></figure><ul><li>元素的style样式</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&quot;width:200px&quot;&gt;</span><br></pre></td></tr></table></figure><h5 id="2-CSS3的几种选择器"><a href="#2-CSS3的几种选择器" class="headerlink" title="2.CSS3的几种选择器"></a>2.CSS3的几种选择器</h5><ul><li>简单选择器（type，#id, .class）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">每个元素的id是唯一的，class可以多个元素同时用</span><br><span class="line">选择器组</span><br><span class="line">ul, ol &#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>属性选择器</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.class[width = 200px]&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>上下文选择器</li><li>伪类选择器</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//结构化伪类选择器</span><br><span class="line">e:first-child&#123;&#125; //第一个子元素设置</span><br><span class="line">e:last-child&#123;&#125;</span><br><span class="line">e:nth-child(2n+1)&#123;&#125; //奇数位置元素</span><br><span class="line">//UI伪类选择器</span><br><span class="line">e:visited&#123;&#125;</span><br><span class="line">hover,focus,active, checked</span><br></pre></td></tr></table></figure><ul><li>伪元素选择器</li></ul><h5 id="3-CSS的级联Casscading"><a href="#3-CSS的级联Casscading" class="headerlink" title="3. CSS的级联Casscading"></a>3. CSS的级联Casscading</h5><ul><li>级联：一个元素可能会被多个CSS选择器选中，就会产生层叠&#x2F;级联效果。</li><li>优先级规则算法：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 首先会判断重要性important</span><br><span class="line">    a &#123;</span><br><span class="line">        color:blue; !important</span><br><span class="line">    &#125;</span><br><span class="line">2. 规则来源： 开发者设置 &gt; 用户设置  &gt; 浏览器预设</span><br><span class="line">2. 基于明确程度，ID &gt; Class &gt; Type , 算法通过（I-C-T）分量来判断</span><br><span class="line">3. 顺序：后添加的生效</span><br></pre></td></tr></table></figure><h5 id="4-CSS的继承"><a href="#4-CSS的继承" class="headerlink" title="4. CSS的继承"></a>4. CSS的继承</h5><ul><li>子元素会继承来自父元素的属性</li><li>不是所有的属性都是可继承的</li></ul><h5 id="5-厂商前缀"><a href="#5-厂商前缀" class="headerlink" title="5. 厂商前缀"></a>5. 厂商前缀</h5><ul><li>为了解决不同厂商的浏览器的兼容问题</li><li>常见的厂商前缀</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Chrome:     -webkit</span><br><span class="line">Firefox:    -moz</span><br><span class="line">Opera:      -o</span><br><span class="line">Safari:     -webkit</span><br></pre></td></tr></table></figure><h3 id="CSS布局"><a href="#CSS布局" class="headerlink" title="CSS布局"></a>CSS布局</h3><h5 id="1-float"><a href="#1-float" class="headerlink" title="1. float"></a>1. float</h5><h5 id="2-Postion定位"><a href="#2-Postion定位" class="headerlink" title="2. Postion定位"></a>2. Postion定位</h5><h5 id="3-Flex"><a href="#3-Flex" class="headerlink" title="3. Flex"></a>3. Flex</h5><p>内容</p><h3 id="CSS高级"><a href="#CSS高级" class="headerlink" title="CSS高级"></a>CSS高级</h3><h5 id="1-媒体查询"><a href="#1-媒体查询" class="headerlink" title="1. 媒体查询"></a>1. 媒体查询</h5><ul><li>用来实现响应式布局控制</li><li>类似编程语言中的if语句</li><li>指定一组媒体条件，在满足所有媒体条件的时候，应用新的样式规则</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@media(max-width:600px) and (width&lt;=600px) and (mf2) &#123;</span><br><span class="line">    prestyle&#123;</span><br><span class="line">        new style</span><br><span class="line">    &#125;</span><br><span class="line">    rules&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开源库：<a href="https://github.com/scottjehl/Respond/">Respond.js</a></p><h5 id="2-mobile-first-的响应式设计"><a href="#2-mobile-first-的响应式设计" class="headerlink" title="2. mobile first 的响应式设计"></a>2. mobile first 的响应式设计</h5><ul><li>之前的实现都是宽屏优先的，初始样式是面向宽屏的。</li><li>移动优先的初始设计是面向手机设备，然后对逐渐宽屏进行响应式设计。</li><li>优点：移动端是趋势，移动设备加载更快，在移动设备上不会去下载宽屏的样式文件。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">css rules for mobile device </span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">@media screen and (min-width:768px)&#123;</span><br><span class="line">    rule1</span><br><span class="line">    rule2</span><br><span class="line">&#125;</span><br><span class="line">// 769px小屏， 972px中屏，1200px大屏</span><br></pre></td></tr></table></figure><h5 id="3-CSS3的Transform"><a href="#3-CSS3的Transform" class="headerlink" title="3. CSS3的Transform"></a>3. CSS3的Transform</h5><ul><li>为元素添加变形和变换效果，2D和3D</li><li>行内元素（inline）不是transformable元素，其他常见的都是的</li><li>Transform 对于元素的内容，边框，边距等都会生效。</li><li>实质上是进行矩阵变换</li><li>默认以元素的中心为Transform的基点，可以通过transform-origin更改</li><li>几个基本操作</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">transform: rotate(45deg);   //旋转45度，度数可以是负数</span><br><span class="line">transform: scale(x-value,y-value); //x,y方向上的缩放</span><br><span class="line">transform: translate(x-value,y-value)//在xy上移动</span><br><span class="line">transform: skew(45deg,45deg)   //x和y方向上倾斜度数</span><br><span class="line">transform: rotate(45deg) scale(3);  //多个transform组合使用，需要注意的是从右向左生效的</span><br><span class="line">transform-origin: left top; //将Transform的基点变成左上角</span><br></pre></td></tr></table></figure><h5 id="4-CSS3的Transition"><a href="#4-CSS3的Transition" class="headerlink" title="4. CSS3的Transition"></a>4. CSS3的Transition</h5><ul><li>用于给文档中的样式变化添加过渡效果</li><li>不是所有的CSS属性都可以添加过渡效果</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">transition-property: width, background-color;     //设置transition关注的属性值的变化</span><br><span class="line">transition-property: all;       //为所有的可添加属性添加transition效果</span><br><span class="line">transition-duration: 3s, 1ms;        //各个属性平滑过渡效果的持续时长</span><br><span class="line">transition-delay：1s, 2ms;      //执行过渡效果动画的等待时间</span><br><span class="line">transition-timing-function: linear | ease-in | ease-out | ease-in-out | ease; //设置渐变的时间函数(常用的5个)</span><br><span class="line">transition: property duration func delay;       // 简写属性</span><br></pre></td></tr></table></figure><h5 id="6-CSS3的Animation"><a href="#6-CSS3的Animation" class="headerlink" title="6. CSS3的Animation"></a>6. CSS3的Animation</h5><ul><li>与Transition的不同：Animation可以支持一个系列的变化，而Transition只能实现从一个状态过渡到另一个</li><li>实现本质方式：指定元素在动画中的关键帧状态</li><li>例子： 实现弹球动画</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 先定义了一个动画序列效果</span><br><span class="line">@Keyframes bounce &#123;     </span><br><span class="line">    0% &#123;</span><br><span class="line">        left: 0px;</span><br><span class="line">        top: 0px;</span><br><span class="line">    &#125;</span><br><span class="line">    0% &#123;</span><br><span class="line">        left: 50px;</span><br><span class="line">        top: 100px;</span><br><span class="line">    &#125;</span><br><span class="line">    0% &#123;</span><br><span class="line">        left: 100px;</span><br><span class="line">        top: 0px;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 应用动画序列效果</span><br><span class="line">.box:hover .ball &#123;</span><br><span class="line">    animation: bounce 4s linear 0s;     //鼠标悬停的时候触发动画</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>动画循环次数属性：animation-iteration-count</li><li>动画方向属性：animation-direction</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>内容</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 大脑Cache </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BroswerRouter以及HashRouter的React前端项目在Nginx上部署</title>
      <link href="/2021/09/28/BroswerRouter%E4%BB%A5%E5%8F%8AHashRouter%E7%9A%84React%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E5%9C%A8Nginx%E4%B8%8A%E9%83%A8%E7%BD%B2/"/>
      <url>/2021/09/28/BroswerRouter%E4%BB%A5%E5%8F%8AHashRouter%E7%9A%84React%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E5%9C%A8Nginx%E4%B8%8A%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>背景：视频云的前端项目使用了React框架，并通过React-Router实现了SPA单页应用。前端包括管理端和观看端，而React-Router有两种常用类型的Router，分别是HashRouter以及BrowserRouter，为了体验二者的不同，在管理端使用了HashRouter，而在观看端使用了HashRouter。</p></blockquote><h3 id="两种React-Router"><a href="#两种React-Router" class="headerlink" title="两种React-Router"></a>两种React-Router</h3><h5 id="1-HashRouter"><a href="#1-HashRouter" class="headerlink" title="1. HashRouter"></a>1. HashRouter</h5><ul><li>history: 使用 hash history</li><li>通过Hash部分来表示路由，属于浏览器端路由，Hash部分在请求的时候并不会提交到服务器，也就是说不管是请求 #foo 还是 #bar ，服务只知道请求了 index.html 并不知道 hash 部分的细节。</li><li>url样例：&#x2F;#&#x2F;user</li><li>不需要服务器支持，由浏览器负责路由。</li></ul><span id="more"></span><h5 id="2-BrowserRouter"><a href="#2-BrowserRouter" class="headerlink" title="2. BrowserRouter"></a>2. BrowserRouter</h5><ul><li>使用的是 HTML5 的 History API，浏览器提供相应的接口来修改浏览器的历史记录</li><li>需要服务器支持，属于服务器路由</li><li>url样例：&#x2F;user&#x2F;lives</li><li>路由直接在URL中，原则上每次URL切换的时候，都会像服务器请求页面</li><li>但借助html5里面history的新的api，可以使用js改变url的值，而不会向服务端发请求。(刷新界面的时候还是会请求页面)</li><li>是react-router官方推荐的</li></ul><h3 id="使用Nginx部署的时候需要特殊的配置"><a href="#使用Nginx部署的时候需要特殊的配置" class="headerlink" title="使用Nginx部署的时候需要特殊的配置"></a>使用Nginx部署的时候需要特殊的配置</h3><ul><li>传统的前端部署之后，浏览器都是直接通过浏览器地址栏中的uri去请求服务器对应位置的文件，而在使用React-Router进行路由管理来实现SPA之后，依然采用这样的配置的话，初次加载首页是正常的，但当浏览器URI被改变之后，再点击刷新，则页面不显示或者404错误。</li><li>原因在于，使用React-Router之后，页面内的路由是由前端自行渲染的，未通过后端，而是js动态更改了location。而当我们刷新界面时，首先访问的是后台地址，然后在返回的页面中再去加载React代码并执行。</li><li>问题在于，React应用在运行的时候可能会去更改浏览器的URL，而实际服务器上可能并不存在与URI对应的资源（因为资源的定位已经交给React来做了），所以刷新页面的时候，浏览器直接用URI去寻找资源，可想而知会产生异常（404或者不显示）。</li><li>而我们使用Webpack来打包React之后，最终的输出就是一个index.html附加一些文件，当然文件的定位逻辑也存在这些文件中。所以，默认的由Nginx服务器来定位这些资源的方式是行不通的，需要将该任务交给React本身来做。</li><li>所以，思路是，浏览器在使用React应用期间，无论URI是否更改，服务器都直接无脑返回index.html这个页面就可以，浏览器得到index.html，加载React，剩下的任务都交给React本身去做就好了。</li><li>使用Nginx的try_files，来将前端的请求都映射到index.html。</li></ul><h3 id="部署HashRouter的Nginx配置"><a href="#部署HashRouter的Nginx配置" class="headerlink" title="部署HashRouter的Nginx配置"></a>部署HashRouter的Nginx配置</h3><ul><li>在Nginx中配置一个vhost</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nginx.conf整体配置大概如下：</span></span><br><span class="line">server &#123;</span><br><span class="line">    listen 8083;</span><br><span class="line">    root /home/name/..../build; <span class="comment"># 前端build完成之后的静态资源路径</span></span><br><span class="line">    index index.html index.htm;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        try_file <span class="variable">$uri</span> <span class="variable">$uri</span>/ /index.html;  <span class="comment"># url 切换时始终返回index.html</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 其他配置</span></span><br><span class="line">    <span class="comment"># 图片样式缓存1年</span></span><br><span class="line">    location ~* /app.*\.(js|css|png|jpg)$ &#123;</span><br><span class="line">       access_log off;</span><br><span class="line">        expires    365d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># html/xml/json 文件不缓存</span></span><br><span class="line">    location ~* /app.*\.(?:manifest|appcache|html?|xml|json)$ &#123;</span><br><span class="line">        expires    -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>部署项目的时候搞得很头痛和低效，深入搞明白之后，再也不怕React前端的部署了。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li>1.<a href="https://www.cnblogs.com/soyxiaobi/p/11096940.html">react-router-dom下的BrowserRouter和HashRouter</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搞定跨域资源共享CORS（笔记整理）</title>
      <link href="/2021/09/23/%E6%90%9E%E5%AE%9A%E8%B7%A8%E5%9F%9F%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%ABCORS%EF%BC%88%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%EF%BC%89/"/>
      <url>/2021/09/23/%E6%90%9E%E5%AE%9A%E8%B7%A8%E5%9F%9F%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%ABCORS%EF%BC%88%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<blockquote><p>当从一个域向另一个不同的域或者端口请求资源的时候，会产生跨域请求。<br><img src="http://zwboy.oss-cn-beijing.aliyuncs.com/blog/kuayu.png" alt="跨域.png"></p></blockquote><h3 id="一、什么是跨域"><a href="#一、什么是跨域" class="headerlink" title="一、什么是跨域"></a>一、什么是跨域</h3><ol><li>同源政策（same origin policy）：协议，主机名和端口号要相同，否则就会产生跨域请求。</li><li>通常的错误形式：Access to XMLHttpRequest at XXX has been blocked by CORS policy: No ‘Access-Control-Allow-Origin’ header is present on the requested resource.</li><li>整个CORS通信过程，都是浏览器自动完成，不需要用户参与。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。</li><li>出于安全原因，浏览器限制从脚本内发起的跨源HTTP请求（或者跨域响应被拦截）。比如XMLHttpRequest和Fetch API都需要遵循同源策略。</li><li>实现CORS必须要在服务器端实现CORS接口，即响应报文包含了正确CORS响应头。</li></ol><span id="more"></span><h3 id="二、为何要限制跨域"><a href="#二、为何要限制跨域" class="headerlink" title="二、为何要限制跨域"></a>二、为何要限制跨域</h3><blockquote><p>跨站请求攻击CSRF<br><img src="http://zwboy.oss-cn-beijing.aliyuncs.com/blog/csrf.png" alt="CSRF.png"></p></blockquote><ol><li>攻击者引导用户去登录访问正常的网站，比如银行，session_id等认证会留在浏览器中。</li><li>同时用户还在访问攻击者提供的网站，但是该网站会自动或者通过点击触发向之前正常的网站发起请求，当然用了之前已经认证过的session_id。</li><li>这样就在用户不知道的情况下进行了一些诸如发送邮件，甚至转账、购买商品等操作。</li><li>其利用的是Web用户身份验证的漏洞，即，简单的身份验证智能保证请求是来自该用户的浏览器（不是其他人在另一个浏览器伪造），但是并不能保证请求是用户本身自愿发出的。</li><li>同源政策将会确保网站a拒绝来自网站b的请求。</li></ol><h3 id="三、为何又需要跨域呢"><a href="#三、为何又需要跨域呢" class="headerlink" title="三、为何又需要跨域呢"></a>三、为何又需要跨域呢</h3><blockquote><p>前后端分离</p></blockquote><p>当前端框架兴起之后，前后端彻底分离的开发方式渐渐流行。前端和后端往往部署在不同的域名之上。前端通过访问后端的API获取数据，渲染前端界面，甚至进行路由跳转。这通常意味着前后端会出现不同源的问题。因为即使部署在同一台主机上，二者也属于不同的端口。那么我们就需要某种策略使得跨域请求能够通过。</p><h3 id="四、跨域请求过程"><a href="#四、跨域请求过程" class="headerlink" title="四、跨域请求过程"></a>四、跨域请求过程</h3><blockquote><p>浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。</p></blockquote><h5 id="1-简单请求的跨域过程"><a href="#1-简单请求的跨域过程" class="headerlink" title="1. 简单请求的跨域过程"></a>1. 简单请求的跨域过程</h5><ul><li>1.1. 简单请求是什么</li></ul><blockquote><ol><li>请求方法是以下三种方法之一（简单方法）：HEAD，GET，POST</li><li>HTTP的头信息不超出以下几种字段（简单头）：Accept，Accept-Language，Content-Language，Last-Event-ID，Content-Type：只限于三个值application&#x2F;x-www-form-urlencoded、multipart&#x2F;form-data、text&#x2F;plain</li></ol></blockquote><ul><li>1.2. 跨域过程</li></ul><blockquote><ol><li>浏览器检测到这是一个简单请求，会自动在Header中添加Origin字段，该字段描述了协议，域名以及端口的信息。</li><li>服务器会检查Origin，如果不在许可范围内（allow-origin），就会返回一个正常的HTTP回应，浏览器会抛出异常。如果在，服务器会返回响应，响应Header中会怎加几个头信息字段。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Allow</span>-<span class="title class_">Origin</span>:* <span class="comment">//服务器接收的origin</span></span><br><span class="line"><span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Allow</span>-<span class="title class_">Credentials</span>: <span class="literal">true</span> <span class="comment">// 服务器是否允许CORS请求中发送Cookie。</span></span><br><span class="line"><span class="comment">//如果想实现发送Cookie的话，还需要在浏览器端设置withCredentials = true;</span></span><br><span class="line"><span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Expose</span>-<span class="title class_">Headers</span>: <span class="comment">// ResponsHeader中暴露的字段</span></span><br></pre></td></tr></table></figure></li></ol></blockquote><h5 id="2-非简单请求的跨域过程"><a href="#2-非简单请求的跨域过程" class="headerlink" title="2. 非简单请求的跨域过程"></a>2. 非简单请求的跨域过程</h5><blockquote><p>比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application&#x2F;json，含有自定义的请求头等。</p></blockquote><ul><li>Step.1. 预检请求Preflight</li></ul><blockquote><p>旨在确保服务器对 CORS 标准知情，以保护不支持 CORS 的旧服务器</p><ol><li>浏览器发现是非简单请求，会在正式的通信之前，先向服务器询问当前网页所在的域名是否在服务器的许可名单中，以及可以使用哪些HTTP动词。</li><li>预检请求是一个OPTION请求，会携带Access-Control-Request-Method（指明该跨域请求的Method），Access-Control-Request-Headers（该跨域请求额外会发送的头信息字段，比如认证字段）以及Origin信息。</li><li>服务器检查以上三个字段，确认允许后就会做出回应。（服务器在设置跨域请求的时候不能忘记对预检请求的处理）。回应Header包括Access-Control-Allow-Methods，Access-Control-Allow-Headers，Access-Control-Allow-Credentials等。</li></ol></blockquote><ul><li>Step.2. 预检成功后再发起跨域请求</li></ul><blockquote><p>预检通过之后，浏览器会像简单请求一样，再发送正式的CORS请求。<br><img src="http://zwboy.oss-cn-beijing.aliyuncs.com/blog/cros-yujian.png" alt="d"></p></blockquote><h3 id="五、服务器配置CORS"><a href="#五、服务器配置CORS" class="headerlink" title="五、服务器配置CORS"></a>五、服务器配置CORS</h3><p>以nodejs koa为例，如下为koa corszho</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">const URL = require(&#x27;url&#x27;);</span><br><span class="line">/**</span><br><span class="line"> * 关键点：</span><br><span class="line"> * 1、如果需要支持 cookies,</span><br><span class="line"> *    Access-Control-Allow-Origin 不能设置为 *,</span><br><span class="line"> *    并且 Access-Control-Allow-Credentials 需要设置为 true</span><br><span class="line"> *    (注意前端请求需要设置 withCredentials = true)</span><br><span class="line"> * 2、当 method = OPTIONS 时, 属于预检(复杂请求), 当为预检时, 可以直接返回空响应体, 对应的 http 状态码为 204</span><br><span class="line"> * 3、通过 Access-Control-Max-Age 可以设置预检结果的缓存, 单位(秒)</span><br><span class="line"> * 4、通过 Access-Control-Allow-Headers 设置需要支持的跨域请求头</span><br><span class="line"> * 5、通过 Access-Control-Allow-Methods 设置需要支持的跨域请求方法</span><br><span class="line"> */</span><br><span class="line">module.exports = async function (ctx, next) &#123;</span><br><span class="line">    const origin = URL.parse(ctx.get(&#x27;origin&#x27;) || ctx.get(&#x27;referer&#x27;) || &#x27;&#x27;);</span><br><span class="line">    if (origin.protocol &amp;&amp; origin.host) &#123;</span><br><span class="line">        ctx.set(&#x27;Access-Control-Allow-Origin&#x27;, `$&#123;origin.protocol&#125;//$&#123;origin.host&#125;`);</span><br><span class="line">        ctx.set(&#x27;Access-Control-Allow-Methods&#x27;, &#x27;POST, GET, OPTIONS, DELETE, PUT&#x27;);</span><br><span class="line">        ctx.set(&#x27;Access-Control-Allow-Headers&#x27;, &#x27;X-Requested-With, User-Agent, Referer, Content-Type, Cache-Control,accesstoken&#x27;);</span><br><span class="line">        ctx.set(&#x27;Access-Control-Max-Age&#x27;, &#x27;86400&#x27;);</span><br><span class="line">        ctx.set(&#x27;Access-Control-Allow-Credentials&#x27;, &#x27;true&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (ctx.method !== &#x27;OPTIONS&#x27;) &#123;</span><br><span class="line">        // 如果请求类型为非预检请求，则进入下一个中间件（包括路由中间件等）</span><br><span class="line">        await next();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 当为预检时，直接返回204,代表空响应体</span><br><span class="line">        ctx.body = &#x27;&#x27;;</span><br><span class="line">        ctx.status = 204;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在开发前端的过程中CROS问题总是让自己很头痛，前期花费了大量时间解决CROS问题。再了解了CROS的原理和过程后，对跨域问题不再畏惧。</p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ol><li><a href="https://segmentfault.com/a/1190000015017666">https://segmentfault.com/a/1190000015017666</a></li><li><a href="http://www.ruanyifeng.com/blog/2016/04/cors.html">跨域资源共享 CORS 详解</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS">HTTP访问控制（CORS）</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在一台服务器上通过Nginx反向代理配置多个二级域名映射多个不同端口的应用</title>
      <link href="/2021/09/21/%E5%9C%A8%E4%B8%80%E5%8F%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E9%80%9A%E8%BF%87Nginx%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AA%E4%BA%8C%E7%BA%A7%E5%9F%9F%E5%90%8D%E6%98%A0%E5%B0%84%E5%A4%9A%E4%B8%AA%E4%B8%8D%E5%90%8C%E7%AB%AF%E5%8F%A3%E7%9A%84%E5%BA%94%E7%94%A8/"/>
      <url>/2021/09/21/%E5%9C%A8%E4%B8%80%E5%8F%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E9%80%9A%E8%BF%87Nginx%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AA%E4%BA%8C%E7%BA%A7%E5%9F%9F%E5%90%8D%E6%98%A0%E5%B0%84%E5%A4%9A%E4%B8%AA%E4%B8%8D%E5%90%8C%E7%AB%AF%E5%8F%A3%E7%9A%84%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>背景：需要在实验室服务器上部署gitlab，jira，jenkins等等Server服务，这些服务工作在不同的端口，无法直接通过http的80端口访问，所以之前是通过IP+端口号的方式进行访问。在申请了自己的一个域名之后，想要通过多个二级域名来访问。</p></blockquote><h4 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h4><p>能够通过gitlab.domain.cn访问绑定在82端口上的gitlab服务，通过jenkins.domain.cn访问绑定在9090端口上的jenkins服务。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul><li>1.在域名的解析中分别添加gitlab, jenkins,以及www三个记录，指向均为实验室服务器的IP地址。</li><li>2.使用Nginx作为代理服务器，监听80端口，通过server_name进行匹配，将请求转发到对应的应用服务器。(这应该属于Nginx的反向代理功能，即为多个服务提供代理服务)</li></ul><span id="more"></span><h4 id="实际解决"><a href="#实际解决" class="headerlink" title="实际解决"></a>实际解决</h4><ul><li>1.编辑Nginx配置信息（Ubuntu）<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置文件路径：/etc/nginx/conf.d/domain.conf，（没有的话需要创建）</span></span><br><span class="line"><span class="comment"># Nginx会自动include /etc/nginx/conf.d 目录下所有以.conf结尾的配置到主配置文件nginx.conf中.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 起一个服务，端口80</span></span><br><span class="line">server &#123;</span><br><span class="line">        listen 80;  <span class="comment"># 设置Nginx对外监听80端口</span></span><br><span class="line">        server_name *.domain.cn;  <span class="comment"># 绑定到该服务器的域名</span></span><br><span class="line">        <span class="keyword">if</span> ( <span class="variable">$http_host</span> ~* <span class="string">&quot;^(.*?)\.domain\.cn&quot;</span> ) &#123;  <span class="comment"># 对http_host进行正则匹配，解析domain</span></span><br><span class="line">                <span class="built_in">set</span> <span class="variable">$domain</span> <span class="variable">$1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        location / &#123;</span><br><span class="line">                proxy_set_header        X-Real-IP       <span class="variable">$remote_addr</span>;</span><br><span class="line">                proxy_set_header        Host            <span class="variable">$http_host</span>;</span><br><span class="line">                <span class="comment"># 分别处理各个domain</span></span><br><span class="line">                <span class="keyword">if</span> ( <span class="variable">$domain</span> ~* <span class="string">&quot;www&quot;</span> ) &#123;</span><br><span class="line">                        proxy_pass http://localhost:82;  <span class="comment"># 通过proxy_pass 进行代理转发</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> ( <span class="variable">$domain</span> ~* <span class="string">&quot;gitlab&quot;</span> ) &#123;</span><br><span class="line">                        proxy_pass http://localhost:82;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> ( <span class="variable">$domain</span> ~* <span class="string">&quot;jenkins&quot;</span> ) &#123;</span><br><span class="line">                        proxy_pass http://localhost:9090;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>2.检查配置文件合法性<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 需要将nginx添加到环境变量中</span></span><br><span class="line">sudo nginx -t</span><br></pre></td></tr></table></figure></li><li>3.更新Nginx配置<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nginx -s reload</span><br></pre></td></tr></table></figure></li></ul><h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><ul><li>可以为多个相同的后端服务在反向代理的同时实现负载均衡</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置jenkins负载均衡</span></span><br><span class="line">upstream jenkins &#123;      <span class="comment"># 默认负载均衡规则为轮询 </span></span><br><span class="line">      server      http://localhost:9090 weight = 5;      <span class="comment"># 可以设置权重</span></span><br><span class="line">      server      http://10.10.x.x:9090 weight = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">        listen 80;  <span class="comment"># 设置Nginx对外监听80端口</span></span><br><span class="line">        server_name *.domain.cn;  <span class="comment"># 绑定到该服务器的域名，server也可以是正则表达式</span></span><br><span class="line">        <span class="keyword">if</span> ( <span class="variable">$http_host</span> ~* <span class="string">&quot;^(.*?)\.domain\.cn&quot;</span> ) &#123;  <span class="comment"># 对http_host进行正则匹配，解析domain</span></span><br><span class="line">                <span class="built_in">set</span> <span class="variable">$domain</span> <span class="variable">$1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        location / &#123;</span><br><span class="line">                proxy_set_header        X-Real-IP       <span class="variable">$remote_addr</span>;</span><br><span class="line">                proxy_set_header        Host            <span class="variable">$http_host</span>;     <span class="comment"># 不可缺，否则无法代理</span></span><br><span class="line">                <span class="comment"># 分别处理各个domain</span></span><br><span class="line">                <span class="keyword">if</span> ( <span class="variable">$domain</span> ~* <span class="string">&quot;gitlab&quot;</span> ) &#123;</span><br><span class="line">                        proxy_pass http://jenkins;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> ( <span class="variable">$domain</span> ~* <span class="string">&quot;jenkins&quot;</span> ) &#123;</span><br><span class="line">                        proxy_pass http://localhost:9090;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h4><p>最开始的思路是在Nginx中配置多个server块，再每个块中再配置proxy_pass来实现，配置文件如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># jenkins.domain.cn.conf</span></span><br><span class="line">server &#123;</span><br><span class="line">        listen 80;  <span class="comment"># 设置Nginx对外监听80端口</span></span><br><span class="line">        server_name jenkins.domain.cn;  </span><br><span class="line">        proxy_pass http://localhost:9090;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># gitlab.domain.cn.conf</span></span><br><span class="line">server &#123;</span><br><span class="line">        listen 80;  <span class="comment"># 设置Nginx对外监听80端口</span></span><br><span class="line">        server_name gitlab.domain.cn;  </span><br><span class="line">        proxy_pass http://localhost:82;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Reload Nginx之后发现，二级域名是失效的，两个域名均指向的是gitlab，无法实现想要的效果。分析应该是gitlab.domain.cn.conf先被include到nginx.conf中（和文件顺序有关），所以生效的是gitlab吧。<br>不确定，还需要进一步研究。<br>2019.12.12，问题解决，（果然是按照配置文件顺序匹配的）</p><ul><li>当时咋想的，两个server listen同一个端口</li><li>另外，Nginx 中server的匹配顺序如下</li><li>1.精确匹配</li><li>2.匹配*.zwboy.cn这样的泛域名</li><li>3.按照文件顺序匹配</li><li>4.都没匹配，则匹配第一个，或者listen设置为default的server</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>Nginx是个强大的工具，可以作为Web服务器，文件服务器，代理服务器，反向代理服务器，直播服务器，负载均衡服务器等等，值得深入学习。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
            <tag> 反向代理 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
